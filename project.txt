‚îú‚îÄ ./
‚îÇ   ‚îú‚îÄ .gitignore

‚îÇ   # --- Begin: .gitignore ---
node_modules
dist/


‚îÇ   # --- End: .gitignore ---

‚îÇ   ‚îú‚îÄ API_TESTING_GUIDE.md

‚îÇ   # --- Begin: API_TESTING_GUIDE.md ---
# üß™ API Testing Guide - Housing Society Management System

This guide provides comprehensive instructions for testing all APIs in your Housing Society Management system.

## üìã Table of Contents

1. [Prerequisites](#prerequisites)
2. [Testing Methods](#testing-methods)
3. [API Endpoints Overview](#api-endpoints-overview)
4. [Testing with Postman](#testing-with-postman)
5. [Testing with Node.js Script](#testing-with-nodejs-script)
6. [Testing with cURL](#testing-with-curl)
7. [Testing with Thunder Client](#testing-with-thunder-client)
8. [Automated Testing](#automated-testing)
9. [Common Testing Scenarios](#common-testing-scenarios)
10. [Troubleshooting](#troubleshooting)

## üöÄ Prerequisites

Before testing, ensure you have:

1. **Server Running**: Start your server
   ```bash
   cd server
   npm install
   npm start
   ```

2. **Database Connected**: Ensure MongoDB is running and connected

3. **Environment Variables**: Check your `.env` file has all required variables

## üõ†Ô∏è Testing Methods

### 1. **Postman Collection (Recommended)**

I've created a comprehensive Postman collection (`Housing_Society_API_Tests.postman_collection.json`) that includes:

- **Authentication Tests**: Register, Login, Logout, Change Password
- **Admin Routes**: Society, Building, Flat, User Management
- **Owner Routes**: Flat details, Rent history, Dashboard
- **Tenant Routes**: Rented flats, Rent due, Dashboard
- **Complaints**: Create, View, Update status
- **Announcements**: Create, View announcements
- **Ownership Requests**: Create, View requests

**How to use:**
1. Import the collection into Postman
2. Set the `baseUrl` variable to `http://localhost:5000`
3. Run the "Login User" request first to get authentication token
4. The token will be automatically set for subsequent requests

### 2. **Node.js Testing Script**

I've created `test-api.js` that automatically tests all endpoints:

```bash
# Install axios if not already installed
npm install axios

# Run the test script
node test-api.js
```

**Features:**
- Automatic authentication flow
- Sequential testing of all endpoints
- Detailed logging of success/failure
- Automatic token management
- Error handling and reporting

### 3. **cURL Commands**

For quick testing from command line:

```bash
# Register User
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test User",
    "email": "test@example.com",
    "password": "password123",
    "phone": "+1234567890",
    "role": "owner"
  }'

# Login User
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'

# Get Current User (with token)
curl -X GET http://localhost:5000/api/auth/me \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

### 4. **Thunder Client (VS Code Extension)**

If you're using VS Code, install the Thunder Client extension for a lightweight API testing experience.

## üìä API Endpoints Overview

### Authentication (`/api/auth`)
- `POST /register` - Register new user
- `POST /login` - User login
- `GET /me` - Get current user
- `PATCH /change-password` - Change password
- `POST /logout` - User logout

### Admin Routes (`/api/admin`)
- `POST /societies` - Create society
- `GET /societies/my` - Get admin's societies
- `PUT /societies/:id` - Update society
- `DELETE /societies/:id` - Delete society
- `POST /buildings` - Create building
- `PUT /buildings/:id` - Update building
- `DELETE /buildings/:id` - Delete building
- `POST /flats` - Create flats
- `PATCH /flats/:flatId/assign-owner` - Assign flat owner
- `GET /users` - Get all users
- `PATCH /users/:id` - Update user
- `POST /rent/generate` - Generate rent
- `GET /rent/history` - Get rent history
- `POST /maintenance` - Generate maintenance
- `GET /dashboard/overview` - Admin dashboard

### Owner Routes (`/api/owner`)
- `GET /flats` - Get owner's flats
- `GET /flats/:id` - Get flat details
- `GET /rent/history` - Get rent history
- `GET /dashboard` - Owner dashboard

### Tenant Routes (`/api/tenant`)
- `GET /flats` - Get rented flats
- `GET /rent/due` - Get rent due
- `GET /dashboard` - Tenant dashboard

### Complaints (`/api/complaints`)
- `POST /` - Create complaint
- `GET /my` - Get user's complaints
- `PATCH /:id/status` - Update complaint status

### Announcements (`/api/announcements`)
- `POST /` - Create announcement
- `GET /` - Get announcements

### Ownership Requests (`/api/ownership-requests`)
- `POST /` - Create ownership request
- `GET /my` - Get user's requests

## üîÑ Testing Workflow

### Step 1: Authentication Testing
1. Register a new user
2. Login with credentials
3. Verify token is received
4. Test protected routes with token
5. Test logout

### Step 2: Admin Functionality Testing
1. Create a society
2. Create buildings in the society
3. Create flats in buildings
4. Assign owners to flats
5. Generate rent
6. Test user management
7. Test dashboard

### Step 3: Owner/Tenant Testing
1. Test owner-specific routes
2. Test tenant-specific routes
3. Verify data isolation between roles

### Step 4: Feature Testing
1. Test complaints system
2. Test announcements
3. Test ownership requests
4. Test maintenance features

## üß™ Common Testing Scenarios

### Scenario 1: Complete User Journey
```javascript
// 1. Register as admin
// 2. Create society
// 3. Create building
// 4. Create flats
// 5. Register owner
// 6. Assign flat to owner
// 7. Register tenant
// 8. Assign tenant to flat
// 9. Generate rent
// 10. Test payments
```

### Scenario 2: Complaint Management
```javascript
// 1. Tenant creates complaint
// 2. Admin views complaint
// 3. Admin updates status
// 4. Tenant views updated status
```

### Scenario 3: Announcement System
```javascript
// 1. Admin creates announcement
// 2. All users view announcement
// 3. Test different announcement types
```

## üîß Automated Testing Setup

### 1. Install Testing Dependencies
```bash
npm install --save-dev jest supertest
```

### 2. Create Test Configuration
```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
};
```

### 3. Create Test Files
```javascript
// __tests__/auth.test.js
const request = require('supertest');
const app = require('../server');

describe('Authentication', () => {
  test('should register a new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'owner'
      });
    
    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('user');
  });
});
```

## üêõ Troubleshooting

### Common Issues:

1. **Authentication Errors**
   - Check if token is being sent correctly
   - Verify token format: `Bearer <token>`
   - Ensure token hasn't expired

2. **Validation Errors**
   - Check request body format
   - Verify all required fields are present
   - Check data types (strings, numbers, etc.)

3. **Database Connection Issues**
   - Verify MongoDB is running
   - Check connection string in `.env`
   - Ensure database exists

4. **CORS Issues**
   - Check CORS configuration in `server.js`
   - Verify frontend URL is allowed

### Debug Tips:

1. **Enable Detailed Logging**
   ```javascript
   // In server.js
   app.use(morgan('dev'));
   ```

2. **Check Request/Response**
   ```javascript
   // Add to routes for debugging
   console.log('Request Body:', req.body);
   console.log('Request Headers:', req.headers);
   ```

3. **Database Queries**
   ```javascript
   // Enable MongoDB query logging
   mongoose.set('debug', true);
   ```

## üìà Performance Testing

### Load Testing with Artillery
```bash
npm install -g artillery

# Create artillery.yml
artillery run artillery.yml
```

### Artillery Configuration
```yaml
# artillery.yml
config:
  target: 'http://localhost:5000'
  phases:
    - duration: 60
      arrivalRate: 10
scenarios:
  - name: "API Load Test"
    requests:
      - get:
          url: "/api/auth/me"
          headers:
            Authorization: "Bearer {{token}}"
```

## üéØ Best Practices

1. **Test Data Management**
   - Use unique test data
   - Clean up test data after tests
   - Use test databases for automated tests

2. **Error Handling**
   - Test both success and error scenarios
   - Verify error messages are meaningful
   - Test edge cases

3. **Security Testing**
   - Test authentication requirements
   - Verify role-based access
   - Test input validation

4. **Performance Testing**
   - Test response times
   - Check memory usage
   - Monitor database performance

## üìù Test Documentation

Keep track of your tests with:

- Test case descriptions
- Expected vs actual results
- Environment details
- Test data used
- Issues found and resolved

This comprehensive testing approach will ensure your Housing Society Management API is robust, secure, and performs well under various conditions. 
‚îÇ   # --- End: API_TESTING_GUIDE.md ---

‚îÇ   ‚îú‚îÄ complete-api-test.js

‚îÇ   # --- Begin: complete-api-test.js ---
const axios = require('axios');

class CompleteAPITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.cookies = [];
    this.testData = {
      admin: null,
      owner: null,
      tenant: null,
      society: null,
      building: null,
      flat: null,
      complaint: null,
      announcement: null,
      ownershipRequest: null,
      maintenance: null,
      rent: null
    };
    this.testResults = {
      total: 59,
      passed: 0,
      failed: 0,
      skipped: 0,
      details: []
    };
  }

  // Helper function to delay execution
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      // Add a longer delay to avoid rate limiting
      await this.sleep(2000);
      
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
      }

      const response = await axios(config);
      
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        this.cookies = [...this.cookies, ...newCookies];
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      this.recordTestResult(method, endpoint, true);
      return { status: response.status, data: response.data };
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      // Log detailed error information if available
      if (error.response?.data?.errors) {
        console.error('Validation errors:', JSON.stringify(error.response.data.errors, null, 2));
      }
      this.recordTestResult(method, endpoint, false, error.response?.status, error.response?.data?.message || error.message);
      return { status: error.response?.status || 500, data: error.response?.data || null };
    }
  }

  recordTestResult(method, endpoint, success, statusCode = null, errorMessage = null) {
    const result = {
      method,
      endpoint,
      success,
      timestamp: new Date().toISOString()
    };

    if (!success) {
      result.statusCode = statusCode;
      result.errorMessage = errorMessage;
    }

    if (success) {
      this.testResults.passed++;
    } else {
      this.testResults.failed++;
    }

    this.testResults.details.push(result);
  }

  resetCookies() {
    this.cookies = [];
    console.log('üîÑ Cookies reset');
  }

  async runCompleteTest() {
    console.log('üöÄ Starting Complete API Test\n');
    console.log(`üìä Total APIs to test: ${this.testResults.total}\n`);
    
    try {
      // Test all authentication APIs
      await this.testAuthAPIs();
      
      // Test admin APIs - This creates society, building, flats which are needed for other tests
      await this.testAdminAPIs();
      
      // Only proceed with other tests if we have a society and flat created
      if (this.testData.society && this.testData.flat) {
        // Test owner APIs
        await this.testOwnerAPIs();
        
        // Test tenant APIs
        await this.testTenantAPIs();
        
        // Test complaint APIs
        await this.testComplaintAPIs();
        
        // Test announcement APIs
        await this.testAnnouncementAPIs();
        
        // Test ownership request APIs
        await this.testOwnershipRequestAPIs();
      } else {
        console.log('\n‚ö†Ô∏è Society or flat creation failed, skipping dependent tests');
        this.testResults.skipped = this.testResults.total - this.testResults.passed - this.testResults.failed;
      }
    } catch (error) {
      console.error('\n‚ùå Test execution error:', error.message);
    }
    
    // Print test summary
    this.printTestSummary();
    
    console.log('\n‚úÖ Complete API test finished!');
  }

  printTestSummary() {
    console.log('\nüìä Test Summary:');
    console.log(`Total APIs: ${this.testResults.total}`);
    console.log(`Passed: ${this.testResults.passed}`);
    console.log(`Failed: ${this.testResults.failed}`);
    console.log(`Skipped: ${this.testResults.skipped}`);
    
    if (this.testResults.failed > 0) {
      console.log('\n‚ùå Failed Tests:');
      const failedTests = this.testResults.details.filter(test => !test.success);
      failedTests.forEach((test, index) => {
        console.log(`${index + 1}. ${test.method} ${test.endpoint} - Status: ${test.statusCode} - ${test.errorMessage}`);
      });
    }
  }

  async testAuthAPIs() {
    console.log('\nüîê Testing Authentication APIs...');
    
    // 1. Register admin user
    const adminTimestamp = Date.now();
    const adminEmail = `admin${adminTimestamp}@example.com`;
    
    const adminRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Admin User',
      email: adminEmail,
      password: 'admin123',
      phone: '+1234567890',
      role: 'admin'
    });

    if (adminRegisterResponse.status === 201 && adminRegisterResponse.data) {
      this.testData.admin = adminRegisterResponse.data.data;
      console.log('‚úÖ Admin registered:', this.testData.admin.name);
      
      // 2. Register owner user
      const ownerTimestamp = Date.now();
      const ownerEmail = `owner${ownerTimestamp}@example.com`;
      
      const ownerRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
        name: 'Owner User',
        email: ownerEmail,
        password: 'owner123',
        phone: '+1234567891',
        role: 'owner'
      });

      if (ownerRegisterResponse.status === 201 && ownerRegisterResponse.data) {
        this.testData.owner = ownerRegisterResponse.data.data;
        console.log('‚úÖ Owner registered:', this.testData.owner.name);
        
        // 3. Register tenant user
        const tenantTimestamp = Date.now();
        const tenantEmail = `tenant${tenantTimestamp}@example.com`;
        
        const tenantRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
          name: 'Tenant User',
          email: tenantEmail,
          password: 'tenant123',
          phone: '+1234567892',
          role: 'tenant'
        });

        if (tenantRegisterResponse.status === 201 && tenantRegisterResponse.data) {
          this.testData.tenant = tenantRegisterResponse.data.data;
          console.log('‚úÖ Tenant registered:', this.testData.tenant.name);
          
          // 4. Test login for admin
          this.resetCookies();
          const adminLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
            email: adminEmail,
            password: 'admin123'
          });

          if (adminLoginResponse.status === 200) {
            console.log('‚úÖ Admin login successful');
            
            // 5. Test get current user
            await this.makeRequest('GET', '/api/auth/me');
            
            // 6. Test change password
            await this.makeRequest('PATCH', '/api/auth/change-password', {
              currentPassword: 'admin123',
              newPassword: 'admin1234',
              confirmPassword: 'admin1234'
            });
            
            // 7. Test logout
            await this.makeRequest('POST', '/api/auth/logout');
            
            // 8. Test login with new password
            await this.makeRequest('POST', '/api/auth/login', {
              email: adminEmail,
              password: 'admin1234'
            });
          }
        }
      }
    }
  }

  async testAdminAPIs() {
    console.log('\nüë®‚Äçüíº Testing Admin APIs...');
    
    // Ensure we're logged in as admin
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 1000}@example.com`;
    const adminLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234' // Using the changed password
    });

    if (adminLoginResponse.status === 200) {
      console.log('‚úÖ Admin login successful for API testing');
      
      // 1. Test society management
      // Create society
      const societyData = {
        name: 'Test Society',
        registrationNumber: `REG${Date.now()}`,
        address: {
          street: '123 Test Street',
          city: 'Test City',
          state: 'Test State',
          pincode: '123456',
          country: 'Test Country'
        },
        maintenancePolicy: {
          frequency: 'monthly',
          amountPerFlat: 1000,
          dueDate: 5,
          lateFeesPercentage: 10
        },
        amenities: ['Parking', 'Swimming Pool', 'Gym'],
        establishedYear: new Date().getFullYear()
      };
      
      const societyResponse = await this.makeRequest('POST', '/api/admin/societies', societyData);
      
      // Log the full response for debugging
      console.log('Society creation response:', JSON.stringify(societyResponse.data, null, 2));
      
      if (societyResponse.status === 201 && societyResponse.data) {
        this.testData.society = societyResponse.data.data;
        console.log('‚úÖ Society created successfully');
        
        // Get admin's societies
        await this.makeRequest('GET', '/api/admin/societies/my');
        
        // Update society
        await this.makeRequest('PUT', `/api/admin/societies/${this.testData.society._id}`, {
          name: 'Updated Test Society',
          address: 'Updated Address',
          maintenancePolicy: 'Updated maintenance policy'
        });
        
        // 2. Test building management
        // Create building
        const buildingResponse = await this.makeRequest('POST', '/api/admin/buildings', {
          name: 'Test Building',
          societyId: this.testData.society._id,
          totalFloors: 5,
          totalFlats: 20,
          addressLabel: 'Wing A'
        });
        
        if (buildingResponse.status === 201 && buildingResponse.data) {
          this.testData.building = buildingResponse.data.data;
          console.log('‚úÖ Building created successfully');
          
          // Update building
          await this.makeRequest('PUT', `/api/admin/buildings/${this.testData.building._id}`, {
            name: 'Updated Test Building',
            totalFloors: 6,
            addressLabel: 'Updated Wing A'
          });
          
          // 3. Test flat management
          // Create flats
          const flatsResponse = await this.makeRequest('POST', '/api/admin/flats', {
            buildingId: this.testData.building._id,
            totalFlats: 4
          });
          
          if (flatsResponse.status === 201 && flatsResponse.data) {
            this.testData.flats = flatsResponse.data.data;
            if (this.testData.flats && this.testData.flats.length > 0) {
              this.testData.flat = this.testData.flats[0];
              console.log(`‚úÖ ${this.testData.flats.length} flats created successfully`);
              
              // Assign flat owner
              await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-owner`, {
                ownerId: this.testData.owner._id
              });
              
              // 4. Test user management
              // Get all users
              await this.makeRequest('GET', '/api/admin/users');
              
              // Get user by ID
              await this.makeRequest('GET', `/api/admin/users/${this.testData.owner._id}`);
              
              // Update user
              await this.makeRequest('PATCH', `/api/admin/users/${this.testData.owner._id}`, {
                name: 'Updated Owner Name'
              });
              
              // Toggle user status
              await this.makeRequest('PATCH', `/api/admin/users/${this.testData.owner._id}/toggle-status`);
              
              // 5. Test rent management
              // Generate rent
              const rentResponse = await this.makeRequest('POST', '/api/admin/rent/generate', {
                flatId: this.testData.flat._id,
                amount: 10000,
                dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                description: 'Monthly rent'
              });
              
              if (rentResponse.status === 201 && rentResponse.data) {
                this.testData.rent = rentResponse.data.data;
                console.log('‚úÖ Rent generated successfully');
                
                // Get rent history
                await this.makeRequest('GET', '/api/admin/rent/history');
                
                // 6. Test maintenance management
                // Generate maintenance
                const maintenanceResponse = await this.makeRequest('POST', '/api/admin/maintenance', {
                  societyId: this.testData.society._id,
                  amount: 5000,
                  dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
                  description: 'Monthly maintenance'
                });
                
                if (maintenanceResponse.status === 201 && maintenanceResponse.data) {
                  this.testData.maintenance = maintenanceResponse.data.data;
                  console.log('‚úÖ Maintenance generated successfully');
                  
                  // Get maintenance status
                  await this.makeRequest('GET', '/api/admin/maintenance/status');
                  
                  // 7. Test dashboard
                  // Get admin dashboard
                  await this.makeRequest('GET', '/api/admin/dashboard/overview');
                  
                  // Get flat info
                  await this.makeRequest('GET', `/api/admin/flats/${this.testData.flat._id}/info`);
                  
                  // 8. Test notes & reminders
                  // Add society note
                  await this.makeRequest('PATCH', `/api/admin/societies/${this.testData.society._id}/note`, {
                    note: 'Test society note'
                  });
                  
                  // Send reminder to user
                  await this.makeRequest('POST', `/api/admin/users/${this.testData.owner._id}/reminder`, {
                    message: 'Test reminder message',
                    subject: 'Test reminder'
                  });
                }
              }
            }
          }
        }
      }
    }
  }

  async testOwnerAPIs() {
    console.log('\nüè† Testing Owner APIs...');
    
    // Ensure we're logged in as owner
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    const ownerLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });

    if (ownerLoginResponse.status === 200) {
      console.log('‚úÖ Owner login successful for API testing');
      
      // 1. Test dashboard & profile
      // Get owner dashboard
      await this.makeRequest('GET', '/api/owner/dashboard/overview');
      
      // Update owner profile
      await this.makeRequest('PATCH', '/api/auth/profile', {
        name: 'Updated Owner Profile',
        phone: '+1234567899'
      });
      
      // 2. Test flat management
      // Get owner's flats
      await this.makeRequest('GET', '/api/owner/flats');
      
      // Get flat society info
      if (this.testData.flat && this.testData.flat._id) {
        await this.makeRequest('GET', `/api/owner/flats/${this.testData.flat._id}/society`);
      }
      
      // 3. Test rent & maintenance
      // Get rent history
      await this.makeRequest('GET', '/api/owner/rent-history');
      
      // Get unpaid maintenance
      await this.makeRequest('GET', '/api/owner/maintenance-due');
      
      // Pay maintenance
      if (this.testData.maintenance && this.testData.maintenance._id) {
        await this.makeRequest('PATCH', `/api/owner/maintenance/${this.testData.maintenance._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 4. Test ownership requests
      // Create ownership request
      if (this.testData.flat && this.testData.flat._id) {
        const ownershipRequestResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
          flatId: this.testData.flat._id,
          documents: 'Test ownership documents',
          requestNotes: 'Test ownership request'
        });
        
        if (ownershipRequestResponse.status === 201 && ownershipRequestResponse.data) {
          this.testData.ownershipRequest = ownershipRequestResponse.data.data;
          console.log('‚úÖ Ownership request created successfully');
          
          // Get my ownership requests
          await this.makeRequest('GET', '/api/owner/ownership-requests/my');
        }
      }
    }
  }

  async testTenantAPIs() {
    console.log('\nüë§ Testing Tenant APIs...');
    
    // First, assign tenant to flat as admin
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234' // Using the changed password
    });
    
    if (this.testData.flat && this.testData.flat._id && this.testData.tenant && this.testData.tenant._id) {
      await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-tenant`, {
        tenantId: this.testData.tenant._id,
        rentAmount: 10000,
        securityDeposit: 20000,
        leaseStart: new Date().toISOString(),
        leaseDuration: 12 // months
      });
      
      console.log('‚úÖ Tenant assigned to flat');
    }
    
    // Now login as tenant
    this.resetCookies();
    const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
    const tenantLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: tenantEmail,
      password: 'tenant123'
    });

    if (tenantLoginResponse.status === 200) {
      console.log('‚úÖ Tenant login successful for API testing');
      
      // 1. Test dashboard & profile
      // Get tenant dashboard
      await this.makeRequest('GET', '/api/tenant/dashboard/overview');
      
      // Update tenant profile
      await this.makeRequest('PATCH', '/api/auth/profile', {
        name: 'Updated Tenant Profile',
        phone: '+1234567898'
      });
      
      // 2. Test flat & rent management
      // Get tenant's flat
      await this.makeRequest('GET', '/api/tenant/my-flat');
      
      // Get rent history
      await this.makeRequest('GET', '/api/tenant/rent-history');
      
      // Get rent due
      await this.makeRequest('GET', '/api/tenant/rent/due');
      
      // Pay rent
      if (this.testData.rent && this.testData.rent._id) {
        await this.makeRequest('PATCH', `/api/tenant/rent/${this.testData.rent._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 3. Test maintenance
      // Get unpaid maintenance
      await this.makeRequest('GET', '/api/tenant/maintenance-due');
      
      // Pay maintenance
      if (this.testData.maintenance && this.testData.maintenance._id) {
        await this.makeRequest('PATCH', `/api/tenant/maintenance/${this.testData.maintenance._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 4. Test announcements
      // Get relevant announcements
      await this.makeRequest('GET', '/api/tenant/announcements');
    }
  }

  async testComplaintAPIs() {
    console.log('\nüìù Testing Complaint APIs...');
    
    // 1. Test owner complaint creation
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });
    
    const ownerComplaintResponse = await this.makeRequest('POST', '/api/complaints', {
      title: 'Owner Test Complaint',
      description: 'This is a test complaint from owner',
      category: 'maintenance',
      priority: 'medium',
      societyId: this.testData.society?._id || null,
      flatId: this.testData.flat?._id || null
    });
    
    if (ownerComplaintResponse.status === 201 && ownerComplaintResponse.data) {
      this.testData.complaint = ownerComplaintResponse.data.data;
      console.log('‚úÖ Owner complaint created successfully');
      
      // Get owner's complaints
      await this.makeRequest('GET', '/api/complaints/my');
    }
    
    // 2. Test tenant complaint creation
    this.resetCookies();
    const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: tenantEmail,
      password: 'tenant123'
    });
    
    await this.makeRequest('POST', '/api/complaints', {
      title: 'Tenant Test Complaint',
      description: 'This is a test complaint from tenant',
      category: 'security',
      priority: 'high',
      societyId: this.testData.society?._id || null,
      flatId: this.testData.flat?._id || null
    });
    
    // Get tenant's complaints
    await this.makeRequest('GET', '/api/complaints/my');
    
    // 3. Test admin complaint management
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234'
    });
    
    // Get all complaints
    await this.makeRequest('GET', '/api/complaints');
    
    // Update complaint status
    if (this.testData.complaint && this.testData.complaint._id) {
      await this.makeRequest('PATCH', `/api/complaints/${this.testData.complaint._id}`, {
        status: 'in-progress',
        adminResponse: 'Working on this issue'
      });
    }
  }

  async testAnnouncementAPIs() {
    console.log('\nüì¢ Testing Announcement APIs...');
    
    // 1. Test admin announcement management
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234'
    });
    
    // Create announcement
    const announcementResponse = await this.makeRequest('POST', '/api/announcements', {
      title: 'Test Announcement',
      content: 'This is a test announcement',
      type: 'general',
      societyId: this.testData.society?._id,
      audience: ['all'],
      validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
    });
    
    if (announcementResponse.status === 201 && announcementResponse.data) {
      this.testData.announcement = announcementResponse.data.data;
      console.log('‚úÖ Announcement created successfully');
      
      // Get all announcements
      await this.makeRequest('GET', '/api/announcements');
      
      // Update announcement
      if (this.testData.announcement && this.testData.announcement._id) {
        await this.makeRequest('PUT', `/api/announcements/${this.testData.announcement._id}`, {
          title: 'Updated Test Announcement',
          content: 'This is an updated test announcement',
          type: 'important'
        });
      }
      
      // 2. Test user announcement viewing
      // Owner view announcements
      this.resetCookies();
      const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
      await this.makeRequest('POST', '/api/auth/login', {
        email: ownerEmail,
        password: 'owner123'
      });
      
      await this.makeRequest('GET', '/api/announcements/relevant');
      
      // Tenant view announcements
      this.resetCookies();
      const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
      await this.makeRequest('POST', '/api/auth/login', {
        email: tenantEmail,
        password: 'tenant123'
      });
      
      await this.makeRequest('GET', '/api/announcements/relevant');
      
      // 3. Test announcement deletion
      this.resetCookies();
      await this.makeRequest('POST', '/api/auth/login', {
        email: adminEmail,
        password: 'admin1234'
      });
      
      if (this.testData.announcement && this.testData.announcement._id) {
        await this.makeRequest('DELETE', `/api/announcements/${this.testData.announcement._id}`);
      }
    }
  }

  async testOwnershipRequestAPIs() {
    console.log('\nüìã Testing Ownership Request APIs...');
    
    // 1. Test owner ownership request creation
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });
    
    if (this.testData.flat && this.testData.flat._id) {
      const ownershipRequestResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
        flatId: this.testData.flat._id,
        documents: 'Test ownership documents',
        requestNotes: 'Test ownership request'
      });
      
      if (ownershipRequestResponse.status === 201 && ownershipRequestResponse.data) {
        this.testData.ownershipRequest = ownershipRequestResponse.data.data;
        console.log('‚úÖ Ownership request created successfully');
        
        // Get my ownership requests
        await this.makeRequest('GET', '/api/owner/ownership-requests/my');
        
        // 2. Test admin ownership request management
        this.resetCookies();
        const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
        await this.makeRequest('POST', '/api/auth/login', {
          email: adminEmail,
          password: 'admin1234'
        });
        
        // Get all ownership requests
        const adminRequestsResponse = await this.makeRequest('GET', '/api/admin/ownership-requests');
        
        if (adminRequestsResponse.status === 200 && adminRequestsResponse.data && 
            adminRequestsResponse.data.data && adminRequestsResponse.data.data.length > 0) {
          const requestId = adminRequestsResponse.data.data[0]._id;
          
          // Review ownership request
          await this.makeRequest('PATCH', '/api/admin/ownership-requests/review', {
            requestId,
            status: 'approved',
            reviewNotes: 'Approved by admin'
          });
        }
      }
    }
  }
}

// Run the complete test
if (require.main === module) {
  const tester = new CompleteAPITester();
  tester.runCompleteTest();
}

module.exports = CompleteAPITester;
‚îÇ   # --- End: complete-api-test.js ---

‚îÇ   ‚îú‚îÄ COMPLETE_API_LIST.md

‚îÇ   # --- Begin: COMPLETE_API_LIST.md ---
# üìã Complete API List - Housing Society Management System

## üîê Authentication APIs (`/api/auth`)
1. `POST /register` - Register new user
2. `POST /login` - User login
3. `GET /me` - Get current user
4. `PATCH /change-password` - Change password
5. `POST /logout` - User logout

## üë®‚Äçüíº Admin APIs (`/api/admin`)

### Society Management
6. `POST /societies` - Create society
7. `GET /societies/my` - Get admin's societies
8. `PUT /societies/:id` - Update society
9. `DELETE /societies/:id` - Delete society

### Building Management
10. `POST /buildings` - Create building
11. `PUT /buildings/:id` - Update building
12. `DELETE /buildings/:id` - Delete building

### Flat Management
13. `POST /flats` - Create flats
14. `PATCH /flats/:flatId/assign-owner` - Assign flat owner
15. `PATCH /flats/:flatId/remove-owner` - Remove flat owner
16. `PATCH /flats/:flatId/remove-tenant` - Remove flat tenant

### User Management
17. `GET /users` - Get all users
18. `GET /users/:id` - Get user by ID
19. `PATCH /users/:id` - Update user
20. `PATCH /users/:id/toggle-status` - Toggle user status

### Rent Management
21. `POST /rent/generate` - Generate rent
22. `GET /rent/history` - Get rent history

### Maintenance
23. `POST /maintenance` - Generate maintenance
24. `GET /maintenance/status` - Get maintenance status

### Ownership Requests
25. `GET /ownership-requests` - Get ownership requests
26. `PATCH /ownership-requests/review` - Review ownership request

### Dashboard & Documents
27. `GET /dashboard/overview` - Admin dashboard
28. `GET /flats/:flatId/info` - Get flat info

### Notes & Reminders
29. `PATCH /societies/:id/note` - Add society note
30. `POST /users/:id/reminder` - Send reminder to user

## üè† Owner APIs (`/api/owner`)

### Dashboard & Profile
31. `GET /dashboard/overview` - Owner dashboard
32. `PATCH /profile` - Update owner profile

### Flat Management
33. `GET /flats` - Get owner's flats
34. `GET /flats/:id/society` - Get flat society info

### Rent & Maintenance
35. `GET /rent-history` - Get rent history
36. `GET /maintenance-due` - Get unpaid maintenance
37. `PATCH /maintenance/:maintenanceId/pay` - Pay maintenance

## üè† Tenant APIs (`/api/tenant`)

### Dashboard & Profile
38. `GET /dashboard/overview` - Tenant dashboard
39. `PATCH /profile` - Update tenant profile

### Flat & Rent Management
40. `GET /my-flat` - Get tenant's flat
41. `GET /rent-history` - Get rent history
42. `PATCH /rent/:rentId/pay` - Pay rent
43. `GET /rent-due` - Get rent due

### Maintenance
44. `GET /maintenance-due` - Get unpaid maintenance
45. `PATCH /maintenance/:maintenanceId/pay` - Pay maintenance

### Announcements
46. `GET /announcements` - Get relevant announcements

## üìù Complaint APIs (`/api/complaints`)

### User Complaints
47. `POST /` - Create complaint (Owner/Tenant)
48. `GET /my` - Get my complaints (Owner/Tenant)

### Admin Complaint Management
49. `GET /` - Get all complaints (Admin)
50. `PATCH /:id` - Update complaint status (Admin)

## üì¢ Announcement APIs (`/api/announcements`)

### Admin Announcement Management
51. `POST /` - Create announcement (Admin)
52. `GET /` - Get all announcements (Admin)
53. `PUT /:id` - Update announcement (Admin)
54. `DELETE /:id` - Delete announcement (Admin)

### User Announcements
55. `GET /relevant` - Get relevant announcements (Owner/Tenant)

## üìã Ownership Request APIs (`/api/ownership-requests`)

### User Requests
56. `POST /` - Create ownership request (Owner)
57. `GET /my` - Get my ownership requests (Owner)

### Admin Management
58. `GET /` - Get all ownership requests (Admin)
59. `PATCH /:requestId` - Review ownership request (Admin)

## üìä Total Count: 59 APIs

### Breakdown by Role:
- **Authentication**: 5 APIs
- **Admin**: 25 APIs
- **Owner**: 7 APIs
- **Tenant**: 9 APIs
- **Complaints**: 4 APIs
- **Announcements**: 5 APIs
- **Ownership Requests**: 4 APIs

### API Categories:
- **CRUD Operations**: Society, Building, Flat, User management
- **Financial**: Rent generation, payment, maintenance
- **Communication**: Announcements, complaints
- **Dashboard**: Overview data for all roles
- **Profile Management**: User profile updates
- **Ownership**: Transfer requests and management 
‚îÇ   # --- End: COMPLETE_API_LIST.md ---

‚îÇ   ‚îú‚îÄ comprehensive-api-test.js

‚îÇ   # --- Begin: comprehensive-api-test.js ---
const axios = require('axios');

class ComprehensiveAPITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.cookies = [];
    this.testData = {
      admin: null,
      owner: null,
      tenant: null,
      society: null,
      building: null,
      flat: null
    };
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
      }

      const response = await axios(config);
      
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        this.cookies = [...this.cookies, ...newCookies];
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      return { status: response.status, data: response.data };
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      return { status: error.response?.status || 500, data: error.response?.data || null };
    }
  }

  resetCookies() {
    this.cookies = [];
    console.log('üîÑ Cookies reset');
  }

  async runComprehensiveTest() {
    console.log('üöÄ Starting Comprehensive API Test\n');
    
    await this.testAdminFlow();
    await this.testOwnerFlow();
    await this.testTenantFlow();
    
    console.log('\n‚úÖ Comprehensive API test completed!');
  }

  async testAdminFlow() {
    console.log('\nüë®‚Äçüíº Testing Admin Flow...');
    
    // 1. Register admin user
    const timestamp = Date.now();
    const adminEmail = `admin${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Admin User',
      email: adminEmail,
      password: 'admin123',
      phone: '+1234567890',
      role: 'admin'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.admin = registerResponse.data.data;
      console.log('‚úÖ Admin registered:', this.testData.admin.name);
      
      // 2. Login as admin
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: adminEmail,
        password: 'admin123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Admin login successful');
        
        // 3. Test admin routes
        await this.makeRequest('GET', '/api/admin/users');
        await this.makeRequest('GET', '/api/admin/dashboard/overview');
        
        // 4. Create a society
        const societyData = {
          name: 'Test Society',
          registrationNumber: `REG${Date.now()}`,
          address: '123 Test Street, Test City, Test State, 123456',
          maintenancePolicy: 'Monthly maintenance of 1000 per flat'
        };
        console.log('Society data:', societyData);
        
        const societyResponse = await this.makeRequest('POST', '/api/admin/societies', societyData);
        
        if (societyResponse.status === 201 && societyResponse.data) {
          console.log('‚úÖ Society created successfully');
          this.testData.society = societyResponse.data.data;
          
          // 5. Create a building in the society
          const buildingResponse = await this.makeRequest('POST', '/api/admin/buildings', {
            name: 'Test Building',
            societyId: this.testData.society._id,
            totalFloors: 5,
            totalFlats: 20,
            addressLabel: 'Wing A'
          });
        } else {
          console.log('‚ùå Society creation failed with response:', JSON.stringify(societyResponse.data, null, 2));
        }

        if (this.testData.society && buildingResponse && buildingResponse.status === 201 && buildingResponse.data) {
          this.testData.building = buildingResponse.data.data;
          console.log('‚úÖ Building created:', this.testData.building.name);
          
          // 6. Create flats in the building
          const flatsResponse = await this.makeRequest('POST', '/api/admin/flats', {
            buildingId: this.testData.building._id,
            totalFlats: 4
          });
          
          if (flatsResponse.status === 201 && flatsResponse.data) {
            this.testData.flats = flatsResponse.data.data;
            if (this.testData.flats && this.testData.flats.length > 0) {
              this.testData.flat = this.testData.flats[0];
              console.log(`‚úÖ ${this.testData.flats.length} flats created successfully`);
            }
          } else {
            console.log('‚ùå Flat creation failed with response:', JSON.stringify(flatsResponse.data, null, 2));
          }
        }
      }
    }
  }

  async testOwnerFlow() {
    console.log('\nüë®‚Äçüíº Testing Owner Flow...');
    
    // Reset cookies before testing with owner user
    this.resetCookies();
    
    // 1. Register owner user
    const timestamp = Date.now();
    const ownerEmail = `owner${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Owner User',
      email: ownerEmail,
      password: 'owner123',
      phone: '+1234567890',
      role: 'owner'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.owner = registerResponse.data.data;
      console.log('‚úÖ Owner registered:', this.testData.owner.name);
      
      // 2. Login as owner
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: ownerEmail,
        password: 'owner123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Owner login successful');
        
        // 3. Test owner routes
        await this.makeRequest('GET', '/api/owner/dashboard/overview');
        await this.makeRequest('GET', '/api/owner/flats');
        
        // 4. If we have a flat from admin flow, request ownership
        if (this.testData.flat && this.testData.flat._id) {
          // 5. Request ownership of a flat
          const ownershipResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
            flatId: this.testData.flat._id,
            documents: 'Test ownership documents',
            requestNotes: 'Test ownership request'
          });
          
          if (ownershipResponse.status === 201) {
            console.log('‚úÖ Ownership request created');
            
            // 6. Switch to admin to approve the request
            this.resetCookies();
            
            // Login as admin
            await this.makeRequest('POST', '/api/auth/login', {
              email: `admin${Date.now() - 1000}@example.com`, // Use the previously created admin
              password: 'admin123'
            });
            
            // Get ownership requests as admin
            const adminRequestsResponse = await this.makeRequest('GET', '/api/admin/ownership-requests');
            
            if (adminRequestsResponse.status === 200 && adminRequestsResponse.data && adminRequestsResponse.data.data && adminRequestsResponse.data.data.length > 0) {
              const requestId = adminRequestsResponse.data.data[0]._id;
              
              // Approve the request
              await this.makeRequest('PATCH', '/api/admin/ownership-requests/review', {
                requestId,
                status: 'approved',
                reviewNotes: 'Approved by admin'
              });
              
              console.log('‚úÖ Ownership request approved by admin');
              
              // Assign flat owner
              await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-owner`, {
                ownerId: this.testData.owner._id
              });
              
              console.log('‚úÖ Flat assigned to owner');
            }
          }
        }
      }
    }
  }

  async testTenantFlow() {
    console.log('\nüë§ Testing Tenant Flow...');
    
    // Reset cookies before testing with tenant user
    this.resetCookies();
    
    // 1. Register tenant user
    const timestamp = Date.now();
    const tenantEmail = `tenant${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Tenant User',
      email: tenantEmail,
      password: 'tenant123',
      phone: '+1234567890',
      role: 'tenant'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.tenant = registerResponse.data.data;
      console.log('‚úÖ Tenant registered:', this.testData.tenant.name);
      
      // 2. Login as tenant
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: tenantEmail,
        password: 'tenant123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Tenant login successful');
        
        // 3. Test tenant routes
        await this.makeRequest('GET', '/api/tenant/dashboard/overview');
        
        // 4. If we have a flat from admin flow, assign tenant
        if (this.testData.flat && this.testData.flat._id) {
          // Switch to admin to assign tenant
          this.resetCookies();
          
          // Login as admin
          await this.makeRequest('POST', '/api/auth/login', {
            email: `admin${Date.now() - 1000}@example.com`, // Use the previously created admin
            password: 'admin123'
          });
          
          // Assign tenant to flat
          await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-tenant`, {
            tenantId: this.testData.tenant._id,
            rentAmount: 10000,
            securityDeposit: 20000,
            leaseStart: new Date().toISOString(),
            leaseDuration: 12 // months
          });
          
          console.log('‚úÖ Tenant assigned to flat');
          
          // Generate rent for tenant
          await this.makeRequest('POST', '/api/admin/rents/generate', {
            flatId: this.testData.flat._id,
            amount: 10000,
            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days from now
            description: 'Monthly rent'
          });
          
          console.log('‚úÖ Rent generated for tenant');
          
          // Switch back to tenant to check rent
          this.resetCookies();
          
          // Login as tenant
          await this.makeRequest('POST', '/api/auth/login', {
            email: tenantEmail,
            password: 'tenant123'
          });
          
          // Check tenant's flat
          await this.makeRequest('GET', '/api/tenant/my-flat');
          
          // Check tenant's rent history
          await this.makeRequest('GET', '/api/tenant/rent-history');
        }
      }
    }
  }
}

// Run the comprehensive test
if (require.main === module) {
  const tester = new ComprehensiveAPITester();
  tester.runComprehensiveTest();
}

module.exports = ComprehensiveAPITester;
‚îÇ   # --- End: comprehensive-api-test.js ---

‚îÇ   ‚îú‚îÄ debug-user.js

‚îÇ   # --- Begin: debug-user.js ---
const axios = require('axios');

async function debugUser() {
  const baseURL = 'http://localhost:5000';
  let cookies = [];

  async function makeRequest(method, endpoint, data = null) {
    try {
      const config = {
        method,
        url: `${baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json'
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      if (cookies.length > 0) {
        config.headers.Cookie = cookies.join('; ');
      }

      const response = await axios(config);
      
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        cookies = [...cookies, ...newCookies];
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      return response.data;
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      return null;
    }
  }

  console.log('üîç Debugging User Authentication and Roles...\n');

  // Test 1: Register and login as admin
  const timestamp = Date.now();
  const adminEmail = `debugadmin${timestamp}@example.com`;
  
  console.log('1. Registering admin user...');
  await makeRequest('POST', '/api/auth/register', {
    name: 'Debug Admin',
    email: adminEmail,
    password: 'admin123',
    phone: '+1234567890',
    role: 'admin'
  });

  console.log('2. Logging in as admin...');
  const loginResponse = await makeRequest('POST', '/api/auth/login', {
    email: adminEmail,
    password: 'admin123'
  });

  if (loginResponse && loginResponse.data) {
    console.log('3. User data from login:', JSON.stringify(loginResponse.data, null, 2));
    
    console.log('4. Testing /api/auth/me endpoint...');
    const meResponse = await makeRequest('GET', '/api/auth/me');
    if (meResponse && meResponse.data) {
      console.log('5. User data from /me:', JSON.stringify(meResponse.data, null, 2));
    }
    
    console.log('6. Testing admin route...');
    await makeRequest('GET', '/api/admin/users');
  }
}

debugUser(); 
‚îÇ   # --- End: debug-user.js ---

‚îÇ   ‚îú‚îÄ Housing_Society_API_Tests.postman_collection.json

‚îÇ   # --- Begin: Housing_Society_API_Tests.postman_collection.json ---
 
‚îÇ   # --- End: Housing_Society_API_Tests.postman_collection.json ---

‚îÇ   ‚îú‚îÄ package.json

‚îÇ   # --- Begin: package.json ---
{
  "dependencies": {
    "axios": "^1.11.0"
  }
}

‚îÇ   # --- End: package.json ---

‚îÇ   ‚îú‚îÄ project.txt

‚îÇ   # --- Begin: project.txt ---
‚îú‚îÄ ./
‚îÇ   ‚îú‚îÄ .gitignore

‚îÇ   # --- Begin: .gitignore ---
node_modules
dist/


‚îÇ   # --- End: .gitignore ---

‚îÇ   ‚îú‚îÄ API_TESTING_GUIDE.md

‚îÇ   # --- Begin: API_TESTING_GUIDE.md ---
# üß™ API Testing Guide - Housing Society Management System

This guide provides comprehensive instructions for testing all APIs in your Housing Society Management system.

## üìã Table of Contents

1. [Prerequisites](#prerequisites)
2. [Testing Methods](#testing-methods)
3. [API Endpoints Overview](#api-endpoints-overview)
4. [Testing with Postman](#testing-with-postman)
5. [Testing with Node.js Script](#testing-with-nodejs-script)
6. [Testing with cURL](#testing-with-curl)
7. [Testing with Thunder Client](#testing-with-thunder-client)
8. [Automated Testing](#automated-testing)
9. [Common Testing Scenarios](#common-testing-scenarios)
10. [Troubleshooting](#troubleshooting)

## üöÄ Prerequisites

Before testing, ensure you have:

1. **Server Running**: Start your server
   ```bash
   cd server
   npm install
   npm start
   ```

2. **Database Connected**: Ensure MongoDB is running and connected

3. **Environment Variables**: Check your `.env` file has all required variables

## üõ†Ô∏è Testing Methods

### 1. **Postman Collection (Recommended)**

I've created a comprehensive Postman collection (`Housing_Society_API_Tests.postman_collection.json`) that includes:

- **Authentication Tests**: Register, Login, Logout, Change Password
- **Admin Routes**: Society, Building, Flat, User Management
- **Owner Routes**: Flat details, Rent history, Dashboard
- **Tenant Routes**: Rented flats, Rent due, Dashboard
- **Complaints**: Create, View, Update status
- **Announcements**: Create, View announcements
- **Ownership Requests**: Create, View requests

**How to use:**
1. Import the collection into Postman
2. Set the `baseUrl` variable to `http://localhost:5000`
3. Run the "Login User" request first to get authentication token
4. The token will be automatically set for subsequent requests

### 2. **Node.js Testing Script**

I've created `test-api.js` that automatically tests all endpoints:

```bash
# Install axios if not already installed
npm install axios

# Run the test script
node test-api.js
```

**Features:**
- Automatic authentication flow
- Sequential testing of all endpoints
- Detailed logging of success/failure
- Automatic token management
- Error handling and reporting

### 3. **cURL Commands**

For quick testing from command line:

```bash
# Register User
curl -X POST http://localhost:5000/api/auth/register \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Test User",
    "email": "test@example.com",
    "password": "password123",
    "phone": "+1234567890",
    "role": "owner"
  }'

# Login User
curl -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{
    "email": "test@example.com",
    "password": "password123"
  }'

# Get Current User (with token)
curl -X GET http://localhost:5000/api/auth/me \
  -H "Authorization: Bearer YOUR_TOKEN_HERE"
```

### 4. **Thunder Client (VS Code Extension)**

If you're using VS Code, install the Thunder Client extension for a lightweight API testing experience.

## üìä API Endpoints Overview

### Authentication (`/api/auth`)
- `POST /register` - Register new user
- `POST /login` - User login
- `GET /me` - Get current user
- `PATCH /change-password` - Change password
- `POST /logout` - User logout

### Admin Routes (`/api/admin`)
- `POST /societies` - Create society
- `GET /societies/my` - Get admin's societies
- `PUT /societies/:id` - Update society
- `DELETE /societies/:id` - Delete society
- `POST /buildings` - Create building
- `PUT /buildings/:id` - Update building
- `DELETE /buildings/:id` - Delete building
- `POST /flats` - Create flats
- `PATCH /flats/:flatId/assign-owner` - Assign flat owner
- `GET /users` - Get all users
- `PATCH /users/:id` - Update user
- `POST /rent/generate` - Generate rent
- `GET /rent/history` - Get rent history
- `POST /maintenance` - Generate maintenance
- `GET /dashboard/overview` - Admin dashboard

### Owner Routes (`/api/owner`)
- `GET /flats` - Get owner's flats
- `GET /flats/:id` - Get flat details
- `GET /rent/history` - Get rent history
- `GET /dashboard` - Owner dashboard

### Tenant Routes (`/api/tenant`)
- `GET /flats` - Get rented flats
- `GET /rent/due` - Get rent due
- `GET /dashboard` - Tenant dashboard

### Complaints (`/api/complaints`)
- `POST /` - Create complaint
- `GET /my` - Get user's complaints
- `PATCH /:id/status` - Update complaint status

### Announcements (`/api/announcements`)
- `POST /` - Create announcement
- `GET /` - Get announcements

### Ownership Requests (`/api/ownership-requests`)
- `POST /` - Create ownership request
- `GET /my` - Get user's requests

## üîÑ Testing Workflow

### Step 1: Authentication Testing
1. Register a new user
2. Login with credentials
3. Verify token is received
4. Test protected routes with token
5. Test logout

### Step 2: Admin Functionality Testing
1. Create a society
2. Create buildings in the society
3. Create flats in buildings
4. Assign owners to flats
5. Generate rent
6. Test user management
7. Test dashboard

### Step 3: Owner/Tenant Testing
1. Test owner-specific routes
2. Test tenant-specific routes
3. Verify data isolation between roles

### Step 4: Feature Testing
1. Test complaints system
2. Test announcements
3. Test ownership requests
4. Test maintenance features

## üß™ Common Testing Scenarios

### Scenario 1: Complete User Journey
```javascript
// 1. Register as admin
// 2. Create society
// 3. Create building
// 4. Create flats
// 5. Register owner
// 6. Assign flat to owner
// 7. Register tenant
// 8. Assign tenant to flat
// 9. Generate rent
// 10. Test payments
```

### Scenario 2: Complaint Management
```javascript
// 1. Tenant creates complaint
// 2. Admin views complaint
// 3. Admin updates status
// 4. Tenant views updated status
```

### Scenario 3: Announcement System
```javascript
// 1. Admin creates announcement
// 2. All users view announcement
// 3. Test different announcement types
```

## üîß Automated Testing Setup

### 1. Install Testing Dependencies
```bash
npm install --save-dev jest supertest
```

### 2. Create Test Configuration
```javascript
// jest.config.js
module.exports = {
  testEnvironment: 'node',
  testMatch: ['**/__tests__/**/*.js', '**/?(*.)+(spec|test).js'],
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coverageReporters: ['text', 'lcov'],
};
```

### 3. Create Test Files
```javascript
// __tests__/auth.test.js
const request = require('supertest');
const app = require('../server');

describe('Authentication', () => {
  test('should register a new user', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password123',
        role: 'owner'
      });
    
    expect(response.status).toBe(201);
    expect(response.body).toHaveProperty('user');
  });
});
```

## üêõ Troubleshooting

### Common Issues:

1. **Authentication Errors**
   - Check if token is being sent correctly
   - Verify token format: `Bearer <token>`
   - Ensure token hasn't expired

2. **Validation Errors**
   - Check request body format
   - Verify all required fields are present
   - Check data types (strings, numbers, etc.)

3. **Database Connection Issues**
   - Verify MongoDB is running
   - Check connection string in `.env`
   - Ensure database exists

4. **CORS Issues**
   - Check CORS configuration in `server.js`
   - Verify frontend URL is allowed

### Debug Tips:

1. **Enable Detailed Logging**
   ```javascript
   // In server.js
   app.use(morgan('dev'));
   ```

2. **Check Request/Response**
   ```javascript
   // Add to routes for debugging
   console.log('Request Body:', req.body);
   console.log('Request Headers:', req.headers);
   ```

3. **Database Queries**
   ```javascript
   // Enable MongoDB query logging
   mongoose.set('debug', true);
   ```

## üìà Performance Testing

### Load Testing with Artillery
```bash
npm install -g artillery

# Create artillery.yml
artillery run artillery.yml
```

### Artillery Configuration
```yaml
# artillery.yml
config:
  target: 'http://localhost:5000'
  phases:
    - duration: 60
      arrivalRate: 10
scenarios:
  - name: "API Load Test"
    requests:
      - get:
          url: "/api/auth/me"
          headers:
            Authorization: "Bearer {{token}}"
```

## üéØ Best Practices

1. **Test Data Management**
   - Use unique test data
   - Clean up test data after tests
   - Use test databases for automated tests

2. **Error Handling**
   - Test both success and error scenarios
   - Verify error messages are meaningful
   - Test edge cases

3. **Security Testing**
   - Test authentication requirements
   - Verify role-based access
   - Test input validation

4. **Performance Testing**
   - Test response times
   - Check memory usage
   - Monitor database performance

## üìù Test Documentation

Keep track of your tests with:

- Test case descriptions
- Expected vs actual results
- Environment details
- Test data used
- Issues found and resolved

This comprehensive testing approach will ensure your Housing Society Management API is robust, secure, and performs well under various conditions. 
‚îÇ   # --- End: API_TESTING_GUIDE.md ---

‚îÇ   ‚îú‚îÄ complete-api-test.js

‚îÇ   # --- Begin: complete-api-test.js ---
const axios = require('axios');

class CompleteAPITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.cookies = [];
    this.testData = {
      admin: null,
      owner: null,
      tenant: null,
      society: null,
      building: null,
      flat: null,
      complaint: null,
      announcement: null,
      ownershipRequest: null,
      maintenance: null,
      rent: null
    };
    this.testResults = {
      total: 59,
      passed: 0,
      failed: 0,
      skipped: 0,
      details: []
    };
  }

  // Helper function to delay execution
  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      // Add a longer delay to avoid rate limiting
      await this.sleep(2000);
      
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
      }

      const response = await axios(config);
      
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        this.cookies = [...this.cookies, ...newCookies];
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      this.recordTestResult(method, endpoint, true);
      return { status: response.status, data: response.data };
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      // Log detailed error information if available
      if (error.response?.data?.errors) {
        console.error('Validation errors:', JSON.stringify(error.response.data.errors, null, 2));
      }
      this.recordTestResult(method, endpoint, false, error.response?.status, error.response?.data?.message || error.message);
      return { status: error.response?.status || 500, data: error.response?.data || null };
    }
  }

  recordTestResult(method, endpoint, success, statusCode = null, errorMessage = null) {
    const result = {
      method,
      endpoint,
      success,
      timestamp: new Date().toISOString()
    };

    if (!success) {
      result.statusCode = statusCode;
      result.errorMessage = errorMessage;
    }

    if (success) {
      this.testResults.passed++;
    } else {
      this.testResults.failed++;
    }

    this.testResults.details.push(result);
  }

  resetCookies() {
    this.cookies = [];
    console.log('üîÑ Cookies reset');
  }

  async runCompleteTest() {
    console.log('üöÄ Starting Complete API Test\n');
    console.log(`üìä Total APIs to test: ${this.testResults.total}\n`);
    
    try {
      // Test all authentication APIs
      await this.testAuthAPIs();
      
      // Test admin APIs - This creates society, building, flats which are needed for other tests
      await this.testAdminAPIs();
      
      // Only proceed with other tests if we have a society and flat created
      if (this.testData.society && this.testData.flat) {
        // Test owner APIs
        await this.testOwnerAPIs();
        
        // Test tenant APIs
        await this.testTenantAPIs();
        
        // Test complaint APIs
        await this.testComplaintAPIs();
        
        // Test announcement APIs
        await this.testAnnouncementAPIs();
        
        // Test ownership request APIs
        await this.testOwnershipRequestAPIs();
      } else {
        console.log('\n‚ö†Ô∏è Society or flat creation failed, skipping dependent tests');
        this.testResults.skipped = this.testResults.total - this.testResults.passed - this.testResults.failed;
      }
    } catch (error) {
      console.error('\n‚ùå Test execution error:', error.message);
    }
    
    // Print test summary
    this.printTestSummary();
    
    console.log('\n‚úÖ Complete API test finished!');
  }

  printTestSummary() {
    console.log('\nüìä Test Summary:');
    console.log(`Total APIs: ${this.testResults.total}`);
    console.log(`Passed: ${this.testResults.passed}`);
    console.log(`Failed: ${this.testResults.failed}`);
    console.log(`Skipped: ${this.testResults.skipped}`);
    
    if (this.testResults.failed > 0) {
      console.log('\n‚ùå Failed Tests:');
      const failedTests = this.testResults.details.filter(test => !test.success);
      failedTests.forEach((test, index) => {
        console.log(`${index + 1}. ${test.method} ${test.endpoint} - Status: ${test.statusCode} - ${test.errorMessage}`);
      });
    }
  }

  async testAuthAPIs() {
    console.log('\nüîê Testing Authentication APIs...');
    
    // 1. Register admin user
    const adminTimestamp = Date.now();
    const adminEmail = `admin${adminTimestamp}@example.com`;
    
    const adminRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Admin User',
      email: adminEmail,
      password: 'admin123',
      phone: '+1234567890',
      role: 'admin'
    });

    if (adminRegisterResponse.status === 201 && adminRegisterResponse.data) {
      this.testData.admin = adminRegisterResponse.data.data;
      console.log('‚úÖ Admin registered:', this.testData.admin.name);
      
      // 2. Register owner user
      const ownerTimestamp = Date.now();
      const ownerEmail = `owner${ownerTimestamp}@example.com`;
      
      const ownerRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
        name: 'Owner User',
        email: ownerEmail,
        password: 'owner123',
        phone: '+1234567891',
        role: 'owner'
      });

      if (ownerRegisterResponse.status === 201 && ownerRegisterResponse.data) {
        this.testData.owner = ownerRegisterResponse.data.data;
        console.log('‚úÖ Owner registered:', this.testData.owner.name);
        
        // 3. Register tenant user
        const tenantTimestamp = Date.now();
        const tenantEmail = `tenant${tenantTimestamp}@example.com`;
        
        const tenantRegisterResponse = await this.makeRequest('POST', '/api/auth/register', {
          name: 'Tenant User',
          email: tenantEmail,
          password: 'tenant123',
          phone: '+1234567892',
          role: 'tenant'
        });

        if (tenantRegisterResponse.status === 201 && tenantRegisterResponse.data) {
          this.testData.tenant = tenantRegisterResponse.data.data;
          console.log('‚úÖ Tenant registered:', this.testData.tenant.name);
          
          // 4. Test login for admin
          this.resetCookies();
          const adminLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
            email: adminEmail,
            password: 'admin123'
          });

          if (adminLoginResponse.status === 200) {
            console.log('‚úÖ Admin login successful');
            
            // 5. Test get current user
            await this.makeRequest('GET', '/api/auth/me');
            
            // 6. Test change password
            await this.makeRequest('PATCH', '/api/auth/change-password', {
              currentPassword: 'admin123',
              newPassword: 'admin1234',
              confirmPassword: 'admin1234'
            });
            
            // 7. Test logout
            await this.makeRequest('POST', '/api/auth/logout');
            
            // 8. Test login with new password
            await this.makeRequest('POST', '/api/auth/login', {
              email: adminEmail,
              password: 'admin1234'
            });
          }
        }
      }
    }
  }

  async testAdminAPIs() {
    console.log('\nüë®‚Äçüíº Testing Admin APIs...');
    
    // Ensure we're logged in as admin
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 1000}@example.com`;
    const adminLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234' // Using the changed password
    });

    if (adminLoginResponse.status === 200) {
      console.log('‚úÖ Admin login successful for API testing');
      
      // 1. Test society management
      // Create society
      const societyData = {
        name: 'Test Society',
        registrationNumber: `REG${Date.now()}`,
        address: {
          street: '123 Test Street',
          city: 'Test City',
          state: 'Test State',
          pincode: '123456',
          country: 'Test Country'
        },
        maintenancePolicy: {
          frequency: 'monthly',
          amountPerFlat: 1000,
          dueDate: 5,
          lateFeesPercentage: 10
        },
        amenities: ['Parking', 'Swimming Pool', 'Gym'],
        establishedYear: new Date().getFullYear()
      };
      
      const societyResponse = await this.makeRequest('POST', '/api/admin/societies', societyData);
      
      // Log the full response for debugging
      console.log('Society creation response:', JSON.stringify(societyResponse.data, null, 2));
      
      if (societyResponse.status === 201 && societyResponse.data) {
        this.testData.society = societyResponse.data.data;
        console.log('‚úÖ Society created successfully');
        
        // Get admin's societies
        await this.makeRequest('GET', '/api/admin/societies/my');
        
        // Update society
        await this.makeRequest('PUT', `/api/admin/societies/${this.testData.society._id}`, {
          name: 'Updated Test Society',
          address: 'Updated Address',
          maintenancePolicy: 'Updated maintenance policy'
        });
        
        // 2. Test building management
        // Create building
        const buildingResponse = await this.makeRequest('POST', '/api/admin/buildings', {
          name: 'Test Building',
          societyId: this.testData.society._id,
          totalFloors: 5,
          totalFlats: 20,
          addressLabel: 'Wing A'
        });
        
        if (buildingResponse.status === 201 && buildingResponse.data) {
          this.testData.building = buildingResponse.data.data;
          console.log('‚úÖ Building created successfully');
          
          // Update building
          await this.makeRequest('PUT', `/api/admin/buildings/${this.testData.building._id}`, {
            name: 'Updated Test Building',
            totalFloors: 6,
            addressLabel: 'Updated Wing A'
          });
          
          // 3. Test flat management
          // Create flats
          const flatsResponse = await this.makeRequest('POST', '/api/admin/flats', {
            buildingId: this.testData.building._id,
            totalFlats: 4
          });
          
          if (flatsResponse.status === 201 && flatsResponse.data) {
            this.testData.flats = flatsResponse.data.data;
            if (this.testData.flats && this.testData.flats.length > 0) {
              this.testData.flat = this.testData.flats[0];
              console.log(`‚úÖ ${this.testData.flats.length} flats created successfully`);
              
              // Assign flat owner
              await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-owner`, {
                ownerId: this.testData.owner._id
              });
              
              // 4. Test user management
              // Get all users
              await this.makeRequest('GET', '/api/admin/users');
              
              // Get user by ID
              await this.makeRequest('GET', `/api/admin/users/${this.testData.owner._id}`);
              
              // Update user
              await this.makeRequest('PATCH', `/api/admin/users/${this.testData.owner._id}`, {
                name: 'Updated Owner Name'
              });
              
              // Toggle user status
              await this.makeRequest('PATCH', `/api/admin/users/${this.testData.owner._id}/toggle-status`);
              
              // 5. Test rent management
              // Generate rent
              const rentResponse = await this.makeRequest('POST', '/api/admin/rent/generate', {
                flatId: this.testData.flat._id,
                amount: 10000,
                dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                description: 'Monthly rent'
              });
              
              if (rentResponse.status === 201 && rentResponse.data) {
                this.testData.rent = rentResponse.data.data;
                console.log('‚úÖ Rent generated successfully');
                
                // Get rent history
                await this.makeRequest('GET', '/api/admin/rent/history');
                
                // 6. Test maintenance management
                // Generate maintenance
                const maintenanceResponse = await this.makeRequest('POST', '/api/admin/maintenance', {
                  societyId: this.testData.society._id,
                  amount: 5000,
                  dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
                  description: 'Monthly maintenance'
                });
                
                if (maintenanceResponse.status === 201 && maintenanceResponse.data) {
                  this.testData.maintenance = maintenanceResponse.data.data;
                  console.log('‚úÖ Maintenance generated successfully');
                  
                  // Get maintenance status
                  await this.makeRequest('GET', '/api/admin/maintenance/status');
                  
                  // 7. Test dashboard
                  // Get admin dashboard
                  await this.makeRequest('GET', '/api/admin/dashboard/overview');
                  
                  // Get flat info
                  await this.makeRequest('GET', `/api/admin/flats/${this.testData.flat._id}/info`);
                  
                  // 8. Test notes & reminders
                  // Add society note
                  await this.makeRequest('PATCH', `/api/admin/societies/${this.testData.society._id}/note`, {
                    note: 'Test society note'
                  });
                  
                  // Send reminder to user
                  await this.makeRequest('POST', `/api/admin/users/${this.testData.owner._id}/reminder`, {
                    message: 'Test reminder message',
                    subject: 'Test reminder'
                  });
                }
              }
            }
          }
        }
      }
    }
  }

  async testOwnerAPIs() {
    console.log('\nüè† Testing Owner APIs...');
    
    // Ensure we're logged in as owner
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    const ownerLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });

    if (ownerLoginResponse.status === 200) {
      console.log('‚úÖ Owner login successful for API testing');
      
      // 1. Test dashboard & profile
      // Get owner dashboard
      await this.makeRequest('GET', '/api/owner/dashboard/overview');
      
      // Update owner profile
      await this.makeRequest('PATCH', '/api/auth/profile', {
        name: 'Updated Owner Profile',
        phone: '+1234567899'
      });
      
      // 2. Test flat management
      // Get owner's flats
      await this.makeRequest('GET', '/api/owner/flats');
      
      // Get flat society info
      if (this.testData.flat && this.testData.flat._id) {
        await this.makeRequest('GET', `/api/owner/flats/${this.testData.flat._id}/society`);
      }
      
      // 3. Test rent & maintenance
      // Get rent history
      await this.makeRequest('GET', '/api/owner/rent-history');
      
      // Get unpaid maintenance
      await this.makeRequest('GET', '/api/owner/maintenance-due');
      
      // Pay maintenance
      if (this.testData.maintenance && this.testData.maintenance._id) {
        await this.makeRequest('PATCH', `/api/owner/maintenance/${this.testData.maintenance._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 4. Test ownership requests
      // Create ownership request
      if (this.testData.flat && this.testData.flat._id) {
        const ownershipRequestResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
          flatId: this.testData.flat._id,
          documents: 'Test ownership documents',
          requestNotes: 'Test ownership request'
        });
        
        if (ownershipRequestResponse.status === 201 && ownershipRequestResponse.data) {
          this.testData.ownershipRequest = ownershipRequestResponse.data.data;
          console.log('‚úÖ Ownership request created successfully');
          
          // Get my ownership requests
          await this.makeRequest('GET', '/api/owner/ownership-requests/my');
        }
      }
    }
  }

  async testTenantAPIs() {
    console.log('\nüë§ Testing Tenant APIs...');
    
    // First, assign tenant to flat as admin
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234' // Using the changed password
    });
    
    if (this.testData.flat && this.testData.flat._id && this.testData.tenant && this.testData.tenant._id) {
      await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-tenant`, {
        tenantId: this.testData.tenant._id,
        rentAmount: 10000,
        securityDeposit: 20000,
        leaseStart: new Date().toISOString(),
        leaseDuration: 12 // months
      });
      
      console.log('‚úÖ Tenant assigned to flat');
    }
    
    // Now login as tenant
    this.resetCookies();
    const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
    const tenantLoginResponse = await this.makeRequest('POST', '/api/auth/login', {
      email: tenantEmail,
      password: 'tenant123'
    });

    if (tenantLoginResponse.status === 200) {
      console.log('‚úÖ Tenant login successful for API testing');
      
      // 1. Test dashboard & profile
      // Get tenant dashboard
      await this.makeRequest('GET', '/api/tenant/dashboard/overview');
      
      // Update tenant profile
      await this.makeRequest('PATCH', '/api/auth/profile', {
        name: 'Updated Tenant Profile',
        phone: '+1234567898'
      });
      
      // 2. Test flat & rent management
      // Get tenant's flat
      await this.makeRequest('GET', '/api/tenant/my-flat');
      
      // Get rent history
      await this.makeRequest('GET', '/api/tenant/rent-history');
      
      // Get rent due
      await this.makeRequest('GET', '/api/tenant/rent/due');
      
      // Pay rent
      if (this.testData.rent && this.testData.rent._id) {
        await this.makeRequest('PATCH', `/api/tenant/rent/${this.testData.rent._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 3. Test maintenance
      // Get unpaid maintenance
      await this.makeRequest('GET', '/api/tenant/maintenance-due');
      
      // Pay maintenance
      if (this.testData.maintenance && this.testData.maintenance._id) {
        await this.makeRequest('PATCH', `/api/tenant/maintenance/${this.testData.maintenance._id}/pay`, {
          paymentMethod: 'online',
          transactionId: `TXN${Date.now()}`
        });
      }
      
      // 4. Test announcements
      // Get relevant announcements
      await this.makeRequest('GET', '/api/tenant/announcements');
    }
  }

  async testComplaintAPIs() {
    console.log('\nüìù Testing Complaint APIs...');
    
    // 1. Test owner complaint creation
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });
    
    const ownerComplaintResponse = await this.makeRequest('POST', '/api/complaints', {
      title: 'Owner Test Complaint',
      description: 'This is a test complaint from owner',
      category: 'maintenance',
      priority: 'medium',
      societyId: this.testData.society?._id || null,
      flatId: this.testData.flat?._id || null
    });
    
    if (ownerComplaintResponse.status === 201 && ownerComplaintResponse.data) {
      this.testData.complaint = ownerComplaintResponse.data.data;
      console.log('‚úÖ Owner complaint created successfully');
      
      // Get owner's complaints
      await this.makeRequest('GET', '/api/complaints/my');
    }
    
    // 2. Test tenant complaint creation
    this.resetCookies();
    const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: tenantEmail,
      password: 'tenant123'
    });
    
    await this.makeRequest('POST', '/api/complaints', {
      title: 'Tenant Test Complaint',
      description: 'This is a test complaint from tenant',
      category: 'security',
      priority: 'high',
      societyId: this.testData.society?._id || null,
      flatId: this.testData.flat?._id || null
    });
    
    // Get tenant's complaints
    await this.makeRequest('GET', '/api/complaints/my');
    
    // 3. Test admin complaint management
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234'
    });
    
    // Get all complaints
    await this.makeRequest('GET', '/api/complaints');
    
    // Update complaint status
    if (this.testData.complaint && this.testData.complaint._id) {
      await this.makeRequest('PATCH', `/api/complaints/${this.testData.complaint._id}`, {
        status: 'in-progress',
        adminResponse: 'Working on this issue'
      });
    }
  }

  async testAnnouncementAPIs() {
    console.log('\nüì¢ Testing Announcement APIs...');
    
    // 1. Test admin announcement management
    this.resetCookies();
    const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: adminEmail,
      password: 'admin1234'
    });
    
    // Create announcement
    const announcementResponse = await this.makeRequest('POST', '/api/announcements', {
      title: 'Test Announcement',
      content: 'This is a test announcement',
      type: 'general',
      societyId: this.testData.society?._id,
      audience: ['all'],
      validUntil: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()
    });
    
    if (announcementResponse.status === 201 && announcementResponse.data) {
      this.testData.announcement = announcementResponse.data.data;
      console.log('‚úÖ Announcement created successfully');
      
      // Get all announcements
      await this.makeRequest('GET', '/api/announcements');
      
      // Update announcement
      if (this.testData.announcement && this.testData.announcement._id) {
        await this.makeRequest('PUT', `/api/announcements/${this.testData.announcement._id}`, {
          title: 'Updated Test Announcement',
          content: 'This is an updated test announcement',
          type: 'important'
        });
      }
      
      // 2. Test user announcement viewing
      // Owner view announcements
      this.resetCookies();
      const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
      await this.makeRequest('POST', '/api/auth/login', {
        email: ownerEmail,
        password: 'owner123'
      });
      
      await this.makeRequest('GET', '/api/announcements/relevant');
      
      // Tenant view announcements
      this.resetCookies();
      const tenantEmail = this.testData.tenant?.email || `tenant${Date.now() - 1000}@example.com`;
      await this.makeRequest('POST', '/api/auth/login', {
        email: tenantEmail,
        password: 'tenant123'
      });
      
      await this.makeRequest('GET', '/api/announcements/relevant');
      
      // 3. Test announcement deletion
      this.resetCookies();
      await this.makeRequest('POST', '/api/auth/login', {
        email: adminEmail,
        password: 'admin1234'
      });
      
      if (this.testData.announcement && this.testData.announcement._id) {
        await this.makeRequest('DELETE', `/api/announcements/${this.testData.announcement._id}`);
      }
    }
  }

  async testOwnershipRequestAPIs() {
    console.log('\nüìã Testing Ownership Request APIs...');
    
    // 1. Test owner ownership request creation
    this.resetCookies();
    const ownerEmail = this.testData.owner?.email || `owner${Date.now() - 1000}@example.com`;
    await this.makeRequest('POST', '/api/auth/login', {
      email: ownerEmail,
      password: 'owner123'
    });
    
    if (this.testData.flat && this.testData.flat._id) {
      const ownershipRequestResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
        flatId: this.testData.flat._id,
        documents: 'Test ownership documents',
        requestNotes: 'Test ownership request'
      });
      
      if (ownershipRequestResponse.status === 201 && ownershipRequestResponse.data) {
        this.testData.ownershipRequest = ownershipRequestResponse.data.data;
        console.log('‚úÖ Ownership request created successfully');
        
        // Get my ownership requests
        await this.makeRequest('GET', '/api/owner/ownership-requests/my');
        
        // 2. Test admin ownership request management
        this.resetCookies();
        const adminEmail = this.testData.admin?.email || `admin${Date.now() - 2000}@example.com`;
        await this.makeRequest('POST', '/api/auth/login', {
          email: adminEmail,
          password: 'admin1234'
        });
        
        // Get all ownership requests
        const adminRequestsResponse = await this.makeRequest('GET', '/api/admin/ownership-requests');
        
        if (adminRequestsResponse.status === 200 && adminRequestsResponse.data && 
            adminRequestsResponse.data.data && adminRequestsResponse.data.data.length > 0) {
          const requestId = adminRequestsResponse.data.data[0]._id;
          
          // Review ownership request
          await this.makeRequest('PATCH', '/api/admin/ownership-requests/review', {
            requestId,
            status: 'approved',
            reviewNotes: 'Approved by admin'
          });
        }
      }
    }
  }
}

// Run the complete test
if (require.main === module) {
  const tester = new CompleteAPITester();
  tester.runCompleteTest();
}

module.exports = CompleteAPITester;
‚îÇ   # --- End: complete-api-test.js ---

‚îÇ   ‚îú‚îÄ COMPLETE_API_LIST.md

‚îÇ   # --- Begin: COMPLETE_API_LIST.md ---
# üìã Complete API List - Housing Society Management System

## üîê Authentication APIs (`/api/auth`)
1. `POST /register` - Register new user
2. `POST /login` - User login
3. `GET /me` - Get current user
4. `PATCH /change-password` - Change password
5. `POST /logout` - User logout

## üë®‚Äçüíº Admin APIs (`/api/admin`)

### Society Management
6. `POST /societies` - Create society
7. `GET /societies/my` - Get admin's societies
8. `PUT /societies/:id` - Update society
9. `DELETE /societies/:id` - Delete society

### Building Management
10. `POST /buildings` - Create building
11. `PUT /buildings/:id` - Update building
12. `DELETE /buildings/:id` - Delete building

### Flat Management
13. `POST /flats` - Create flats
14. `PATCH /flats/:flatId/assign-owner` - Assign flat owner
15. `PATCH /flats/:flatId/remove-owner` - Remove flat owner
16. `PATCH /flats/:flatId/remove-tenant` - Remove flat tenant

### User Management
17. `GET /users` - Get all users
18. `GET /users/:id` - Get user by ID
19. `PATCH /users/:id` - Update user
20. `PATCH /users/:id/toggle-status` - Toggle user status

### Rent Management
21. `POST /rent/generate` - Generate rent
22. `GET /rent/history` - Get rent history

### Maintenance
23. `POST /maintenance` - Generate maintenance
24. `GET /maintenance/status` - Get maintenance status

### Ownership Requests
25. `GET /ownership-requests` - Get ownership requests
26. `PATCH /ownership-requests/review` - Review ownership request

### Dashboard & Documents
27. `GET /dashboard/overview` - Admin dashboard
28. `GET /flats/:flatId/info` - Get flat info

### Notes & Reminders
29. `PATCH /societies/:id/note` - Add society note
30. `POST /users/:id/reminder` - Send reminder to user

## üè† Owner APIs (`/api/owner`)

### Dashboard & Profile
31. `GET /dashboard/overview` - Owner dashboard
32. `PATCH /profile` - Update owner profile

### Flat Management
33. `GET /flats` - Get owner's flats
34. `GET /flats/:id/society` - Get flat society info

### Rent & Maintenance
35. `GET /rent-history` - Get rent history
36. `GET /maintenance-due` - Get unpaid maintenance
37. `PATCH /maintenance/:maintenanceId/pay` - Pay maintenance

## üè† Tenant APIs (`/api/tenant`)

### Dashboard & Profile
38. `GET /dashboard/overview` - Tenant dashboard
39. `PATCH /profile` - Update tenant profile

### Flat & Rent Management
40. `GET /my-flat` - Get tenant's flat
41. `GET /rent-history` - Get rent history
42. `PATCH /rent/:rentId/pay` - Pay rent
43. `GET /rent-due` - Get rent due

### Maintenance
44. `GET /maintenance-due` - Get unpaid maintenance
45. `PATCH /maintenance/:maintenanceId/pay` - Pay maintenance

### Announcements
46. `GET /announcements` - Get relevant announcements

## üìù Complaint APIs (`/api/complaints`)

### User Complaints
47. `POST /` - Create complaint (Owner/Tenant)
48. `GET /my` - Get my complaints (Owner/Tenant)

### Admin Complaint Management
49. `GET /` - Get all complaints (Admin)
50. `PATCH /:id` - Update complaint status (Admin)

## üì¢ Announcement APIs (`/api/announcements`)

### Admin Announcement Management
51. `POST /` - Create announcement (Admin)
52. `GET /` - Get all announcements (Admin)
53. `PUT /:id` - Update announcement (Admin)
54. `DELETE /:id` - Delete announcement (Admin)

### User Announcements
55. `GET /relevant` - Get relevant announcements (Owner/Tenant)

## üìã Ownership Request APIs (`/api/ownership-requests`)

### User Requests
56. `POST /` - Create ownership request (Owner)
57. `GET /my` - Get my ownership requests (Owner)

### Admin Management
58. `GET /` - Get all ownership requests (Admin)
59. `PATCH /:requestId` - Review ownership request (Admin)

## üìä Total Count: 59 APIs

### Breakdown by Role:
- **Authentication**: 5 APIs
- **Admin**: 25 APIs
- **Owner**: 7 APIs
- **Tenant**: 9 APIs
- **Complaints**: 4 APIs
- **Announcements**: 5 APIs
- **Ownership Requests**: 4 APIs

### API Categories:
- **CRUD Operations**: Society, Building, Flat, User management
- **Financial**: Rent generation, payment, maintenance
- **Communication**: Announcements, complaints
- **Dashboard**: Overview data for all roles
- **Profile Management**: User profile updates
- **Ownership**: Transfer requests and management 
‚îÇ   # --- End: COMPLETE_API_LIST.md ---

‚îÇ   ‚îú‚îÄ comprehensive-api-test.js

‚îÇ   # --- Begin: comprehensive-api-test.js ---
const axios = require('axios');

class ComprehensiveAPITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.cookies = [];
    this.testData = {
      admin: null,
      owner: null,
      tenant: null,
      society: null,
      building: null,
      flat: null
    };
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
      }

      const response = await axios(config);
      
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        this.cookies = [...this.cookies, ...newCookies];
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      return { status: response.status, data: response.data };
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      return { status: error.response?.status || 500, data: error.response?.data || null };
    }
  }

  resetCookies() {
    this.cookies = [];
    console.log('üîÑ Cookies reset');
  }

  async runComprehensiveTest() {
    console.log('üöÄ Starting Comprehensive API Test\n');
    
    await this.testAdminFlow();
    await this.testOwnerFlow();
    await this.testTenantFlow();
    
    console.log('\n‚úÖ Comprehensive API test completed!');
  }

  async testAdminFlow() {
    console.log('\nüë®‚Äçüíº Testing Admin Flow...');
    
    // 1. Register admin user
    const timestamp = Date.now();
    const adminEmail = `admin${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Admin User',
      email: adminEmail,
      password: 'admin123',
      phone: '+1234567890',
      role: 'admin'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.admin = registerResponse.data.data;
      console.log('‚úÖ Admin registered:', this.testData.admin.name);
      
      // 2. Login as admin
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: adminEmail,
        password: 'admin123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Admin login successful');
        
        // 3. Test admin routes
        await this.makeRequest('GET', '/api/admin/users');
        await this.makeRequest('GET', '/api/admin/dashboard/overview');
        
        // 4. Create a society
        const societyData = {
          name: 'Test Society',
          registrationNumber: `REG${Date.now()}`,
          address: '123 Test Street, Test City, Test State, 123456',
          maintenancePolicy: 'Monthly maintenance of 1000 per flat'
        };
        console.log('Society data:', societyData);
        
        const societyResponse = await this.makeRequest('POST', '/api/admin/societies', societyData);
        
        if (societyResponse.status === 201 && societyResponse.data) {
          console.log('‚úÖ Society created successfully');
          this.testData.society = societyResponse.data.data;
          
          // 5. Create a building in the society
          const buildingResponse = await this.makeRequest('POST', '/api/admin/buildings', {
            name: 'Test Building',
            societyId: this.testData.society._id,
            totalFloors: 5,
            totalFlats: 20,
            addressLabel: 'Wing A'
          });
        } else {
          console.log('‚ùå Society creation failed with response:', JSON.stringify(societyResponse.data, null, 2));
        }

        if (this.testData.society && buildingResponse && buildingResponse.status === 201 && buildingResponse.data) {
          this.testData.building = buildingResponse.data.data;
          console.log('‚úÖ Building created:', this.testData.building.name);
          
          // 6. Create flats in the building
          const flatsResponse = await this.makeRequest('POST', '/api/admin/flats', {
            buildingId: this.testData.building._id,
            totalFlats: 4
          });
          
          if (flatsResponse.status === 201 && flatsResponse.data) {
            this.testData.flats = flatsResponse.data.data;
            if (this.testData.flats && this.testData.flats.length > 0) {
              this.testData.flat = this.testData.flats[0];
              console.log(`‚úÖ ${this.testData.flats.length} flats created successfully`);
            }
          } else {
            console.log('‚ùå Flat creation failed with response:', JSON.stringify(flatsResponse.data, null, 2));
          }
        }
      }
    }
  }

  async testOwnerFlow() {
    console.log('\nüë®‚Äçüíº Testing Owner Flow...');
    
    // Reset cookies before testing with owner user
    this.resetCookies();
    
    // 1. Register owner user
    const timestamp = Date.now();
    const ownerEmail = `owner${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Owner User',
      email: ownerEmail,
      password: 'owner123',
      phone: '+1234567890',
      role: 'owner'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.owner = registerResponse.data.data;
      console.log('‚úÖ Owner registered:', this.testData.owner.name);
      
      // 2. Login as owner
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: ownerEmail,
        password: 'owner123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Owner login successful');
        
        // 3. Test owner routes
        await this.makeRequest('GET', '/api/owner/dashboard/overview');
        await this.makeRequest('GET', '/api/owner/flats');
        
        // 4. If we have a flat from admin flow, request ownership
        if (this.testData.flat && this.testData.flat._id) {
          // 5. Request ownership of a flat
          const ownershipResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', {
            flatId: this.testData.flat._id,
            documents: 'Test ownership documents',
            requestNotes: 'Test ownership request'
          });
          
          if (ownershipResponse.status === 201) {
            console.log('‚úÖ Ownership request created');
            
            // 6. Switch to admin to approve the request
            this.resetCookies();
            
            // Login as admin
            await this.makeRequest('POST', '/api/auth/login', {
              email: `admin${Date.now() - 1000}@example.com`, // Use the previously created admin
              password: 'admin123'
            });
            
            // Get ownership requests as admin
            const adminRequestsResponse = await this.makeRequest('GET', '/api/admin/ownership-requests');
            
            if (adminRequestsResponse.status === 200 && adminRequestsResponse.data && adminRequestsResponse.data.data && adminRequestsResponse.data.data.length > 0) {
              const requestId = adminRequestsResponse.data.data[0]._id;
              
              // Approve the request
              await this.makeRequest('PATCH', '/api/admin/ownership-requests/review', {
                requestId,
                status: 'approved',
                reviewNotes: 'Approved by admin'
              });
              
              console.log('‚úÖ Ownership request approved by admin');
              
              // Assign flat owner
              await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-owner`, {
                ownerId: this.testData.owner._id
              });
              
              console.log('‚úÖ Flat assigned to owner');
            }
          }
        }
      }
    }
  }

  async testTenantFlow() {
    console.log('\nüë§ Testing Tenant Flow...');
    
    // Reset cookies before testing with tenant user
    this.resetCookies();
    
    // 1. Register tenant user
    const timestamp = Date.now();
    const tenantEmail = `tenant${timestamp}@example.com`;
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', {
      name: 'Tenant User',
      email: tenantEmail,
      password: 'tenant123',
      phone: '+1234567890',
      role: 'tenant'
    });

    if (registerResponse.status === 201 && registerResponse.data) {
      this.testData.tenant = registerResponse.data.data;
      console.log('‚úÖ Tenant registered:', this.testData.tenant.name);
      
      // 2. Login as tenant
      const loginResponse = await this.makeRequest('POST', '/api/auth/login', {
        email: tenantEmail,
        password: 'tenant123'
      });

      if (loginResponse.status === 200) {
        console.log('‚úÖ Tenant login successful');
        
        // 3. Test tenant routes
        await this.makeRequest('GET', '/api/tenant/dashboard/overview');
        
        // 4. If we have a flat from admin flow, assign tenant
        if (this.testData.flat && this.testData.flat._id) {
          // Switch to admin to assign tenant
          this.resetCookies();
          
          // Login as admin
          await this.makeRequest('POST', '/api/auth/login', {
            email: `admin${Date.now() - 1000}@example.com`, // Use the previously created admin
            password: 'admin123'
          });
          
          // Assign tenant to flat
          await this.makeRequest('PATCH', `/api/admin/flats/${this.testData.flat._id}/assign-tenant`, {
            tenantId: this.testData.tenant._id,
            rentAmount: 10000,
            securityDeposit: 20000,
            leaseStart: new Date().toISOString(),
            leaseDuration: 12 // months
          });
          
          console.log('‚úÖ Tenant assigned to flat');
          
          // Generate rent for tenant
          await this.makeRequest('POST', '/api/admin/rents/generate', {
            flatId: this.testData.flat._id,
            amount: 10000,
            dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7 days from now
            description: 'Monthly rent'
          });
          
          console.log('‚úÖ Rent generated for tenant');
          
          // Switch back to tenant to check rent
          this.resetCookies();
          
          // Login as tenant
          await this.makeRequest('POST', '/api/auth/login', {
            email: tenantEmail,
            password: 'tenant123'
          });
          
          // Check tenant's flat
          await this.makeRequest('GET', '/api/tenant/my-flat');
          
          // Check tenant's rent history
          await this.makeRequest('GET', '/api/tenant/rent-history');
        }
      }
    }
  }
}

// Run the comprehensive test
if (require.main === module) {
  const tester = new ComprehensiveAPITester();
  tester.runComprehensiveTest();
}

module.exports = ComprehensiveAPITester;

‚îÇ   # --- End: project.txt ---

‚îÇ   ‚îú‚îÄ quick-api-test.js

‚îÇ   # --- Begin: quick-api-test.js ---
const axios = require('axios');

class APITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.cookies = [];
    this.testCount = 0;
    this.passCount = 0;
  }

  resetSession() {
    this.cookies = [];
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers,
        },
        withCredentials: true,
        // Allow us to handle all status codes without throwing an error
        validateStatus: () => true,
      };

      if (data) {
        config.data = data;
      }

      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
      }

      const response = await axios(config);

      if (response.headers['set-cookie']) {
        // More robust cookie parsing and storage to avoid duplicates
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        const uniqueCookies = new Map();
        [...this.cookies, ...newCookies].forEach(cookie => {
            const [key] = cookie.split('=');
            uniqueCookies.set(key, cookie);
        });
        this.cookies = Array.from(uniqueCookies.values());
      }

      return response;
    } catch (error) {
      console.error(`‚ùå NETWORK ERROR on ${method} ${endpoint}: ${error.message}`);
      // Return a consistent shape for network errors
      return { status: 500, data: { message: error.message } };
    }
  }

  check(testName, response, expectedStatus) {
    this.testCount++;
    if (response && response.status === expectedStatus) {
      console.log(`‚úÖ PASS: [${response.status}] ${testName}`);
      this.passCount++;
      return true;
    } else {
      const status = response ? response.status : 'No Response';
      const message = response ? JSON.stringify(response.data) : 'Request failed';
      console.error(`‚ùå FAIL: [${status}] ${testName}. Expected ${expectedStatus}. Response: ${message}`);
      return false;
    }
  }

  printSummary() {
    console.log('\n--------------------');
    console.log('üìä Test Summary');
    console.log(`Total Tests: ${this.testCount}`);
    console.log(`Passed: ${this.passCount}`);
    console.log(`Failed: ${this.testCount - this.passCount}`);
    console.log('--------------------\n');
    if (this.passCount !== this.testCount) {
        process.exit(1); // Exit with error code if tests failed

  }
}

// Run the quick test
if (require.main === module) {
  const tester = new QuickAPITester();
  tester.testKeyAPIs();
}

module.exports = QuickAPITester; 
‚îÇ   # --- End: quick-api-test.js ---

‚îÇ   ‚îú‚îÄ quick-test.sh

‚îÇ   # --- Begin: quick-test.sh ---
 
‚îÇ   # --- End: quick-test.sh ---

‚îÇ   ‚îú‚îÄ README.md

‚îÇ   # --- Begin: README.md ---
# Housing Society Management System - Backend

A robust, scalable, and secure Node.js backend for managing housing societies, buildings, flats, tenants, and maintenance.

## üöÄ Features

### Core Functionality
- **Society Management**: Create, update, and delete housing societies
- **Building Management**: Manage buildings with automatic flat generation
- **Flat Management**: Assign owners and tenants to flats
- **User Management**: Multi-role system (Admin, Owner, Tenant)
- **Complaint System**: File and track complaints by category
- **Maintenance Tracking**: Generate and track maintenance bills
- **Rent Management**: Track rent payments and overdue amounts
- **Announcement System**: Create and distribute announcements
- **Ownership Requests**: Handle flat ownership transfer requests

### Security Features
- **XSS Protection**: Enabled `xss-clean` middleware
- **NoSQL Injection Protection**: Enabled `express-mongo-sanitize`
- **Rate Limiting**: 100 requests per 15 minutes per IP
- **Helmet Security**: HTTP headers security
- **JWT Authentication**: Secure token-based authentication
- **Role-based Access Control**: Granular permissions per user role
- **Input Validation**: Comprehensive validation using `express-validator`

### API Features
- **RESTful Design**: Consistent API structure
- **Response Formatting**: Standardized response format
- **Pagination**: Built-in pagination support
- **Error Handling**: Centralized error handling
- **Logging**: File-based logging with different levels
- **Database Indexing**: Optimized queries with strategic indexes

## üèóÔ∏è Architecture

### Directory Structure
```
‚îú‚îÄ‚îÄ config/           # Database and environment configuration
‚îú‚îÄ‚îÄ controllers/      # Business logic handlers
‚îú‚îÄ‚îÄ middleware/       # Authentication and validation middleware
‚îú‚îÄ‚îÄ models/          # MongoDB schemas with indexes
‚îú‚îÄ‚îÄ routes/          # API route definitions
‚îú‚îÄ‚îÄ services/        # Business logic services
‚îú‚îÄ‚îÄ utils/           # Utility functions and helpers
‚îú‚îÄ‚îÄ validators/      # Input validation schemas
‚îú‚îÄ‚îÄ logs/            # Application logs
‚îî‚îÄ‚îÄ server.js        # Main application entry point
```

### Key Components

#### Security Middleware
- `authMiddleware.js`: JWT token validation
- `roleMiddleware.js`: Role-based access control
- `roleAccessGuard.js`: Additional access validation

#### Validation
- `adminValidator.js`: Admin route validations
- `ownerValidator.js`: Owner route validations
- `tenantValidator.js`: Tenant route validations
- `authValidator.js`: Authentication validations

#### Services
- `dashboardService.js`: Dashboard data aggregation
- `complaintService.js`: Complaint management logic
- `paymentService.js`: Payment processing logic

## üìä API Endpoints

### Authentication
- `POST /api/auth/register` - User registration
- `POST /api/auth/login` - User login
- `POST /api/auth/logout` - User logout

### Admin Routes (`/api/admin`)
- **Societies**: `POST`, `GET`, `PUT`, `DELETE /societies`
- **Buildings**: `POST`, `PUT`, `DELETE /buildings`
- **Flats**: `POST /flats` (auto-generate), `PATCH /flats/:id/assign-owner`
- **Complaints**: `GET /complaints`, `PATCH /complaints/:id`
- **Announcements**: `POST`, `GET /announcements`
- **Dashboard**: `GET /dashboard/overview`
- **Ownership Requests**: `GET`, `PATCH /ownership-requests`

### Owner Routes (`/api/owner`)
- **Flats**: `GET /flats`, `GET /flats/:id/society`
- **Tenants**: `PATCH /flats/:id/assign-tenant`, `PATCH /flats/:flatId/update-tenant`
- **Complaints**: `POST`, `GET /complaints`
- **Maintenance**: `GET /maintenance-due`, `PATCH /maintenance/:id/pay`
- **Dashboard**: `GET /dashboard/overview`

### Tenant Routes (`/api/tenant`)
- **Flat Info**: `GET /my-flat`
- **Rent**: `GET /rent-history`, `GET /current-rent`, `PATCH /rent/:id/pay`
- **Maintenance**: `GET /maintenance-due`, `PATCH /maintenance/:id/pay`
- **Complaints**: `POST`, `GET /complaints`
- **Announcements**: `GET /announcements`
- **Profile**: `PATCH /profile`
- **Dashboard**: `GET /dashboard/overview`

## üîß Database Models

### Optimized with Indexes
- **Building**: Auto-generates flats on creation
- **Flat**: Compound index on `{building: 1, flatNumber: 1}`
- **Complaint**: Index on `{status: 1}` for filtering
- **User**: Role-based queries optimized
- **Society**: Admin-based queries optimized

### Pre-save Hooks
- **Building Model**: Automatically creates flats based on `totalFlats` and `totalFloors`

## üõ°Ô∏è Security Features

### Input Validation
- All routes with `req.body` or `req.query` have comprehensive validation
- MongoDB ObjectId validation for all ID parameters
- String length and format validation
- Enum validation for status fields

### Authentication & Authorization
- JWT-based authentication with cookie and header support
- Role-based middleware for all protected routes
- Additional access guards for owner/tenant specific operations

### Security Headers
- Helmet for security headers
- XSS protection enabled
- NoSQL injection protection enabled
- Rate limiting to prevent abuse

## üìà Performance Optimizations

### Database Indexes
- Strategic indexes on frequently queried fields
- Compound indexes for common query patterns
- Status-based indexes for filtering operations

### Service Layer
- Dashboard data aggregation moved to dedicated service
- Efficient data fetching with population
- Optimized queries with proper indexing

### Logging
- File-based logging with JSON format
- Different log levels (INFO, ERROR, WARN, DEBUG)
- Development console logging
- Request logging with Morgan

## üöÄ Getting Started

### Prerequisites
- Node.js (v14 or higher)
- MongoDB
- npm or yarn

### Installation
1. Clone the repository
2. Install dependencies: `npm install`
3. Create `.env` file with required environment variables
4. Start the server: `npm start`

### Environment Variables
```env
NODE_ENV=development
PORT=5000
MONGO_URI=mongodb://localhost:27017/housing-society
JWT_SECRET=your-jwt-secret
JWT_EXPIRE=30d
```

## üîÑ Recent Refactoring Improvements

### Phase 1: Security and Middleware
- ‚úÖ Enabled XSS and NoSQL injection protection
- ‚úÖ Comprehensive input validation for all routes
- ‚úÖ Proper middleware application across all routes

### Phase 2: API and Controller Refactoring
- ‚úÖ Consolidated announcement functionality
- ‚úÖ Implemented full CRUD for societies and buildings
- ‚úÖ Created dashboard service for data aggregation
- ‚úÖ Enhanced admin dashboard with meaningful metrics

### Phase 3: Database Optimization
- ‚úÖ Added pre-save hook to Building model for auto flat generation
- ‚úÖ Added compound index on Flat model for building+flatNumber queries
- ‚úÖ Added status index on Complaint model for filtering

### Phase 4: Final Cleanup
- ‚úÖ Replaced console.log with proper file-based logging
- ‚úÖ Ensured consistent use of formatResponse utility
- ‚úÖ Enhanced error handling and logging

## üìù API Response Format

All API responses follow a consistent format:
```json
{
  "success": true,
  "message": "Operation successful",
  "data": {},
  "statusCode": 200
}
```

## üîç Monitoring and Logging

- **Application Logs**: Stored in `logs/app.log`
- **Request Logs**: HTTP request/response logging
- **Error Tracking**: Comprehensive error logging with stack traces
- **Performance**: Response time tracking

## ü§ù Contributing

1. Follow the existing code structure
2. Add proper validation for new routes
3. Use the formatResponse utility for all responses
4. Add appropriate indexes for new database queries
5. Include proper error handling and logging

## üìÑ License

This project is licensed under the ISC License.

‚îÇ   # --- End: README.md ---

‚îÇ   ‚îú‚îÄ run-api-tests.js

‚îÇ   # --- Begin: run-api-tests.js ---
const CompleteAPITester = require('./complete-api-test.js');

console.log('Starting focused society creation test.');
console.log('Starting focused society creation test...');

async function runTests() {
  try {
    const tester = new CompleteAPITester();
    
    // Override the makeRequest method to log detailed error responses
    const originalMakeRequest = tester.makeRequest;
    tester.makeRequest = async function(method, endpoint, data = null, headers = {}) {
      // Special handling for society creation
      if (method === 'POST' && endpoint === '/api/admin/societies') {
        console.log('Original society data:', JSON.stringify(data, null, 2));
        
        // Convert address object to string for validator
        if (data.address && typeof data.address === 'object') {
          const addressObj = data.address;
          data.address = `${addressObj.street}, ${addressObj.city}, ${addressObj.state}, ${addressObj.pincode}`;
        }
        
        // Convert maintenancePolicy object to string for validator
        if (data.maintenancePolicy && typeof data.maintenancePolicy === 'object') {
          const policyObj = data.maintenancePolicy;
          data.maintenancePolicy = `Frequency: ${policyObj.frequency}, Amount: ${policyObj.amountPerFlat}`;
        }
        
        console.log('Modified society data:', JSON.stringify(data, null, 2));
      }
      
      const response = await originalMakeRequest.call(this, method, endpoint, data, headers);
      
      if (response.status >= 400) {
        console.log('Detailed error response:', JSON.stringify(response.data, null, 2));
      }
      
      return response;
    };
    
    await tester.runCompleteTest();
  } catch (error) {
    console.error('Error running API tests:', error);
  }
  console.log('API testing completed!');
}

runTests();
‚îÇ   # --- End: run-api-tests.js ---

‚îÇ   ‚îú‚îÄ setup-test-env.js

‚îÇ   # --- Begin: setup-test-env.js ---
const fs = require('fs');
const { execSync } = require('child_process');

console.log('üîß Setting up test environment for Housing Society Management API...\n');

// Check if we're in the right directory
if (!fs.existsSync('server')) {
    console.error('‚ùå Error: Please run this script from the project root directory');
    process.exit(1);
}

try {
    // Install axios for testing
    console.log('üì¶ Installing axios for API testing...');
    execSync('npm install axios', { stdio: 'inherit' });
    
    // Install server dependencies
    console.log('üì¶ Installing server dependencies...');
    execSync('cd server && npm install', { stdio: 'inherit' });
    
    // Make quick-test.sh executable
    console.log('üîß Making quick-test.sh executable...');
    execSync('chmod +x quick-test.sh', { stdio: 'inherit' });
    
    console.log('\n‚úÖ Test environment setup completed!');
    console.log('\nüìã Available testing commands:');
    console.log('  ‚Ä¢ npm run test:api     - Run comprehensive API tests');
    console.log('  ‚Ä¢ npm run test:quick   - Run quick API tests');
    console.log('  ‚Ä¢ npm run test:dev     - Start server with nodemon');
    console.log('  ‚Ä¢ node test-api.js     - Run Node.js test script');
    console.log('  ‚Ä¢ ./quick-test.sh      - Run bash test script');
    
    console.log('\nüöÄ To start testing:');
    console.log('  1. Start the server: cd server && npm start');
    console.log('  2. In another terminal, run: npm run test:api');
    
} catch (error) {
    console.error('‚ùå Setup failed:', error.message);
    process.exit(1);
} 
‚îÇ   # --- End: setup-test-env.js ---

‚îÇ   ‚îú‚îÄ test-all-apis.js

‚îÇ   # --- Begin: test-all-apis.js ---
const axios = require('axios');

const API_URL = 'http://localhost:5000/api';
let cookies = '';

async function makeRequest(method, endpoint, data = null) {
  try {
    const response = await axios({
      method,
      url: `${API_URL}${endpoint}`,
      data,
      headers: {
        'Content-Type': 'application/json',
        Cookie: cookies
      },
      withCredentials: true
    });
    
    // Save cookies for subsequent requests
    if (response.headers['set-cookie']) {
      cookies = response.headers['set-cookie'].join('; ');
    }
    
    console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
    return response;
  } catch (error) {
    if (error.response) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response.status}: ${error.response.statusText}`);
      console.error('Error response:', JSON.stringify(error.response.data, null, 2));
      return error.response;
    }
    throw error;
  }
}

async function testAllAPIs() {
  console.log('Starting API tests...');
  
  // Test data storage
  const testData = {
    admin: null,
    owner: null,
    tenant: null,
    society: null,
    building: null,
    flat: null,
    complaint: null,
    announcement: null
  };
  
  // 1. Register admin
  const adminEmail = `admin${Date.now()}@example.com`;
  const adminRegisterResponse = await makeRequest('POST', '/auth/register', {
    name: 'Admin User',
    email: adminEmail,
    password: 'admin123',
    phone: '+1234567890',
    role: 'admin'
  });
  
  if (adminRegisterResponse.status !== 201) {
    console.error('Admin registration failed');
    return;
  }
  
  testData.admin = adminRegisterResponse.data.data;
  console.log('‚úÖ Admin registered successfully');
  
  // 2. Register owner
  const ownerEmail = `owner${Date.now()}@example.com`;
  const ownerRegisterResponse = await makeRequest('POST', '/auth/register', {
    name: 'Owner User',
    email: ownerEmail,
    password: 'owner123',
    phone: '+1234567891',
    role: 'owner'
  });
  
  if (ownerRegisterResponse.status !== 201) {
    console.error('Owner registration failed');
    return;
  }
  
  testData.owner = ownerRegisterResponse.data.data;
  console.log('‚úÖ Owner registered successfully');
  
  // 3. Register tenant
  const tenantEmail = `tenant${Date.now()}@example.com`;
  const tenantRegisterResponse = await makeRequest('POST', '/auth/register', {
    name: 'Tenant User',
    email: tenantEmail,
    password: 'tenant123',
    phone: '+1234567892',
    role: 'tenant'
  });
  
  if (tenantRegisterResponse.status !== 201) {
    console.error('Tenant registration failed');
    return;
  }
  
  testData.tenant = tenantRegisterResponse.data.data;
  console.log('‚úÖ Tenant registered successfully');
  
  // 4. Login as admin
  cookies = ''; // Clear cookies
  const adminLoginResponse = await makeRequest('POST', '/auth/login', {
    email: adminEmail,
    password: 'admin123'
  });
  
  if (adminLoginResponse.status !== 200) {
    console.error('Admin login failed');
    return;
  }
  
  console.log('‚úÖ Admin logged in successfully');
  
  // 5. Create society
  const societyData = {
    name: 'Test Society',
    registrationNumber: `REG${Date.now()}`,
    address: '123 Test Street, Test City, Test State, 123456',
    maintenancePolicy: {
      frequency: 'monthly',
      amountPerFlat: 1000
    }
  };
  
  console.log('Society data:', JSON.stringify(societyData, null, 2));
  
  const societyResponse = await makeRequest('POST', '/admin/societies', societyData);
  
  if (societyResponse.status !== 201) {
    console.error('Society creation failed');
    return;
  }
  
  testData.society = societyResponse.data.data;
  console.log('‚úÖ Society created successfully');
  
  // 6. Get admin's societies
  const societiesResponse = await makeRequest('GET', '/admin/societies/my');
  console.log('Raw societies response:', societiesResponse?.data);
  
  if (societiesResponse.status !== 200) {
    console.error('Failed to get admin societies');
  } else {
    console.log('‚úÖ Got admin societies successfully');
  }
  
  // 7. Update society
  const updateSocietyResponse = await makeRequest('PUT', `/admin/societies/${testData.society._id}`, {
    name: 'Updated Test Society',
    address: 'Updated Address, Test City, Test State, 654321',
    maintenancePolicy: 'Updated maintenance policy'
  });
  
  if (updateSocietyResponse.status !== 200) {
    console.error('Society update failed');
  } else {
    console.log('‚úÖ Society updated successfully');
  }
  
  // 8. Create building
  const buildingData = {
    society: testData.society._id, // Changed from societyId to society
    name: 'Test Building',
    totalFloors: 5,
    totalFlats: 20
  };
  
  const buildingResponse = await makeRequest('POST', '/admin/buildings', buildingData);
  
  if (buildingResponse.status !== 201) {
    console.error('Building creation failed');
    return;
  }
  
  testData.building = buildingResponse.data.data;
  console.log('‚úÖ Building created successfully');
  
  // 9. Update building
  await makeRequest('PUT', `/admin/buildings/${testData.building._id}`, {
    name: 'Updated Test Building',
    totalFloors: 6
  });
  
  // 10. Create flat
  const flatData = {
    buildingId: testData.building._id,
    floorNumber: 1,
    flatNumber: '101',
    type: '2BHK',
    areaInSqFt: 1200
  };
  
  const flatResponse = await makeRequest('POST', '/admin/flats', flatData);
  
  if (flatResponse.status !== 201) {
    console.error('Flat creation failed');
    return;
  }
  
  testData.flat = flatResponse.data.data;
  console.log('‚úÖ Flat created successfully');
  
  // 11. Assign flat owner
  await makeRequest('PATCH', `/admin/flats/${testData.flat._id}/assign-owner`, {
    ownerId: testData.owner._id
  });
  
  // 12. Get all users
  await makeRequest('GET', '/admin/users');
  
  // 13. Get user by ID
  await makeRequest('GET', `/admin/users/${testData.owner._id}`);
  
  // 14. Update user
  await makeRequest('PATCH', `/admin/users/${testData.owner._id}`, {
    name: 'Updated Owner Name'
  });
  
  // 15. Toggle user status
  await makeRequest('PATCH', `/admin/users/${testData.tenant._id}/toggle-status`);
  
  // 16. Generate rent
  await makeRequest('POST', '/admin/rent/generate', {
    flatId: testData.flat._id,
    amount: 15000,
    dueDate: new Date(Date.now() + 15 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], // 15 days from now
    description: 'Monthly rent'
  });
  
  // 17. Get rent history
  await makeRequest('GET', '/admin/rent/history');
  
  // 18. Generate maintenance
  await makeRequest('POST', '/admin/maintenance', {
    societyId: testData.society._id,
    month: new Date().getMonth() + 1,
    year: new Date().getFullYear(),
    dueDate: new Date(Date.now() + 10 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] // 10 days from now
  });
  
  // 19. Get maintenance status
  await makeRequest('GET', '/admin/maintenance/status');
  
  // 20. Login as owner
  cookies = ''; // Clear cookies
  const ownerLoginResponse = await makeRequest('POST', '/auth/login', {
    email: ownerEmail,
    password: 'owner123'
  });
  
  if (ownerLoginResponse.status !== 200) {
    console.error('Owner login failed');
    return;
  }
  
  console.log('‚úÖ Owner logged in successfully');
  
  // 21. Get owner's properties
  await makeRequest('GET', '/owner/properties');
  
  // 22. Get property details
  await makeRequest('GET', `/owner/properties/${testData.flat._id}`);
  
  // 23. Add tenant to flat
  await makeRequest('POST', `/owner/properties/${testData.flat._id}/tenant`, {
    tenantId: testData.tenant._id,
    rentAmount: 15000,
    startDate: new Date().toISOString().split('T')[0],
    endDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0] // 1 year from now
  });
  
  // 24. Get tenant details
  await makeRequest('GET', `/owner/properties/${testData.flat._id}/tenant`);
  
  // 25. Get maintenance history
  await makeRequest('GET', '/owner/maintenance/history');
  
  // 26. Pay maintenance
  const maintenanceDuesResponse = await makeRequest('GET', '/owner/maintenance/dues');
  
  if (maintenanceDuesResponse.status === 200 && maintenanceDuesResponse.data?.data?.length > 0) {
    const maintenanceId = maintenanceDuesResponse.data.data[0]._id;
    await makeRequest('POST', `/owner/maintenance/${maintenanceId}/pay`, {
      paymentMethod: 'online',
      transactionId: `TXN${Date.now()}`
    });
  }
  
  // 27. Login as tenant
  cookies = ''; // Clear cookies
  const tenantLoginResponse = await makeRequest('POST', '/auth/login', {
    email: tenantEmail,
    password: 'tenant123'
  });
  
  if (tenantLoginResponse.status !== 200) {
    console.error('Tenant login failed');
    return;
  }
  
  console.log('‚úÖ Tenant logged in successfully');
  
  // 28. Get tenant's rented property
  await makeRequest('GET', '/tenant/property');
  
  // 29. Get rent history
  await makeRequest('GET', '/tenant/rent/history');
  
  // 30. Get rent dues
  await makeRequest('GET', '/tenant/rent/dues');
  
  // 31. Pay rent
  const rentDuesResponse = await makeRequest('GET', '/tenant/rent/dues');
  
  if (rentDuesResponse.status === 200 && rentDuesResponse.data?.data?.length > 0) {
    const rentId = rentDuesResponse.data.data[0]._id;
    await makeRequest('POST', `/tenant/rent/${rentId}/pay`, {
      paymentMethod: 'online',
      transactionId: `TXN${Date.now()}`
    });
  }
  
  // 32. Create complaint
  const complaintData = {
    title: 'Test Complaint',
    description: 'This is a test complaint',
    type: 'maintenance',
    priority: 'medium'
  };
  
  const complaintResponse = await makeRequest('POST', '/complaints', complaintData);
  
  if (complaintResponse.status !== 201) {
    console.error('Complaint creation failed');
    return;
  }
  
  testData.complaint = complaintResponse.data.data;
  console.log('‚úÖ Complaint created successfully');
  
  // 33. Get tenant's complaints
  await makeRequest('GET', '/complaints/my');
  
  // 34. Get complaint details
  await makeRequest('GET', `/complaints/${testData.complaint._id}`);
  
  // 35. Login as admin to handle complaint
  cookies = ''; // Clear cookies
  await makeRequest('POST', '/auth/login', {
    email: adminEmail,
    password: 'admin123'
  });
  
  // 36. Get all complaints
  await makeRequest('GET', '/admin/complaints');
  
  // 37. Update complaint status
  await makeRequest('PATCH', `/admin/complaints/${testData.complaint._id}/status`, {
    status: 'in-progress',
    remarks: 'Working on it'
  });
  
  // 38. Resolve complaint
  await makeRequest('PATCH', `/admin/complaints/${testData.complaint._id}/status`, {
    status: 'resolved',
    remarks: 'Issue fixed'
  });
  
  // 39. Create announcement
  const announcementData = {
    title: 'Test Announcement',
    content: 'This is a test announcement',
    type: 'general',
    societyId: testData.society._id
  };
  
  const announcementResponse = await makeRequest('POST', '/announcements', announcementData);
  
  if (announcementResponse.status !== 201) {
    console.error('Announcement creation failed');
    return;
  }
  
  testData.announcement = announcementResponse.data.data;
  console.log('‚úÖ Announcement created successfully');
  
  // 40. Get all announcements
  await makeRequest('GET', '/announcements');
  
  // 41. Get announcement details
  await makeRequest('GET', `/announcements/${testData.announcement._id}`);
  
  // 42. Update announcement
  await makeRequest('PUT', `/announcements/${testData.announcement._id}`, {
    title: 'Updated Announcement',
    content: 'This announcement has been updated',
    type: 'important'
  });
  
  // 43. Delete announcement
  await makeRequest('DELETE', `/announcements/${testData.announcement._id}`);
  
  // 44. Login as owner to create ownership request
  cookies = ''; // Clear cookies
  await makeRequest('POST', '/auth/login', {
    email: ownerEmail,
    password: 'owner123'
  });
  
  // 45. Create ownership request
  const ownershipRequestData = {
    societyId: testData.society._id,
    buildingId: testData.building._id,
    flatNumber: '102', // Different from the one already assigned
    documentProof: 'https://example.com/document.pdf'
  };
  
  const ownershipRequestResponse = await makeRequest('POST', '/ownership-requests', ownershipRequestData);
  
  if (ownershipRequestResponse.status !== 201) {
    console.error('Ownership request creation failed');
    return;
  }
  
  testData.ownershipRequest = ownershipRequestResponse.data.data;
  console.log('‚úÖ Ownership request created successfully');
  
  // 46. Get owner's ownership requests
  await makeRequest('GET', '/ownership-requests/my');
  
  // 47. Login as admin to handle ownership request
  cookies = ''; // Clear cookies
  await makeRequest('POST', '/auth/login', {
    email: adminEmail,
    password: 'admin123'
  });
  
  // 48. Get all ownership requests
  await makeRequest('GET', '/admin/ownership-requests');
  
  // 49. Review ownership request
  await makeRequest('PATCH', '/admin/ownership-requests/review', {
    requestId: testData.ownershipRequest._id,
    status: 'approved',
    remarks: 'Documents verified'
  });
  
  console.log('‚úÖ All API tests completed successfully!');
}

testAllAPIs().catch(err => console.error('Test error:', err));
‚îÇ   # --- End: test-all-apis.js ---

‚îÇ   ‚îú‚îÄ test-api.js

‚îÇ   # --- Begin: test-api.js ---
const axios = require('axios');

class APITester {
  constructor(baseURL = 'http://localhost:5000') {
    this.baseURL = baseURL;
    this.authToken = null;
    this.userId = null;
    this.societyId = null;
    this.buildingId = null;
    this.flatId = null;
    this.cookies = [];
  }

  async makeRequest(method, endpoint, data = null, headers = {}) {
    try {
      const config = {
        method,
        url: `${this.baseURL}${endpoint}`,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        withCredentials: true
      };

      if (data) {
        config.data = data;
      }

      // Add cookies if available
      if (this.cookies.length > 0) {
        config.headers.Cookie = this.cookies.join('; ');
        console.log(`üç™ Using cookies: ${this.cookies.length} cookies`);
      }

      if (this.authToken) {
        config.headers.Authorization = `Bearer ${this.authToken}`;
        console.log(`üîë Using token: ${this.authToken.substring(0, 20)}...`);
      }

      const response = await axios(config);
      
      // Extract cookies from response
      if (response.headers['set-cookie']) {
        const newCookies = response.headers['set-cookie'].map(cookie => cookie.split(';')[0]);
        this.cookies = [...this.cookies, ...newCookies];
        console.log(`üç™ Received ${newCookies.length} new cookies`);
      }
      
      console.log(`‚úÖ ${method} ${endpoint} - Status: ${response.status}`);
      
      // Add a small delay to avoid rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
      
      return response.data;
    } catch (error) {
      console.error(`‚ùå ${method} ${endpoint} - Error: ${error.response?.status} - ${error.response?.data?.message || error.message}`);
      return null;
    }
  }

  async testAuthentication() {
    console.log('\nüîê Testing Authentication...');
    
    // Generate unique email to avoid conflicts
    const timestamp = Date.now();
    const testEmail = `test${timestamp}@example.com`;
    
    // Register User
    const registerData = {
      name: 'Test User',
      email: testEmail,
      password: 'password123',
      phone: '+1234567890',
      role: 'owner'
    };
    
    const registerResponse = await this.makeRequest('POST', '/api/auth/register', registerData);
    if (registerResponse) {
      console.log('‚úÖ User registered successfully');
    }

    // Login User
    const loginData = {
      email: testEmail,
      password: 'password123'
    };
    
    const loginResponse = await this.makeRequest('POST', '/api/auth/login', loginData);
    if (loginResponse && loginResponse.data && loginResponse.data._id) {
      this.userId = loginResponse.data._id;
      console.log('‚úÖ User logged in successfully');
    }

    // Get Current User
    await this.makeRequest('GET', '/api/auth/me');

    // Change Password
    const changePasswordData = {
      currentPassword: 'password123',
      newPassword: 'newpassword123'
    };
    await this.makeRequest('PATCH', '/api/auth/change-password', changePasswordData);
  }

  async testOwnerAuthentication() {
    console.log('\nüë§ Testing Owner Authentication...');
    
    // Generate unique email to avoid conflicts
    const timestamp = Date.now();
    const ownerEmail = `owner${timestamp}@example.com`;
    
    // Register Owner User
    const registerData = {
      name: 'Test Owner',
      email: ownerEmail,
      password: 'password123',
      phone: '+1234567890',
      role: 'owner'
    };
    
    await this.makeRequest('POST', '/api/auth/register', registerData);

    // Login as Owner
    const loginData = {
      email: ownerEmail,
      password: 'password123'
    };
    
    const loginResponse = await this.makeRequest('POST', '/api/auth/login', loginData);
    console.log('üîç Login response:', JSON.stringify(loginResponse, null, 2));
    if (loginResponse && loginResponse.data && loginResponse.data._id) {
      this.userId = loginResponse.data._id;
      console.log('‚úÖ Owner logged in successfully');
    } else {
      console.log('‚ùå Login failed');
    }
  }

  async testTenantAuthentication() {
    console.log('\nüë§ Testing Tenant Authentication...');
    
    // Generate unique email to avoid conflicts
    const timestamp = Date.now();
    const tenantEmail = `tenant${timestamp}@example.com`;
    
    // Register Tenant User
    const registerData = {
      name: 'Test Tenant',
      email: tenantEmail,
      password: 'password123',
      phone: '+1234567890',
      role: 'tenant'
    };
    
    await this.makeRequest('POST', '/api/auth/register', registerData);

    // Login as Tenant
    const loginData = {
      email: tenantEmail,
      password: 'password123'
    };
    
    const loginResponse = await this.makeRequest('POST', '/api/auth/login', loginData);
    if (loginResponse && loginResponse.data && loginResponse.data._id) {
      this.userId = loginResponse.data._id;
      console.log('‚úÖ Tenant logged in successfully');
    }
  }

  async testAdminRoutes() {
    console.log('\nüë®‚Äçüíº Testing Admin Routes...');

    // First, create and login as admin user
    const adminTimestamp = Date.now();
    const adminEmail = `admin${adminTimestamp}@example.com`;
    
    // Register Admin User
    const adminRegisterData = {
      name: 'Admin User',
      email: adminEmail,
      password: 'admin123',
      phone: '+1234567890',
      role: 'admin'
    };
    
    await this.makeRequest('POST', '/api/auth/register', adminRegisterData);

    // Login as Admin
    const adminLoginData = {
      email: adminEmail,
      password: 'admin123'
    };
    
    const adminLoginResponse = await this.makeRequest('POST', '/api/auth/login', adminLoginData);
    if (adminLoginResponse && adminLoginResponse.data && adminLoginResponse.data._id) {
      this.userId = adminLoginResponse.data._id;
      console.log('‚úÖ Admin logged in successfully');
    }

    // === SOCIETY MANAGEMENT ===
    const societyData = {
      name: 'Test Society',
      address: '123 Test Street',
      city: 'Test City',
      state: 'Test State',
      pincode: '123456',
      contactPerson: 'Admin User',
      contactPhone: '+1234567890',
      contactEmail: 'admin@testsociety.com'
    };
    
    const societyResponse = await this.makeRequest('POST', '/api/admin/societies', societyData);
    if (societyResponse && societyResponse._id) {
      this.societyId = societyResponse._id;
      console.log('‚úÖ Society created successfully');
    }

    await this.makeRequest('GET', '/api/admin/societies/my?page=1&limit=10');
    await this.makeRequest('PUT', `/api/admin/societies/${this.societyId}`, { name: 'Updated Society' });
    // await this.makeRequest('DELETE', `/api/admin/societies/${this.societyId}`); // Commented to avoid deletion

    // === BUILDING MANAGEMENT ===
    if (this.societyId) {
      const buildingData = {
        societyId: this.societyId,
        name: 'Building A',
        floors: 5,
        address: 'Building A Address'
      };
      
      const buildingResponse = await this.makeRequest('POST', '/api/admin/buildings', buildingData);
      if (buildingResponse && buildingResponse._id) {
        this.buildingId = buildingResponse._id;
        console.log('‚úÖ Building created successfully');
      }

      await this.makeRequest('PUT', `/api/admin/buildings/${this.buildingId}`, { name: 'Updated Building' });
      // await this.makeRequest('DELETE', `/api/admin/buildings/${this.buildingId}`); // Commented to avoid deletion
    }

    // === FLAT MANAGEMENT ===
    if (this.buildingId) {
      const flatsData = {
        buildingId: this.buildingId,
        flats: [
          {
            flatNumber: 'A101',
            floor: 1,
            type: '2BHK',
            area: 1200,
            rent: 15000
          },
          {
            flatNumber: 'A102',
            floor: 1,
            type: '3BHK',
            area: 1500,
            rent: 20000
          }
        ]
      };
      
      const flatsResponse = await this.makeRequest('POST', '/api/admin/flats', flatsData);
      if (flatsResponse && flatsResponse.length > 0) {
        this.flatId = flatsResponse[0]._id;
        console.log('‚úÖ Flats created successfully');
      }

      // Test flat assignment operations
      await this.makeRequest('PATCH', `/api/admin/flats/${this.flatId}/assign-owner`, { ownerId: this.userId });
      // await this.makeRequest('PATCH', `/api/admin/flats/${this.flatId}/remove-owner`, {});
      // await this.makeRequest('PATCH', `/api/admin/flats/${this.flatId}/remove-tenant`, {});
    }

    // === USER MANAGEMENT ===
    await this.makeRequest('GET', '/api/admin/users?page=1&limit=10');
    await this.makeRequest('GET', `/api/admin/users/${this.userId}`);
    await this.makeRequest('PATCH', `/api/admin/users/${this.userId}`, { name: 'Updated User' });
    await this.makeRequest('PATCH', `/api/admin/users/${this.userId}/toggle-status`, {});

    // === RENT MANAGEMENT ===
    if (this.societyId) {
      const rentData = {
        month: 12,
        year: 2024,
        societyId: this.societyId
      };
      await this.makeRequest('POST', '/api/admin/rent/generate', rentData);
    }
    await this.makeRequest('GET', '/api/admin/rent/history?page=1&limit=10');

    // === MAINTENANCE ===
    if (this.societyId) {
      await this.makeRequest('POST', '/api/admin/maintenance', { societyId: this.societyId });
    }
    await this.makeRequest('GET', '/api/admin/maintenance/status?page=1&limit=10');

    // === OWNERSHIP REQUESTS ===
    await this.makeRequest('GET', '/api/admin/ownership-requests?page=1&limit=10');
    // await this.makeRequest('PATCH', '/api/admin/ownership-requests/review', { requestId: 'test', status: 'approved' });

    // === DASHBOARD & DOCUMENTS ===
    await this.makeRequest('GET', '/api/admin/dashboard/overview');
    if (this.flatId) {
      await this.makeRequest('GET', `/api/admin/flats/${this.flatId}/info`);
    }

    // === NOTES & REMINDERS ===
    if (this.societyId) {
      await this.makeRequest('PATCH', `/api/admin/societies/${this.societyId}/note`, { note: 'Test note' });
    }
    await this.makeRequest('POST', `/api/admin/users/${this.userId}/reminder`, { message: 'Test reminder' });
  }

  async testOwnerRoutes() {
    console.log('\nüè† Testing Owner Routes...');

    // === DASHBOARD & PROFILE ===
    await this.makeRequest('GET', '/api/owner/dashboard/overview');
    await this.makeRequest('PATCH', '/api/owner/profile', { name: 'Updated Owner Name' });

    // === FLAT MANAGEMENT ===
    await this.makeRequest('GET', '/api/owner/flats?page=1&limit=10');
    if (this.flatId) {
      await this.makeRequest('GET', `/api/owner/flats/${this.flatId}/society`);
    }

    // === RENT & MAINTENANCE ===
    await this.makeRequest('GET', '/api/owner/rent-history?page=1&limit=10');
    await this.makeRequest('GET', '/api/owner/maintenance-due?page=1&limit=10');
    // await this.makeRequest('PATCH', '/api/owner/maintenance/:maintenanceId/pay', { amount: 1000 });
  }

  async testTenantRoutes() {
    console.log('\nüè† Testing Tenant Routes...');

    // === DASHBOARD & PROFILE ===
    await this.makeRequest('GET', '/api/tenant/dashboard/overview');
    await this.makeRequest('PATCH', '/api/tenant/profile', { name: 'Updated Tenant Name' });

    // === FLAT & RENT MANAGEMENT ===
    await this.makeRequest('GET', '/api/tenant/my-flat');
    await this.makeRequest('GET', '/api/tenant/rent-history?page=1&limit=10');
    // await this.makeRequest('PATCH', '/api/tenant/rent/:rentId/pay', { amount: 15000 });
    await this.makeRequest('GET', '/api/tenant/rent-due');

    // === MAINTENANCE ===
    await this.makeRequest('GET', '/api/tenant/maintenance-due?page=1&limit=10');
    // await this.makeRequest('PATCH', '/api/tenant/maintenance/:maintenanceId/pay', { amount: 500 });

    // === ANNOUNCEMENTS ===
    await this.makeRequest('GET', '/api/tenant/announcements');
  }

  async testComplaints() {
    console.log('\nüìù Testing Complaints...');

    // === USER COMPLAINTS ===
    if (this.flatId) {
      const complaintData = {
        title: 'Water Issue',
        description: 'No water supply in flat A101',
        category: 'maintenance',
        priority: 'high',
        flatId: this.flatId
      };
      
      const complaintResponse = await this.makeRequest('POST', '/api/complaints', complaintData);
      if (complaintResponse && complaintResponse._id) {
        this.complaintId = complaintResponse._id;
        console.log('‚úÖ Complaint created successfully');
      }
    }

    await this.makeRequest('GET', '/api/complaints/my?page=1&limit=10');

    // === ADMIN COMPLAINT MANAGEMENT ===
    await this.makeRequest('GET', '/api/complaints?page=1&limit=10');
    if (this.complaintId) {
      const updateData = {
        status: 'in-progress',
        adminResponse: 'Working on the issue'
      };
      await this.makeRequest('PATCH', `/api/complaints/${this.complaintId}`, updateData);
    }
  }

  async testAnnouncements() {
    console.log('\nüì¢ Testing Announcements...');

    // === ADMIN ANNOUNCEMENT MANAGEMENT ===
    if (this.societyId) {
      const announcementData = {
        title: 'Society Meeting',
        content: 'Monthly society meeting on Sunday',
        category: 'general',
        priority: 'medium',
        societyId: this.societyId
      };
      
      const announcementResponse = await this.makeRequest('POST', '/api/announcements', announcementData);
      if (announcementResponse && announcementResponse._id) {
        this.announcementId = announcementResponse._id;
        console.log('‚úÖ Announcement created successfully');
      }
    }

    await this.makeRequest('GET', '/api/announcements?page=1&limit=10');
    
    if (this.announcementId) {
      await this.makeRequest('PUT', `/api/announcements/${this.announcementId}`, { title: 'Updated Meeting' });
      // await this.makeRequest('DELETE', `/api/announcements/${this.announcementId}`); // Commented to avoid deletion
    }

    // === USER ANNOUNCEMENTS ===
    await this.makeRequest('GET', '/api/announcements/relevant');
  }

  async testOwnershipRequests() {
    console.log('\nüìã Testing Ownership Requests...');

    // === USER OWNERSHIP REQUESTS ===
    if (this.flatId) {
      const requestData = {
        flatId: this.flatId,
        reason: 'Want to purchase this flat',
        documents: ['aadhar.pdf', 'pan.pdf']
      };
      
      const requestResponse = await this.makeRequest('POST', '/api/owner/ownership-requests', requestData);
      if (requestResponse && requestResponse._id) {
        this.ownershipRequestId = requestResponse._id;
        console.log('‚úÖ Ownership request created successfully');
      }
    }

    await this.makeRequest('GET', '/api/owner/ownership-requests/my');

    // === ADMIN OWNERSHIP REQUEST MANAGEMENT ===
    await this.makeRequest('GET', '/api/ownership-requests?page=1&limit=10');
    if (this.ownershipRequestId) {
      await this.makeRequest('PATCH', `/api/ownership-requests/${this.ownershipRequestId}`, { status: 'approved' });
    }
  }

  async runAllTests() {
    console.log('üöÄ Starting API Tests...\n');
    
    try {
      await this.testAuthentication();
      await this.testAdminRoutes();
      
      // Test owner routes with owner authentication
      await this.testOwnerAuthentication();
      await this.testOwnerRoutes();
      
      // Test tenant routes with tenant authentication
      await this.testTenantAuthentication();
      await this.testTenantRoutes();
      
      // Test complaints with owner authentication
      await this.testOwnerAuthentication();
      await this.testComplaints();
      
      // Test announcements with owner authentication
      await this.testOwnerAuthentication();
      await this.testAnnouncements();
      
      // Test ownership requests with owner authentication
      await this.testOwnerAuthentication();
      await this.testOwnershipRequests();
      
      console.log('\n‚úÖ All tests completed!');
    } catch (error) {
      console.error('‚ùå Test execution failed:', error.message);
    }
  }
}

// Run tests if this file is executed directly
if (require.main === module) {
  const tester = new APITester();
  tester.runAllTests();
}

module.exports = APITester; 
‚îÇ   # --- End: test-api.js ---

‚îÇ   ‚îú‚îÄ test-society-creation.js

‚îÇ   # --- Begin: test-society-creation.js ---
const axios = require('axios');

const API_URL = 'http://localhost:5000/api';
let cookies = '';

async function makeRequest(method, endpoint, data = null) {
  try {
    const response = await axios({
      method,
      url: `${API_URL}${endpoint}`,
      data,
      headers: {
        'Content-Type': 'application/json',
        Cookie: cookies
      },
      withCredentials: true
    });
    
    // Save cookies for subsequent requests
    if (response.headers['set-cookie']) {
      cookies = response.headers['set-cookie'].join('; ');
    }
    
    return response;
  } catch (error) {
    if (error.response) {
      console.error(`Error ${error.response.status}: ${error.response.statusText}`);
      console.error('Error response:', JSON.stringify(error.response.data, null, 2));
      return error.response;
    }
    throw error;
  }
}

async function testSocietyCreation() {
  console.log('Starting society creation test...');
  
  // 1. Register admin
  const adminEmail = `admin${Date.now()}@example.com`;
  const adminRegisterResponse = await makeRequest('POST', '/auth/register', {
    name: 'Admin User',
    email: adminEmail,
    password: 'admin123',
    phone: '+1234567890',
    role: 'admin'
  });
  
  if (adminRegisterResponse.status !== 201) {
    console.error('Admin registration failed');
    return;
  }
  
  console.log('‚úÖ Admin registered successfully');
  
  // 2. Login as admin
  const adminLoginResponse = await makeRequest('POST', '/auth/login', {
    email: adminEmail,
    password: 'admin123'
  });
  
  if (adminLoginResponse.status !== 200) {
    console.error('Admin login failed');
    return;
  }
  
  console.log('‚úÖ Admin logged in successfully');
  
  // 3. Create society
  const societyData = {
    name: 'Test Society',
    registrationNumber: `REG${Date.now()}`,
    address: '123 Test Street, Test City, Test State, 123456',
    maintenancePolicy: 'Monthly maintenance of 1000 per flat'
  };
  
  console.log('Society data:', JSON.stringify(societyData, null, 2));
  
  const societyResponse = await makeRequest('POST', '/admin/societies', societyData);
  
  console.log('Society creation response:', JSON.stringify(societyResponse.data, null, 2));
  
  if (societyResponse.status === 201) {
    console.log('‚úÖ Society created successfully');
  } else {
    console.error('‚ùå Society creation failed');
  }
}

testSocietyCreation().catch(err => console.error('Test error:', err));
‚îÇ   # --- End: test-society-creation.js ---

‚îÇ   ‚îú‚îÄ server/
‚îÇ   ‚îÇ   ‚îú‚îÄ .env

‚îÇ   ‚îÇ   # --- Begin: .env ---
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=your_access_token_secret
JWT_REFRESH_SECRET=your_refresh_token_secret

# Server config
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:5173
#In production, set CLIENT_URL in .env to your deployed frontend domain

# MongoDB
MONGO_URI=mongodb+srv://srgcode:sushantno111@cluster0.akpgore.mongodb.net/

# JWT
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password

# Cookies
COOKIE_EXPIRE=7

# For production, override values as needed

‚îÇ   ‚îÇ   # --- End: .env ---

‚îÇ   ‚îÇ   ‚îú‚îÄ .env.example

‚îÇ   ‚îÇ   # --- Begin: .env.example ---
PORT=5000
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password
CLIENT_URL=http://localhost:3000
NODE_ENV=development
COOKIE_EXPIRE=7

‚îÇ   ‚îÇ   # --- End: .env.example ---

‚îÇ   ‚îÇ   ‚îú‚îÄ .gitignore

‚îÇ   ‚îÇ   # --- Begin: .gitignore ---
# Node.js
node_modules/
.env
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Logs
logs
*.log
pids
*.pid
*.seed
*.pid.lock

# OS
.DS_Store
Thumbs.db

# IDEs
.vscode/
.idea/

# Build output
dist/
build/

# Optional npm cache
.npm/
.cache/

tesh.py
project.txt
‚îÇ   ‚îÇ   # --- End: .gitignore ---

‚îÇ   ‚îÇ   ‚îú‚îÄ package.json

‚îÇ   ‚îÇ   # --- Begin: package.json ---
{
  "name": "housing-rent-management",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "test:api": "node ../test-api.js",
    "test:quick": "bash ../quick-test.sh",
    "test:api-quick": "node ../quick-api-test.js",
    "test:dev": "nodemon server.js",
    "start": "node server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "build": "^0.1.4",
    "compression": "^1.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.14.0",
    "morgan": "^1.10.0",
    "nodemailer": "^7.0.3",
    "xss": "^1.0.15"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

‚îÇ   ‚îÇ   # --- End: package.json ---

‚îÇ   ‚îÇ   ‚îú‚îÄ server.js

‚îÇ   ‚îÇ   # --- Begin: server.js ---
// ‚úÖ PATCHED: server.js with all routes
const express = require('express');
const dotenv = require('dotenv');
const cookieParser = require('cookie-parser');
const cors = require('cors');

const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitizeMiddleware = require('./middleware/mongoSanitizeMiddleware');
const xssMiddleware = require('./middleware/xssMiddleware');
const compression = require('compression');
const validateEnv = require('./utils/validateEnv');
const { morganLogger, logger } = require('./utils/logger');
const connectDB = require('./config/db');
const errorHandler = require('./middleware/errorHandler');

// Route Imports
const authRoutes = require('./routes/authRoutes');
const adminRoutes = require('./routes/adminRoutes');
const ownerRoutes = require('./routes/ownerRoutes');
const tenantRoutes = require('./routes/tenantRoutes');
const complaintRoutes = require('./routes/complaintRoutes');
const announcementRoutes = require('./routes/announcementRoutes');
const ownershipRequestRoutes = require('./routes/ownershipRequestRoutes');

dotenv.config();
validateEnv(); // Validate environment variables
connectDB();

const app = express();

app.use(cors({
  origin: 'http://localhost:5173',
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
}));

// === Global Middleware ===
app.use(helmet());
app.use(mongoSanitizeMiddleware); // ‚úÖ FIXED: Using custom MongoDB sanitization
app.use(xssMiddleware); // ‚úÖ FIXED: Using custom XSS middleware
app.use(compression());
app.use(morganLogger); // ‚úÖ Updated to use morganLogger
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 1000, // Increased for testing
  message: 'Too many requests from this IP, try again later.'
}));

app.use(express.json());
app.use(cookieParser());

// === Routes ===
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/owner', ownerRoutes);
app.use('/api/tenant', tenantRoutes);
app.use('/api/complaints', complaintRoutes);
app.use('/api/announcements', announcementRoutes);
app.use('/api/ownership-requests', ownershipRequestRoutes); // ‚úÖ Added

// Default Route
app.get('/', (req, res) => {
  res.send('Housing Society & Rent Management System API is running');
});

// API Documentation Route
app.get('/api', (req, res) => {
  res.json({
    success: true,
    message: 'Housing Society Management API',
    version: '1.0.0',
    endpoints: {
      auth: '/api/auth',
      admin: '/api/admin',
      owner: '/api/owner',
      tenant: '/api/tenant',
      complaints: '/api/complaints',
      announcements: '/api/announcements',
      ownershipRequests: '/api/ownership-requests'
    },
    documentation: 'API endpoints are protected and require authentication'
  });
});

// Add this at the very end, after all other app.use and route definitions
app.use((req, res, next) => {
  res.status(404).json({
    success: false,
    message: 'API endpoint not found',
    data: null,
    statusCode: 404
  });
});

// Error Handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  logger.info(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
  logger.info(`üåê Local URL: http://localhost:${PORT}`);
  logger.info(`üìö API Documentation: http://localhost:${PORT}/api`);
});
‚îÇ   ‚îÇ   # --- End: server.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ config/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ constant.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: constant.js ---
// config/constants.js
module.exports = {
    ROLES: ['admin', 'owner', 'tenant'],
    COMPLAINT_CATEGORIES: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    MAINTENANCE_FREQUENCIES: ['monthly', 'quarterly'],
    PAYMENT_MODES: ['cash', 'online', 'bank-transfer', 'upi'],
  };
  
‚îÇ   ‚îÇ   ‚îÇ   # --- End: constant.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ db.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: db.js ---
// config/db.js

const mongoose = require('mongoose');
const { logger } = require('../utils/logger');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      // These options are for Mongoose >= 6
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    logger.info(`MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    logger.error(`MongoDB Connection Error: ${error.message}`, error);
    process.exit(1); // Stop the app if DB connection fails
  }
};

module.exports = connectDB;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: db.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ mailer.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: mailer.js ---
// config/mailer.js
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

module.exports = transporter;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: mailer.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ controllers/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ adminController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: adminController.js ---
const Society = require('../models/Society');
const Building = require('../models/Building');
const Flat = require('../models/Flat');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const OwnershipRequest = require('../models/OwnershipRequest');
const Complaint = require('../models/Complaint');
const Rent = require('../models/Rent');
const sendEmail = require('../utils/sendEmail');
const formatResponse = require('../utils/responseFormatter');
const { updateComplaintStatus, getAllComplaints } = require('../services/complaintService');
const DashboardService = require('../services/dashboardService');
const SocietyService = require('../services/societyService');
const BuildingService = require('../services/buildingService');
const FlatService = require('../services/flatService');
const UserService = require('../services/userService');
const RentService = require('../services/rentService');
const MaintenanceService = require('../services/maintenanceService'); // ‚úÖ ADDED: Import MaintenanceService

// === SOCIETIES ===

exports.createSociety = async (req, res, next) => {
  try {
    const society = await SocietyService.createSociety(req.body, req.user._id);

    res.status(201).json(formatResponse({
      message: 'Society created successfully',
      data: society
    }));
  } catch (err) {
    next(err);
  }
};

exports.getMySocieties = async (req, res, next) => {
  console.log('DEBUG getMySocieties called, req.user:', req.user);
  if (!req.user || !req.user._id) {
    console.error('ERROR: req.user or req.user._id is missing');
    return res.status(401).json({ success: false, message: 'Unauthorized: User not found', data: null, statusCode: 401 });
  }
  try {
    const result = await SocietyService.getSocietiesByAdmin(req.user._id, req.pagination);
    console.log('DEBUG getMySocieties result:', result);
    if (!result || typeof result !== 'object' || !Array.isArray(result.societies)) {
      console.error('ERROR: Invalid result from getSocietiesByAdmin:', result);
      return res.status(500).json({ success: false, message: 'Internal error: Invalid societies result', data: null, statusCode: 500 });
    }
    res.json(formatResponse({
      message: 'Societies retrieved successfully',
      data: result.societies,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        pages: result.pages
      }
    }));
  } catch (err) {
    console.error('ERROR in getMySocieties:', err);
    return res.status(500).json({ success: false, message: err.message || 'Internal server error', data: null, statusCode: 500 });
  }
};

// ‚úÖ FIXED: Standardize parameter names to use 'id'
exports.updateSociety = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from societyId to id
    const updateData = req.body;
    const society = await SocietyService.updateSociety(id, updateData);
    res.json(formatResponse({ message: 'Society updated successfully', data: society }));
  } catch (err) {
    next(err);
  }
};

exports.deleteSociety = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from societyId to id
    await SocietyService.deleteSociety(id);
    res.json(formatResponse({ message: 'Society deleted successfully' }));
  } catch (err) {
    next(err);
  }
};

// === BUILDINGS ===

exports.createBuilding = async (req, res, next) => {
  try {
    const building = await BuildingService.createBuilding(req.body);

    res.status(201).json(formatResponse({
      message: 'Building created successfully',
      data: building
    }));
  } catch (err) {
    next(err);
  }
};

// ‚úÖ FIXED: Standardize parameter names to use 'id'
exports.updateBuilding = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from buildingId to id
    const updateData = req.body;
    const building = await BuildingService.updateBuilding(id, updateData);
    res.json(formatResponse({ message: 'Building updated successfully', data: building }));
  } catch (err) {
    next(err);
  }
};

exports.deleteBuilding = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from buildingId to id
    await BuildingService.deleteBuilding(id);
    res.json(formatResponse({ message: 'Building deleted successfully' }));
  } catch (err) {
    next(err);
  }
};

// === FLAT MANAGEMENT ===

exports.createFlats = async (req, res, next) => {
  try {
    const { buildingId, totalFlats } = req.body;
    const createdFlats = await FlatService.createFlatsForBuilding(buildingId, totalFlats, req.user._id);

    res.status(201).json(formatResponse({
      message: `${createdFlats.length} flats created successfully`,
      data: { count: createdFlats.length, building: buildingId }
    }));
  } catch (err) {
    next(err);
  }
};

exports.assignFlatOwner = async (req, res, next) => {
  try {
    const { ownerId } = req.body;
    const flat = await FlatService.assignOwnerToFlat(req.params.flatId, ownerId);

    res.json(formatResponse({
      message: 'Owner assigned successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatOwner = async (req, res, next) => {
  try {
    const flat = await FlatService.removeOwnerFromFlat(req.params.flatId);

    res.json(formatResponse({
      message: 'Owner removed successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatTenant = async (req, res, next) => {
  try {
    const flat = await FlatService.removeTenantFromFlat(req.params.flatId, req.user._id);

    res.json(formatResponse({
      message: 'Tenant removed successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

// === USER MANAGEMENT ===

exports.getAllUsers = async (req, res, next) => {
  try {
    const filters = {
      role: req.query.role,
      isActive: req.query.isActive !== undefined ? req.query.isActive === 'true' : undefined,
      society: req.query.society
    };

    const result = await UserService.getAllUsers(filters, req.pagination);

    res.json(formatResponse({
      message: 'Users retrieved successfully',
      data: result.users,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        pages: result.pages
      }
    }));
  } catch (err) {
    next(err);
  }
};

exports.getUserById = async (req, res, next) => {
  try {
    const user = await UserService.getUserById(req.params.userId);

    res.json(formatResponse({
      message: 'User details retrieved successfully',
      data: user
    }));
  } catch (err) {
    next(err);
  }
};

// ‚úÖ FIXED: Standardize parameter names to use 'id'
exports.updateUser = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from userId to id
    const updateData = req.body;
    const user = await UserService.updateUser(id, updateData);
    res.json(formatResponse({ message: 'User updated successfully', data: user }));
  } catch (err) {
    next(err);
  }
};

exports.toggleUserStatus = async (req, res, next) => {
  try {
    const user = await UserService.toggleUserStatus(req.params.userId);

    res.json(formatResponse({
      message: `User ${user.isActive ? 'activated' : 'deactivated'} successfully`,
      data: user
    }));
  } catch (err) {
    next(err);
  }
};

// === RENT MANAGEMENT ===

exports.generateRent = async (req, res, next) => {
  try {
    const { billingMonth, societyId } = req.body;
    const result = await RentService.generateRentForMonth(billingMonth, societyId);

    res.status(201).json(formatResponse({
      message: result.message,
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

exports.getRentHistory = async (req, res, next) => {
  try {
    const filters = {
      status: req.query.status,
      society: req.query.society,
      flat: req.query.flat,
      tenant: req.query.tenant,
      owner: req.query.owner
    };

    const result = await RentService.getRentHistory(filters, req.pagination);

    res.json(formatResponse({
      message: 'Rent history retrieved successfully',
      data: result.rents,
      pagination: {
        total: result.total,
        page: result.page,
        limit: result.limit,
        pages: result.pages
      }
    }));
  } catch (err) {
    next(err);
  }
};

// === MAINTENANCE ===

// ‚úÖ FIXED: Use MaintenanceService instead of controller logic
exports.generateMaintenance = async (req, res, next) => {
  try {
    const { societyId, billingMonth } = req.body;
    const records = await MaintenanceService.generateMaintenanceForMonth(societyId, billingMonth, req.user._id);
    res.status(201).json(formatResponse({ 
      message: 'Maintenance generated successfully', 
      data: records 
    }));
  } catch (err) {
    next(err);
  }
};

exports.getMaintenanceStatus = async (req, res, next) => {
  try {
    const { societyId, billingMonth } = req.query;
    const maintenance = await MaintenanceService.getMaintenanceStatus(societyId, billingMonth);
    res.json(formatResponse({ 
      message: 'Maintenance status retrieved', 
      data: maintenance 
    }));
  } catch (err) {
    next(err);
  }
};

// === OWNERSHIP REQUESTS ===

exports.getOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ status: 'pending' }).populate('flat currentOwner');
    res.json(formatResponse({ message: 'Ownership requests fetched', data: requests }));
  } catch (err) {
    next(err);
  }
};

const { reviewOwnershipRequest } = require('../services/ownershipService');

exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;
    const result = await reviewOwnershipRequest({
      requestId,
      status,
      note,
      reviewerId: req.user._id
    });

    res.json(formatResponse({
      message: 'Request reviewed',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// === COMPLAINTS ===

exports.getComplaints = async (req, res, next) => {
  try {
    const complaints = await getAllComplaints();
    res.json(formatResponse({
      message: 'All complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};

// ‚úÖ FIXED: Standardize parameter names to use 'id'
exports.updateComplaintStatus = async (req, res, next) => {
  try {
    const { id } = req.params; // ‚úÖ CHANGED: from complaintId to id
    const { status, adminNote } = req.body;
    const complaint = await ComplaintService.updateComplaintStatus(id, status, adminNote, req.user._id);
    res.json(formatResponse({ message: 'Complaint status updated', data: complaint }));
  } catch (err) {
    next(err);
  }
};

// === DASHBOARD ===

exports.getAdminDashboard = async (req, res, next) => {
  try {
    const dashboardData = await DashboardService.getAdminDashboard(req.user._id);

    res.json(formatResponse({
      message: 'Admin dashboard data retrieved successfully',
      data: dashboardData
    }));
  } catch (err) {
    next(err);
  }
};

// === NOTES & REMINDERS ===

exports.addSocietyNote = async (req, res, next) => {
  try {
    const { note } = req.body;
    const society = await SocietyService.addSocietyNote(req.params.societyId, note, req.user._id);

    res.json(formatResponse({
      message: 'Note added to society successfully',
      data: society
    }));
  } catch (err) {
    next(err);
  }
};

exports.sendReminderToUser = async (req, res, next) => {
  try {
    const { userId, subject, message } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json(formatResponse({ success: false, message: 'User not found', statusCode: 404 }));

    const emailResult = await sendEmail(user.email, subject, message);
    
    if (!emailResult.success) {
      return res.status(500).json(formatResponse({ 
        success: false, 
        message: 'Failed to send email', 
        error: emailResult.error || emailResult.message,
        statusCode: 500 
      }));
    }

    res.json(formatResponse({ 
      message: 'Reminder sent successfully',
      data: { messageId: emailResult.messageId }
    }));
  } catch (err) {
    next(err);
  }
};

// Get full flat info (owner, tenant, society, building)
exports.getFlatInfo = async (req, res, next) => {
  try {
    const flat = await FlatService.getFlatById(req.params.flatId);

    res.json(formatResponse({
      message: 'Flat details retrieved successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};


‚îÇ   ‚îÇ   ‚îÇ   # --- End: adminController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ announcementController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: announcementController.js ---
const Announcement = require('../models/Announcement');
const Flat = require('../models/Flat');
const Society = require('../models/Society');
const formatResponse = require('../utils/responseFormatter');

// Create a new announcement (Admin only)
exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, content, societyId, priority = 'medium' } = req.body;

    const society = await Society.findById(societyId);
    if (!society) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Society not found',
        statusCode: 404
      }));
    }

    const announcement = await Announcement.create({
      title,
      content,
      society: societyId,
      priority,
      createdBy: req.user._id,
    });

    res.status(201).json(formatResponse({
      message: 'Announcement created successfully',
      data: announcement
    }));
  } catch (err) {
    next(err);
  }
};

// Get all announcements (Admin only)
exports.getAllAnnouncements = async (req, res, next) => {
  try {
    const { page, limit, skip } = req.pagination || { page: 1, limit: 10, skip: 0 };
    const { society, priority } = req.query;

    const filter = {};
    if (society) filter.society = society;
    if (priority) filter.priority = priority;

    const [announcements, total] = await Promise.all([
      Announcement.find(filter)
        .populate('createdBy', 'name email')
        .populate('society', 'name')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Announcement.countDocuments(filter)
    ]);

    res.json(formatResponse({
      message: 'Announcements retrieved successfully',
      data: announcements,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};

// Get relevant announcements for the logged-in user (Owner/Tenant)
exports.getRelevantAnnouncements = async (req, res, next) => {
  try {
    const { priority, page = 1, limit = 10 } = req.query;
    
    const flat = await Flat.findOne({
      $or: [
        { owner: req.user._id },
        { tenant: req.user._id }
      ]
    });

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const filter = { society: flat.society };
    if (priority) filter.priority = priority;

    const skip = (page - 1) * limit;
    const [announcements, total] = await Promise.all([
      Announcement.find(filter)
        .populate('society', 'name')
        .populate('createdBy', 'name')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit)),
      Announcement.countDocuments(filter)
    ]);

    res.json(formatResponse({
      message: 'Relevant announcements retrieved successfully',
      data: announcements,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};

// Update announcement (Admin only)
exports.updateAnnouncement = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updateData = req.body;

    const announcement = await Announcement.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    );

    if (!announcement) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Announcement not found',
        statusCode: 404
      }));
    }

    res.json(formatResponse({
      message: 'Announcement updated successfully',
      data: announcement
    }));
  } catch (err) {
    next(err);
  }
};

// Delete announcement (Admin only)
exports.deleteAnnouncement = async (req, res, next) => {
  try {
    const { id } = req.params;

    const announcement = await Announcement.findByIdAndDelete(id);
    
    if (!announcement) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Announcement not found',
        statusCode: 404
      }));
    }

    res.json(formatResponse({
      message: 'Announcement deleted successfully'
    }));
  } catch (err) {
    next(err);
  }
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: announcementController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ authController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: authController.js ---
// controllers/authController.js

const {
  loginUser,
  registerUser,
  generateTokenCookie,
  changePassword,
  validateToken
} = require('../services/authService');

const formatResponse = require('../utils/responseFormatter');
const User = require('../models/User');

// 1. Register a new user
exports.registerUser = async (req, res, next) => {
  try {
    const { name, email, password, phone, role } = req.body;
    const user = await registerUser({ name, email, password, phone, role });

    generateTokenCookie(res, user._id);

    res.status(201).json(formatResponse({
      message: 'User registered successfully',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 2. Login a user
exports.loginUser = async (req, res, next) => {
  try {
    const { email, password } = req.body;
    const user = await loginUser({ email, password });

    generateTokenCookie(res, user._id);

    res.status(200).json(formatResponse({
      message: 'Login successful',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Logout user
exports.logoutUser = async (req, res, next) => {
  try {
    res.cookie('token', '', {
      httpOnly: true,
      expires: new Date(0)
    });

    res.status(200).json(formatResponse({
      message: 'Logged out successfully'
    }));
  } catch (err) {
    next(err);
  }
};

// 4. Get current logged-in user
exports.getMe = async (req, res, next) => {
  try {
    const user = await User.findById(req.user._id).select('-password');

    if (!user) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'User not found',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        role: user.role,
        society: user.society || null
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 5. Change user password
exports.changePassword = async (req, res, next) => {
  try {
    const { currentPassword, newPassword } = req.body;

    await changePassword({
      userId: req.user._id,
      currentPassword,
      newPassword
    });

    res.status(200).json(formatResponse({
      message: 'Password updated successfully'
    }));
  } catch (err) {
    next(err);
  }
};

// 6. Validate token status

‚îÇ   ‚îÇ   ‚îÇ   # --- End: authController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ complaintController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: complaintController.js ---
// controllers/complaintController.js

const Complaint = require('../models/Complaint');
const Flat = require('../models/Flat');
const formatResponse = require('../utils/responseFormatter');
const { createComplaint: createComplaintService, updateComplaintStatus: updateComplaintStatusService, getAllComplaints: getAllComplaintsService } = require('../services/complaintService');

// Create a new complaint (Owner or Tenant)
exports.createComplaint = async (req, res, next) => {
  try {
    const { category, subject, description, flatId } = req.body;
    
    // If flatId is provided, validate it belongs to the user
    let flat = null;
    if (flatId) {
      flat = await Flat.findOne({
        _id: flatId,
        $or: [
          { owner: req.user._id },
          { tenant: req.user._id }
        ]
      });
      
      if (!flat) {
        return res.status(403).json(formatResponse({
          success: false,
          message: 'Flat not found or you do not have access to it',
          statusCode: 403
        }));
      }
    } else {
      // If no flatId provided, find the user's flat
      flat = await Flat.findOne({
        $or: [
          { owner: req.user._id },
          { tenant: req.user._id }
        ]
      });
      
      if (!flat) {
        return res.status(404).json(formatResponse({
          success: false,
          message: 'No flat assigned to you',
          statusCode: 404
        }));
      }
    }

    const complaint = await createComplaintService({
      raisedBy: req.user._id,
      userRole: req.user.role,
      flatId: flat._id,
      category,
      subject,
      description
    });

    res.status(201).json(formatResponse({
      message: 'Complaint submitted successfully',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// Get complaints filed by the logged-in user
exports.getMyComplaints = async (req, res, next) => {
  try {
    const { page, limit, skip } = req.pagination || { page: 1, limit: 10, skip: 0 };
    const { status, category } = req.query;

    const filter = { raisedBy: req.user._id };
    if (status) filter.status = status;
    if (category) filter.category = category;

    const [complaints, total] = await Promise.all([
      Complaint.find(filter)
        .populate('flat', 'flatNumber')
        .populate('building', 'name')
        .populate('society', 'name')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Complaint.countDocuments(filter)
    ]);

    res.json(formatResponse({
      message: 'Complaints retrieved successfully',
      data: complaints,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};

// Get all complaints (Admin only)
exports.getAllComplaints = async (req, res, next) => {
  try {
    const { page, limit, skip } = req.pagination || { page: 1, limit: 10, skip: 0 };
    const { status, society, category } = req.query;

    const filter = {};
    if (status) filter.status = status;
    if (society) filter.society = society;
    if (category) filter.category = category;

    const [complaints, total] = await Promise.all([
      Complaint.find(filter)
        .populate('raisedBy', 'name email')
        .populate('flat', 'flatNumber')
        .populate('building', 'name')
        .populate('society', 'name')
        .populate('resolvedBy', 'name')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(limit),
      Complaint.countDocuments(filter)
    ]);

    res.json(formatResponse({
      message: 'All complaints retrieved successfully',
      data: complaints,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};

// Update complaint status (Admin only)
exports.updateComplaintStatus = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status, adminNote } = req.body;

    const complaint = await updateComplaintStatusService({
      complaintId: id,
      status,
      adminNote,
      resolvedBy: req.user._id
    });

    res.json(formatResponse({
      message: 'Complaint status updated successfully',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

‚îÇ   ‚îÇ   ‚îÇ   # --- End: complaintController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownerController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownerController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const OwnershipRequest = require('../models/OwnershipRequest');
const Rent = require('../models/Rent');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const formatResponse = require('../utils/responseFormatter');
const DashboardService = require('../services/dashboardService');
const FlatService = require('../services/flatService');

// 1. Get all flats owned by logged-in owner
exports.getMyFlats = async (req, res, next) => {
  try {
    const flats = await FlatService.getFlatsByOwner(req.user._id);

    res.status(200).json(formatResponse({
      message: 'Flats retrieved successfully',
      data: flats
    }));
  } catch (err) {
    next(err);
  }
};

// 2. View society/building info of a specific flat
exports.getFlatSocietyInfo = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ _id: req.params.id, owner: req.user._id })
      .populate('building')
      .populate('society');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found or unauthorized',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Flat info retrieved successfully',
      data: {
        building: flat.building,
        society: flat.society
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Submit ownership transfer request
exports.submitOwnershipRequest = async (req, res, next) => {
  try {
    const { flatId, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flat = await Flat.findById(flatId);
    if (!flat || flat.owner.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized for this flat',
        statusCode: 403
      }));
    }

    const request = await OwnershipRequest.create({
      flat: flatId,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    res.status(201).json(formatResponse({
      message: 'Ownership request submitted successfully',
      data: request
    }));
  } catch (err) {
    next(err);
  }
};

// Get my ownership requests
exports.getMyOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ 
      currentOwner: req.user._id 
    }).populate('flat');

    res.status(200).json(formatResponse({
      message: 'Ownership requests retrieved successfully',
      data: requests
    }));
  } catch (err) {
    next(err);
  }
};

// 4. Rent payment history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ owner: req.user._id })
      .populate('flat')
      .populate('tenant');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved successfully',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 5. Dashboard summary
exports.getOwnerDashboard = async (req, res, next) => {
  try {
    const dashboardData = await DashboardService.getOwnerDashboard(req.user._id);

    res.status(200).json(formatResponse({
      message: 'Owner dashboard data retrieved successfully',
      data: dashboardData
    }));
  } catch (err) {
    next(err);
  }
};

// 6. View unpaid maintenance bills for owner flats
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flats = await Flat.find({
      owner: req.user._id,
      $or: [{ tenant: null }, { tenant: { $exists: false } }]
    });

    const flatIds = flats.map(f => f._id);

    const maintenance = await Maintenance.find({
      flat: { $in: flatIds },
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved successfully',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 7. Pay maintenance for owner flats
const { payMaintenance } = require('../services/paymentService');

exports.payMaintenance = async (req, res, next) => {
  try {
    const result = await payMaintenance({
      maintenanceId: req.params.maintenanceId,
      userId: req.user._id,
      role: 'owner'
    });

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// 8. Assign tenant to flat
exports.assignTenantToMyFlat = async (req, res, next) => {
  try {
    const { tenantId } = req.body;
    const flat = await FlatService.assignTenantToFlat(req.params.id, tenantId, req.user._id);

    res.status(200).json(formatResponse({
      message: 'Tenant assigned successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

exports.removeTenantFromMyFlat = async (req, res, next) => {
  try {
    const flat = await FlatService.removeTenantFromFlat(req.params.flatId, req.user._id);

    res.json(formatResponse({
      message: 'Tenant removed successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

exports.updateTenantForMyFlat = async (req, res, next) => {
  try {
    const { newTenantId } = req.body;
    const flat = await FlatService.assignTenantToFlat(req.params.flatId, newTenantId, req.user._id);

    res.status(200).json(formatResponse({
      message: 'Tenant updated successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownerController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownershipRequestController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownershipRequestController.js ---
// controllers/ownershipRequestController.js

const { reviewOwnershipRequest } = require('../services/ownershipService');
const OwnershipRequest = require('../models/OwnershipRequest');
const formatResponse = require('../utils/responseFormatter');


// Admin: list all ownership requests
exports.getOwnershipRequests = async (req, res, next) => {
  try {
    const { page = 1, limit = 10, status } = req.query;

    const query = {};
    if (status) query.status = status;

    const skip = (page - 1) * limit;

    const requests = await OwnershipRequest.find(query)
      .populate('currentOwner flat')
      .skip(skip)
      .limit(parseInt(limit));

    const total = await OwnershipRequest.countDocuments(query);

    res.json(formatResponse({
      message: 'Ownership requests retrieved',
      data: requests,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};


// Admin: review/approve/reject ownership request
exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;

    const updatedRequest = await reviewOwnershipRequest({
      requestId,
      status,
      note,
      reviewerId: req.user._id
    });

    res.json(formatResponse({
      message: `Ownership request ${status}`,
      data: updatedRequest
    }));
  } catch(err) {
    next(err);
  }
};

‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownershipRequestController.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ tenantController.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: tenantController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');
const Announcement = require('../models/Announcement');
const User = require('../models/User');
const formatResponse = require('../utils/responseFormatter');
const DashboardService = require('../services/dashboardService');
const FlatService = require('../services/flatService');

// 1. Get assigned flat
exports.getMyFlat = async (req, res, next) => {
  try {
    const flat = await FlatService.getUserFlat(req.user._id);

    res.status(200).json(formatResponse({
      message: 'Assigned flat retrieved successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

// 2. Rent history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ tenant: req.user._id })
      .populate('flat');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved successfully',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Pay rent
const { payRent } = require('../services/paymentService');

exports.payRent = async (req, res, next) => {
  try {
    const result = await payRent({
      rentId: req.params.rentId,
      userId: req.user._id
    });

    res.status(200).json(formatResponse({
      message: 'Rent paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// 4. View unpaid maintenance
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized',
        statusCode: 403
      }));
    }

    const maintenance = await Maintenance.find({
      flat: flat._id,
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved successfully',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 5. Pay maintenance
const { payMaintenance } = require('../services/paymentService');

exports.payMaintenance = async (req, res, next) => {
  try {
    const result = await payMaintenance({
      maintenanceId: req.params.maintenanceId,
      userId: req.user._id,
      role: 'tenant'
    });

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// 6. Dashboard overview
exports.getTenantDashboard = async (req, res, next) => {
  try {
    const dashboardData = await DashboardService.getTenantDashboard(req.user._id);

    res.status(200).json(formatResponse({
      message: 'Tenant dashboard data retrieved successfully',
      data: dashboardData
    }));
  } catch (err) {
    next(err);
  }
};

// 7. Get current month's rent (if exists)
exports.getCurrentRent = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not assigned',
        statusCode: 404
      }));
    }

    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM

    const rent = await Rent.findOne({
      flat: flat._id,
      tenant: req.user._id,
      billingMonth: currentMonth,
    });

    if (!rent) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No rent record found for this month',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Current month rent retrieved successfully',
      data: rent
    }));
  } catch (err) {
    next(err);
  }
};

exports.updateMyProfile = async (req, res, next) => {
  try {
    const { name, phone, profilePic } = req.body;

    const user = await User.findById(req.user._id);
    if (!user) return res.status(404).json(formatResponse({
      success: false,
      message: 'User not found',
      statusCode: 404
    }));

    if (name) user.name = name;
    if (phone) user.phone = phone;
    if (profilePic) user.profilePic = profilePic;

    await user.save();

    res.status(200).json(formatResponse({
      message: 'Profile updated successfully',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        profilePic: user.profilePic
      }
    }));
  } catch (err) {
    next(err);
  }
};

// üì£ Announcements
exports.getRelevantAnnouncements = async (req, res, next) => {
  try {
    const { priority, page = 1, limit = 10 } = req.query;
    
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const filter = { society: flat.society };
    if (priority) filter.priority = priority;

    const skip = (page - 1) * limit;
    const [announcements, total] = await Promise.all([
      Announcement.find(filter)
        .populate('society', 'name')
        .populate('createdBy', 'name')
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parseInt(limit)),
      Announcement.countDocuments(filter)
    ]);

    res.json(formatResponse({
      message: 'Relevant announcements retrieved successfully',
      data: announcements,
      pagination: {
        total,
        page: parseInt(page),
        limit: parseInt(limit),
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};


‚îÇ   ‚îÇ   ‚îÇ   # --- End: tenantController.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ logs/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ app.log

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: app.log ---
{"level":"INFO","timestamp":"2025-07-30T08:46:20.379Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T08:46:20.451Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T09:44:15.693Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T09:44:15.766Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T09:57:34.644Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T09:57:34.724Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T11:34:33.437Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T11:34:33.556Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T11:49:13.368Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T11:49:13.422Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T12:46:11.509Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T12:46:11.717Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:35:45.789Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:35:45.851Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:35:52.414Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:35:52.431Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:36:12.257Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:36:12.275Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:36:21.512Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:36:21.534Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:48:32.609Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:48:32.649Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:48:50.545Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:48:50.612Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:29.895Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:29.955Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:40.282Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:40.284Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:40.285Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:40.322Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:49.120Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:49.122Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:49.123Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:49.144Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:53.423Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:53.426Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:53.427Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:54:53.444Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:38.508Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:38.510Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:38.511Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:38.527Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:47.909Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:47.916Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:47.918Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:56:47.986Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:26.919Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:26.922Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:26.924Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:26.942Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:42.891Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:42.893Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:42.894Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:42.917Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:45.427Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:45.430Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:45.431Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:45.449Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:58.242Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:58.244Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:58.245Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:57:58.275Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:58:14.852Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:58:14.854Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:58:14.855Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:58:14.874Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:59:01.736Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:59:01.738Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:59:01.738Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T17:59:01.760Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:00:02.118Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:00:02.120Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:00:02.121Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:00:02.135Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:19.755Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:19.756Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:19.757Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:19.768Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:21.257Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:21.258Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:21.260Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:21.278Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:39.615Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:39.620Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:39.621Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:39.642Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:41.368Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:41.369Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:41.370Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:41.384Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:54.954Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:54.956Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:54.957Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:01:54.982Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:02:06.277Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:02:06.283Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:02:06.284Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:02:06.343Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:39.855Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:39.874Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:39.875Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:39.941Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:41.224Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:41.227Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:41.228Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:41.245Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:56.384Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:56.386Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:56.387Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:09:56.412Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:06.476Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:06.479Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:06.480Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:06.516Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:24.944Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:24.946Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:24.947Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:24.969Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:40.512Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:40.514Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:40.514Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:40.534Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:55.895Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:55.897Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:55.898Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:10:55.916Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:10.538Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:10.541Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:10.541Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:10.561Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:19.159Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:19.161Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:19.162Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:19.189Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:35.445Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:35.448Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:35.450Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:35.483Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:46.972Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:46.974Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:46.975Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:14:46.995Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:15:06.518Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:15:06.521Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:15:06.524Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:15:06.564Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:16:06.164Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:16:06.166Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:16:06.166Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:16:06.181Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:31:47.500Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:31:47.515Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:31:47.519Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-30T18:31:47.574Z","message":"MongoDB Connected: localhost","data":null}
{"level":"INFO","timestamp":"2025-07-30T20:13:25.479Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T20:13:25.486Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-30T20:13:25.487Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"ERROR","timestamp":"2025-07-30T20:13:55.475Z","message":"MongoDB Connection Error: connect ECONNREFUSED ::1:27017, connect ECONNREFUSED 127.0.0.1:27017","error":"MongooseServerSelectionError: connect ECONNREFUSED ::1:27017, connect ECONNREFUSED 127.0.0.1:27017\n    at _handleConnectionErrors (D:\\WEBDEVDSA\\webdevelopment\\Housing Society Management\\node_modules\\mongoose\\lib\\connection.js:1165:11)\n    at NativeConnection.openUri (D:\\WEBDEVDSA\\webdevelopment\\Housing Society Management\\node_modules\\mongoose\\lib\\connection.js:1096:11)\n    at async connectDB (D:\\WEBDEVDSA\\webdevelopment\\Housing Society Management\\config\\db.js:8:18)"}
{"level":"INFO","timestamp":"2025-07-31T05:17:31.118Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:17:31.130Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:17:31.131Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:17:37.784Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:21:45.345Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:21:45.357Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:21:45.358Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:21:46.528Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:29:35.317Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:29:35.327Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:29:35.328Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:29:42.409Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:30:16.281Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:30:16.283Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:30:16.285Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:30:17.321Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:29.973Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:29.976Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:29.977Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:32.835Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:46.058Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:46.059Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:46.060Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:31:49.480Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:32:28.102Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:32:28.104Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:32:28.104Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:32:30.211Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:48:08.083Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:48:08.085Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:48:08.086Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:48:09.381Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:54:26.178Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:54:26.180Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:54:26.182Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T05:54:28.029Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:00:02.594Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:00:02.596Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:00:02.596Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:00:04.115Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:13:07.883Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:13:07.885Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:13:07.886Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:13:09.321Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:38.898Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:38.901Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:38.902Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:40.376Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:55.827Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:55.828Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:55.829Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T06:22:57.364Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T09:56:11.593Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T09:56:11.613Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T09:56:11.614Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T09:56:13.030Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:00:04.145Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:00:04.163Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:00:04.165Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:00:05.494Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:11:52.692Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:11:52.697Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:11:52.700Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:11:54.604Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:43:05.694Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:43:05.698Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:43:05.699Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:43:12.885Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:32.464Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:32.470Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:32.473Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:33.626Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:53.391Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:53.399Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:53.401Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:47:54.279Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:48:05.650Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:48:05.652Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:48:05.653Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:48:06.530Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:50:54.130Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:50:54.133Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:50:54.135Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:50:55.277Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:52:55.805Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:52:55.808Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:52:55.808Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:52:56.650Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:15.921Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:15.945Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:15.946Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:17.148Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:23.799Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:23.804Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:23.806Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T10:55:24.794Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:05.094Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:05.117Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:05.120Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:06.790Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:10.272Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:10.276Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:10.278Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:04:11.617Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:47:05.406Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:47:05.409Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:47:05.410Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:47:06.926Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:56:17.754Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:56:17.759Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:56:17.762Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:56:19.709Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:21.556Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:21.558Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:21.559Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:22.803Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:35.838Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:35.842Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:35.844Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:37.655Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:43.326Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:43.327Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:43.328Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:58:45.019Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:18.769Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:18.772Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:18.775Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:20.152Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:34.824Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:34.826Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:34.827Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:36.224Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-02.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:43.539Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:43.541Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:43.542Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T11:59:44.929Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-01.akpgore.mongodb.net","data":null}
{"level":"INFO","timestamp":"2025-07-31T12:00:03.294Z","message":"Server running in development mode on port 5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T12:00:03.296Z","message":"üåê Local URL: http://localhost:5000","data":null}
{"level":"INFO","timestamp":"2025-07-31T12:00:03.297Z","message":"üìö API Documentation: http://localhost:5000/api","data":null}
{"level":"INFO","timestamp":"2025-07-31T12:00:04.386Z","message":"MongoDB Connected: ac-6r2zdht-shard-00-00.akpgore.mongodb.net","data":null}

‚îÇ   ‚îÇ   ‚îÇ   # --- End: app.log ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ combined.log

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: combined.log ---

‚îÇ   ‚îÇ   ‚îÇ   # --- End: combined.log ---

‚îÇ   ‚îÇ   ‚îú‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ authMiddleware.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: authMiddleware.js ---
// middleware/authMiddleware.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  let token = req.cookies.token;

  if (!token && req.headers.authorization?.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ success: false, message: 'Unauthorized: Token missing' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    
    if (!user) {
      return res.status(401).json({ success: false, message: 'User not found' });
    }

    // ‚úÖ FIXED: Check if user is active
    if (!user.isActive) {
      return res.status(401).json({ success: false, message: 'Account is deactivated' });
    }

    req.user = user;
    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ message: 'Session expired. Please log in again.' });
    }
    return res.status(401).json({ success: false, message: 'Invalid or expired token' });
  }
};

module.exports = authMiddleware;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: authMiddleware.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ errorHandler.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: errorHandler.js ---
// middleware/errorHandler.js

const formatResponse = require('../utils/responseFormatter');

const errorHandler = (error, req, res, next) => {
  console.error('‚ùå Error:', error);

  // Handle custom error classes
  if (error.statusCode) {
    return res.status(error.statusCode).json(formatResponse({
      success: false,
      message: error.message,
      statusCode: error.statusCode
    }));
  }

  // Handle Mongoose validation errors
  if (error.name === 'ValidationError') {
    const messages = Object.values(error.errors).map(err => err.message);
    return res.status(400).json(formatResponse({
      success: false,
      message: 'Validation failed',
      errors: messages,
      statusCode: 400
    }));
  }

  // Handle Mongoose cast errors (invalid ObjectId)
  if (error.name === 'CastError') {
    return res.status(400).json(formatResponse({
      success: false,
      message: 'Invalid ID format',
      statusCode: 400
    }));
  }

  // Handle duplicate key errors
  if (error.code === 11000) {
    const field = Object.keys(error.keyValue)[0];
    return res.status(409).json(formatResponse({
      success: false,
      message: `${field} already exists`,
      statusCode: 409
    }));
  }

  // Handle JWT errors
  if (error.name === 'JsonWebTokenError') {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Invalid token',
      statusCode: 401
    }));
  }

  if (error.name === 'TokenExpiredError') {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Token expired',
      statusCode: 401
    }));
  }

  // Default error response
  res.status(500).json(formatResponse({
    success: false,
    message: process.env.NODE_ENV === 'production' ? 'Internal server error' : error.message,
    statusCode: 500
  }));
};

module.exports = errorHandler;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: errorHandler.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ mongoSanitizeMiddleware.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: mongoSanitizeMiddleware.js ---
// Custom MongoDB sanitization middleware to replace express-mongo-sanitize
const mongoSanitizeMiddleware = (req, res, next) => {
  // Sanitize request body to prevent NoSQL injection
  if (req.body) {
    const sanitizeObject = (obj) => {
      const sanitized = {};
      for (const [key, value] of Object.entries(obj)) {
        // Remove MongoDB operators from keys
        const sanitizedKey = key.replace(/[$]/g, '');
        
        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
          sanitized[sanitizedKey] = sanitizeObject(value);
        } else {
          sanitized[sanitizedKey] = value;
        }
      }
      return sanitized;
    };
    
    req.body = sanitizeObject(req.body);
  }

  // Sanitize query parameters
  if (req.query) {
    const sanitizeQuery = (query) => {
      const sanitized = {};
      for (const [key, value] of Object.entries(query)) {
        // Remove MongoDB operators from keys
        const sanitizedKey = key.replace(/[$]/g, '');
        sanitized[sanitizedKey] = value;
      }
      return sanitized;
    };
    
    // Create a new query object instead of modifying the existing one
    req.sanitizedQuery = sanitizeQuery(req.query);
  }

  next();
};

module.exports = mongoSanitizeMiddleware; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: mongoSanitizeMiddleware.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ paginationMiddleware.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: paginationMiddleware.js ---
// middleware/paginationMiddleware.js

const paginationMiddleware = (req, res, next) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 10;
  const skip = (page - 1) * limit;

  // Attach pagination data to request object
  req.pagination = {
    page,
    limit,
    skip
  };

  next();
};

module.exports = paginationMiddleware; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: paginationMiddleware.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ roleAccessGuard.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: roleAccessGuard.js ---
const formatResponse = require('../utils/responseFormatter');
const Flat = require('../models/Flat');

const verifyOwnerAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ owner: req.user._id });
  if (!flat) {
    return res.status(403).json(formatResponse({
      success: false,
      message: 'Owner not assigned to any flat',
      statusCode: 403
    }));
  }
  next();
};

const verifyTenantAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ tenant: req.user._id });
  if (!flat) {
    return res.status(403).json(formatResponse({
      success: false,
      message: 'Tenant not assigned to any flat',
      statusCode: 403
    }));
  }
  next();
};

module.exports = { verifyOwnerAssigned, verifyTenantAssigned };

‚îÇ   ‚îÇ   ‚îÇ   # --- End: roleAccessGuard.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ roleMiddleware.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: roleMiddleware.js ---
// middleware/roleMiddleware.js

const roleMiddleware = (roles) => {
  const allowedRoles = Array.isArray(roles) ? roles : [roles];
  return (req, res, next) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'Access denied: Insufficient permissions' });
    }
    next();
  };
};

module.exports = roleMiddleware;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: roleMiddleware.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ validate.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: validate.js ---
const { validationResult } = require('express-validator');

const validate = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    console.log('Validation errors:', JSON.stringify(errors.array(), null, 2));
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      data: null,
      errors: errors.array(),
      statusCode: 400
    });
  }
  next();
};
module.exports =  validate ;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: validate.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ xssMiddleware.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: xssMiddleware.js ---
const xss = require('xss');

const xssMiddleware = (req, res, next) => {
  // Sanitize request body only - this is safe to modify
  if (req.body && Object.keys(req.body).length > 0) {
    const sanitizeObject = (obj) => {
      const sanitized = {};
      for (const [key, value] of Object.entries(obj)) {
        if (typeof value === 'string') {
          sanitized[key] = xss(value);
        } else if (typeof value === 'object' && value !== null) {
          sanitized[key] = sanitizeObject(value);
        } else {
          sanitized[key] = value;
        }
      }
      return sanitized;
    };
    
    req.body = sanitizeObject(req.body);
  }

  // ‚úÖ FIXED: Removed query sanitization to avoid read-only property error
  // Query parameters are already sanitized by Express and other middleware
  // If XSS protection is needed for queries, it should be handled at the controller level

  next();
};

module.exports = xssMiddleware; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: xssMiddleware.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ models/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Announcement.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Announcement.js ---
// models/Announcement.js

const mongoose = require('mongoose');

const announcementSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Announcement title is required'],
    trim: true,
  },
  content: { // ‚úÖ CHANGED: from 'message' to 'content'
    type: String,
    required: [true, 'Announcement content is required'],
    trim: true,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    required: [true, 'Admin reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Target society is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    default: null, // If null, applies to whole society
  },
  priority: { // ‚úÖ ADDED: Missing priority field that validators expect
    type: String,
    enum: ['low', 'medium', 'high'],
    default: 'medium',
  },
  audience: {
    type: String,
    enum: ['all', 'owners', 'tenants'],
    default: 'all',
  },
  validTill: {
    type: Date,
    default: null, // Optional expiry
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Announcement', announcementSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Announcement.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Building.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Building.js ---
// models/Building.js

const mongoose = require('mongoose');

const buildingSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Building name is required'],
    trim: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  totalFloors: {
    type: Number,
    required: [true, 'Total number of floors is required'],
    min: [1, 'There must be at least 1 floor'],
  },
  totalFlats: {
    type: Number,
    required: [true, 'Total number of flats is required'],
    min: [1, 'There must be at least 1 flat'],
  },
  addressLabel: {
    type: String,
    trim: true,
    default: '',
    // Optional label if address differs from society (e.g., "Wing B, Gate 2")
  },
}, {
  timestamps: true,
});

// ‚úÖ FIXED: Removed problematic pre-save hook
// Flat creation will be handled in the service layer after building is saved

module.exports = mongoose.model('Building', buildingSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Building.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Complaint.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Complaint.js ---
// models/Complaint.js

const mongoose = require('mongoose');

const complaintSchema = new mongoose.Schema({
  raisedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User who raised the complaint is required'],
  },
  userRole: {
    type: String,
    enum: ['owner', 'tenant'],
    required: true,
  },
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: true,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  category: {
    type: String,
    enum: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    default: 'other',
  },
  subject: {
    type: String,
    required: [true, 'Complaint subject is required'],
    trim: true,
  },
  description: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['open', 'in-progress', 'resolved', 'rejected'],
    default: 'open',
  },
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  resolvedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: "",
  },
}, {
  timestamps: true,
});

// Indexes
complaintSchema.index({ raisedBy: 1 });
complaintSchema.index({ flat: 1 });
complaintSchema.index({ society: 1 });
complaintSchema.index({ status: 1 }); // Index for status filtering

module.exports = mongoose.model('Complaint', complaintSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Complaint.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Flat.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Flat.js ---
// models/Flat.js

const mongoose = require('mongoose');

const flatSchema = new mongoose.Schema({
  flatNumber: {
    type: String,
    required: [true, 'Flat number is required'],
    trim: true,
    index: true,
  },
  floor: {
    type: Number,
    required: [true, 'Floor number is required'],
    min: 0,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  isRented: {
    type: Boolean,
    default: false,
  },
  occupancyStatus: {
    type: String,
    enum: ['vacant', 'occupied-owner', 'occupied-tenant'],
    default: 'vacant',
  },
}, {
  timestamps: true,
});

// Pre-save middleware to update occupancyStatus based on owner/tenant
flatSchema.pre('save', function(next) {
  if (this.tenant) {
    this.occupancyStatus = 'occupied-tenant';
    this.isRented = true;
  } else if (this.owner) {
    this.occupancyStatus = 'occupied-owner';
    this.isRented = false;
  } else {
    this.occupancyStatus = 'vacant';
    this.isRented = false;
  }
  next();
});

// Indexes
flatSchema.index({ owner: 1 });
flatSchema.index({ tenant: 1 });
flatSchema.index({ society: 1 });
flatSchema.index({ building: 1 });
flatSchema.index({ building: 1, flatNumber: 1 }); // Compound index for common query pattern

module.exports = mongoose.model('Flat', flatSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Flat.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Maintenance.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Maintenance.js ---
// models/Maintenance.js

const mongoose = require('mongoose');

const maintenanceSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  amount: {
    type: Number,
    required: [true, 'Maintenance amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Typically an Admin
    required: true,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Maintenance', maintenanceSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Maintenance.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ OwnershipRequest.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: OwnershipRequest.js ---
// models/OwnershipRequest.js

const mongoose = require('mongoose');

const ownershipRequestSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  currentOwner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Current owner reference is required'],
  },
  newOwnerName: {
    type: String,
    required: [true, 'New owner name is required'],
    trim: true,
  },
  newOwnerEmail: {
    type: String,
    required: [true, 'New owner email is required'],
    trim: true,
    lowercase: true,
  },
  newOwnerPhone: {
    type: String,
    required: [true, 'New owner phone number is required'],
    trim: true,
  },
  reason: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'pending',
  },
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    default: null,
  },
  reviewedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('OwnershipRequest', ownershipRequestSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: OwnershipRequest.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Rent.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Rent.js ---
// models/Rent.js

const mongoose = require('mongoose');

const rentSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Tenant reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner reference is required'],
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  amount: {
    type: Number,
    required: [true, 'Rent amount is required'],
    min: 0,
  },
  status: {
    type: String,
    enum: ['unpaid', 'paid', 'overdue'],
    default: 'unpaid',
  },
  paidOn: {
    type: Date,
    default: null,
  },
  paymentMethod: {
    type: String,
    enum: ['cash', 'online', 'bank-transfer', 'upi'],
    default: 'online',
  },
  transactionId: {
    type: String,
    default: null,
  },
  dueDate: {
    type: Date,
    required: true,
  },
}, {
  timestamps: true,
});

// Indexes for better query performance
rentSchema.index({ billingMonth: 1, status: 1 });
rentSchema.index({ tenant: 1, status: 1 });
rentSchema.index({ owner: 1, status: 1 });
rentSchema.index({ society: 1, billingMonth: 1 });
rentSchema.index({ dueDate: 1, status: 1 });

module.exports = mongoose.model('Rent', rentSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Rent.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ Society.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: Society.js ---
// models/Society.js

const mongoose = require('mongoose');

const societySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Society name is required'],
    trim: true,
  },
  address: {
    street: { type: String, required: true, trim: true },
    city: { type: String, required: true, trim: true },
    state: { type: String, required: true, trim: true },
    pincode: { type: String, required: true, trim: true },
  },
  registrationNumber: {
    type: String,
    required: [true, 'Registration number is required'],
    unique: true,
    trim: true,
  },
  totalBuildings: {
    type: Number,
    default: 0,
    min: 0,
  },
  maintenancePolicy: {
    frequency: {
      type: String,
      enum: ['monthly', 'quarterly'],
      default: 'monthly',
    },
    amountPerFlat: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  admin: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Admin user is required'],
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Society', societySchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: Society.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ User.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: User.js ---
// models/User.js

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// Role constants
const ROLES = ['admin', 'owner', 'tenant'];

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide your name'],
    trim: true,
    maxlength: [50, 'Name cannot exceed 50 characters'],
  },
  email: {
    type: String,
    required: [true, 'Please provide your email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\S+@\S+\.\S+$/,
      'Please provide a valid email address',
    ],
  },
  password: {
    type: String,
    required: [true, 'Please set a password'],
    minlength: [6, 'Password must be at least 6 characters'],
    select: false, // Hide in queries by default
  },
  role: {
    type: String,
    enum: ROLES,
    default: 'tenant',
  },
  phone: {
    type: String,
    trim: true,
    maxlength: 15,
  },
  profilePic: {
    type: String, // URL to profile image (optional)
    default: '',
  },
  loginAttempts: {
    type: Number,
    default: 0,
  },
  lastLogin: {
    type: Date,
    default: null,
  },
  isActive: {
    type: Boolean,
    default: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    default: null
  },
}, {
  timestamps: true,
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next(); // Only hash if changed

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Method to compare entered password with stored hash
userSchema.methods.comparePassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

‚îÇ   ‚îÇ   ‚îÇ   # --- End: User.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ routes/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ adminRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: adminRoutes.js ---
const express = require('express');
const router = express.Router();

const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const paginationMiddleware = require('../middleware/paginationMiddleware');

const validate = require('../middleware/validate');

const { 
  societyCreateValidator, 
  societyUpdateValidator, 
  buildingCreateValidator, 
  buildingUpdateValidator, 
  flatCreateValidator, 
  flatAssignOwnerValidator, 
  ownershipRequestReviewValidator, 
  reminderValidator, 
  societyNoteValidator, 
  userUpdateValidator 
} = require('../validators/adminValidator');

router.use(authMiddleware);
router.use(roleMiddleware('admin'));

// === SOCIETY MANAGEMENT ===
router.post('/societies', societyCreateValidator, validate, adminController.createSociety);
router.get('/societies/my', paginationMiddleware, adminController.getMySocieties);
router.put('/societies/:id', societyUpdateValidator, validate, adminController.updateSociety);
router.delete('/societies/:id', adminController.deleteSociety);

// === BUILDING MANAGEMENT ===
router.post('/buildings', buildingCreateValidator, validate, adminController.createBuilding);
router.put('/buildings/:id', buildingUpdateValidator, validate, adminController.updateBuilding);
router.delete('/buildings/:id', adminController.deleteBuilding);

// === FLAT MANAGEMENT ===
router.post('/flats', flatCreateValidator, validate, adminController.createFlats);
router.patch('/flats/:flatId/assign-owner', flatAssignOwnerValidator, validate, adminController.assignFlatOwner);
router.patch('/flats/:flatId/remove-owner', adminController.removeFlatOwner);
router.patch('/flats/:flatId/remove-tenant', adminController.removeFlatTenant);

// === USER MANAGEMENT ===
router.get('/users', paginationMiddleware, adminController.getAllUsers);
router.get('/users/:id', adminController.getUserById);
router.patch('/users/:id', userUpdateValidator, validate, adminController.updateUser);
router.patch('/users/:id/toggle-status', adminController.toggleUserStatus);

// === RENT MANAGEMENT ===
router.post('/rent/generate', adminController.generateRent);
router.get('/rent/history', paginationMiddleware, adminController.getRentHistory);

// === MAINTENANCE ===
router.post('/maintenance', adminController.generateMaintenance);
router.get('/maintenance/status', paginationMiddleware, adminController.getMaintenanceStatus);

// === OWNERSHIP REQUESTS ===
router.get('/ownership-requests', adminController.getOwnershipRequests);
router.patch('/ownership-requests/review', ownershipRequestReviewValidator, validate, adminController.reviewOwnershipRequest);

// === DASHBOARD & DOCUMENTS ===
router.get('/dashboard/overview', adminController.getAdminDashboard);
router.get('/flats/:flatId/info', adminController.getFlatInfo);

// === NOTES & REMINDERS ===
router.patch('/societies/:id/note', societyNoteValidator, validate, adminController.addSocietyNote);
router.post('/users/:id/reminder', reminderValidator, validate, adminController.sendReminderToUser);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: adminRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ announcementRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: announcementRoutes.js ---
// routes/announcementRoutes.js

const express = require('express');
const router = express.Router();

const { createAnnouncement, getAllAnnouncements, getRelevantAnnouncements, updateAnnouncement, deleteAnnouncement } = require('../controllers/announcementController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const validate = require('../middleware/validate');
const { announcementCreateValidator, announcementUpdateValidator } = require('../validators/announcementValidator');

router.use(authMiddleware);

// POST /api/announcements/ - Create a new announcement (Admin only)
router.post('/', roleMiddleware('admin'), announcementCreateValidator, validate, createAnnouncement);

// GET /api/announcements/ - Get all announcements (Admin only)
router.get('/', roleMiddleware('admin'), getAllAnnouncements);

// GET /api/announcements/relevant - Get relevant announcements for user (Owner/Tenant)
router.get('/relevant', roleMiddleware(['owner', 'tenant']), getRelevantAnnouncements);

// PUT /api/announcements/:id - Update announcement (Admin only)
router.put('/:id', roleMiddleware('admin'), announcementUpdateValidator, validate, updateAnnouncement);

// DELETE /api/announcements/:id - Delete announcement (Admin only)
router.delete('/:id', roleMiddleware('admin'), deleteAnnouncement);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: announcementRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ authRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: authRoutes.js ---
// routes/authRoutes.js

const express = require('express');
const router = express.Router();

const authController = require('../controllers/authController');
const  protect  = require('../middleware/authMiddleware');

const  validate  = require('../middleware/validate');
const { registerValidator, loginValidator } = require('../validators/authValidator');
// Public Routes
router.post('/register', registerValidator, validate, authController.registerUser);
router.post('/login', loginValidator, validate, authController.loginUser);
// router.get('/token-status', authController.tokenStatus);

// Protected Routes
router.post('/logout', protect, authController.logoutUser);
router.get('/me', protect, authController.getMe);
router.patch('/change-password', protect, authController.changePassword);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: authRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ complaintRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: complaintRoutes.js ---

const express = require('express');
const router = express.Router();
const complaintController = require('../controllers/complaintController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const paginationMiddleware = require('../middleware/paginationMiddleware');
const validate = require('../middleware/validate');
const { 
  complaintCreateValidator, 
  complaintStatusUpdateValidator, 
  complaintsQueryValidator 
} = require('../validators/complaintValidator');

// ‚úÖ FIXED: Consolidate all complaint routes with proper role-based access
router.use(authMiddleware);

// POST /api/complaints/ - Create a new complaint (Owner or Tenant)
router.post('/', roleMiddleware(['owner', 'tenant']), complaintCreateValidator, validate, complaintController.createComplaint);

// GET /api/complaints/my - Get complaints filed by the logged-in user (Owner or Tenant)
router.get('/my', roleMiddleware(['owner', 'tenant']), paginationMiddleware, complaintController.getMyComplaints);

// GET /api/complaints/ - Get ALL complaints (Admin only)
router.get('/', roleMiddleware('admin'), complaintsQueryValidator, validate, paginationMiddleware, complaintController.getAllComplaints);

// PATCH /api/complaints/:id - Update complaint status (Admin only)
router.patch('/:id', roleMiddleware('admin'), complaintStatusUpdateValidator, validate, complaintController.updateComplaintStatus);

module.exports = router;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: complaintRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownerRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownerRoutes.js ---
const express = require('express');
const router = express.Router();
const ownerController = require('../controllers/ownerController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyOwnerAssigned } = require('../middleware/roleAccessGuard'); // ‚úÖ FIXED: Destructure the function
const paginationMiddleware = require('../middleware/paginationMiddleware');
const validate = require('../middleware/validate');
const { maintenancePaymentValidator, profileUpdateValidator } = require('../validators/ownerValidator');

// ‚úÖ FIXED: Remove global assignment middleware, apply selectively
router.use(authMiddleware);
router.use(roleMiddleware('owner'));

// Routes that DON'T require flat assignment
router.get('/dashboard/overview', ownerController.getOwnerDashboard);
router.get('/flats', ownerController.getMyFlats);

// Routes that DO require flat assignment
router.get('/flats/:id/society', verifyOwnerAssigned, ownerController.getFlatSocietyInfo);
router.get('/maintenance-due', verifyOwnerAssigned, ownerController.getUnpaidMaintenance);
router.patch('/maintenance/:maintenanceId/pay', verifyOwnerAssigned, maintenancePaymentValidator, validate, ownerController.payMaintenance);
router.get('/rent-history', verifyOwnerAssigned, ownerController.getRentHistory);

// === OWNERSHIP REQUESTS ===
router.post('/ownership-requests', ownerController.submitOwnershipRequest);
router.get('/ownership-requests/my', ownerController.getMyOwnershipRequests);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownerRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownershipRequestRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownershipRequestRoutes.js ---
// routes/ownershipRequestRoutes.js
const express = require('express');
const router = express.Router();
const controller = require('../controllers/ownershipRequestController');
const  protect  = require('../middleware/authMiddleware');
const  roleMiddleware  = require('../middleware/roleMiddleware');

// Admin routes
router.get('/', protect, roleMiddleware(['admin']), controller.getOwnershipRequests);
router.patch('/:requestId', protect, roleMiddleware(['admin']), controller.reviewOwnershipRequest);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownershipRequestRoutes.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ tenantRoutes.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: tenantRoutes.js ---
const express = require('express');
const router = express.Router();
const tenantController = require('../controllers/tenantController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyTenantAssigned } = require('../middleware/roleAccessGuard'); // ‚úÖ FIXED: Destructure the function
const paginationMiddleware = require('../middleware/paginationMiddleware');
const validate = require('../middleware/validate');
const { rentPaymentValidator } = require('../validators/tenantValidator');

// ‚úÖ FIXED: Remove global assignment middleware, apply selectively
router.use(authMiddleware);
router.use(roleMiddleware('tenant'));

// Routes that DON'T require flat assignment
router.get('/dashboard/overview', tenantController.getTenantDashboard);
router.patch('/profile', tenantController.updateMyProfile);

// Routes that DO require flat assignment
router.get('/my-flat', verifyTenantAssigned, tenantController.getMyFlat);
router.get('/rent-history', verifyTenantAssigned, tenantController.getRentHistory);
router.patch('/rent/:rentId/pay', verifyTenantAssigned, rentPaymentValidator, validate, tenantController.payRent);
router.get('/maintenance-due', verifyTenantAssigned, tenantController.getUnpaidMaintenance);
router.patch('/maintenance/:maintenanceId/pay', verifyTenantAssigned, validate, tenantController.payMaintenance);
router.get('/announcements', tenantController.getRelevantAnnouncements);

module.exports = router;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: tenantRoutes.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ authService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: authService.js ---
// services/authService.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Flat = require('../models/Flat');

// Generate a signed JWT and return cookie options
exports.generateTokenCookie = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  return token;
};

// Validate user login
exports.loginUser = async ({ email, password }) => {
  const user = await User.findOne({ email }).select('+password');
  if (!user || !(await user.comparePassword(password))) {
    throw new Error('Invalid email or password');
  }

  // ‚úÖ FIXED: Remove restrictive flat assignment validation
  // Allow users to log in regardless of flat assignment status
  // Flat assignment validation should be done at the business logic level, not during login

  return user;
};

// Register new user
exports.registerUser = async ({ name, email, password, phone, role = 'tenant' }) => {
  const existing = await User.findOne({ email });
  if (existing) throw new Error('Email is already registered');

  const user = await User.create({ name, email, password, phone, role });
  return user;
};

// Change password
exports.changePassword = async ({ userId, currentPassword, newPassword }) => {
  const user = await User.findById(userId).select('+password');
  if (!user || !(await user.comparePassword(currentPassword))) {
    throw new Error('Current password is incorrect');
  }

  user.password = newPassword;
  await user.save();
};

// Token check
exports.validateToken = (token) => {
  return jwt.verify(token, process.env.JWT_SECRET);
};

‚îÇ   ‚îÇ   ‚îÇ   # --- End: authService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ buildingService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: buildingService.js ---
// services/buildingService.js
const Building = require('../models/Building');
const Flat = require('../models/Flat');
const Society = require('../models/Society');

class BuildingService {
  // Create building with automatic flat creation
  static async createBuilding(buildingData) {
    const session = await Building.startSession();
    session.startTransaction();

    try {
      // Validate society exists
      const society = await Society.findById(buildingData.society);
      if (!society) {
        throw new Error('Society not found');
      }

      // Create building
      const building = new Building({
        name: buildingData.name,
        society: buildingData.society,
        totalFloors: buildingData.totalFloors,
        totalFlats: buildingData.totalFlats,
        addressLabel: buildingData.addressLabel || ''
      });

      await building.save({ session });

      // Create flats for the building
      const flats = [];
      const flatsPerFloor = Math.ceil(building.totalFlats / building.totalFloors);

      for (let floor = 1; floor <= building.totalFloors; floor++) {
        const flatsOnThisFloor = Math.min(flatsPerFloor, building.totalFlats - flats.length);
        
        for (let flatNum = 1; flatNum <= flatsOnThisFloor; flatNum++) {
          const flatNumber = `${floor}${String(flatNum).padStart(2, '0')}`;
          
          flats.push({
            flatNumber,
            floor,
            building: building._id,
            society: building.society,
            occupancyStatus: 'vacant'
          });
        }
      }

      if (flats.length > 0) {
        await Flat.insertMany(flats, { session });
      }

      await session.commitTransaction();
      session.endSession();

      return building;
    } catch (error) {
      await session.abortTransaction();
      session.endSession();
      throw error;
    }
  }

  // Update building
  static async updateBuilding(buildingId, updateData) {
    const building = await Building.findByIdAndUpdate(
      buildingId,
      updateData,
      { new: true, runValidators: true }
    );

    if (!building) {
      throw new Error('Building not found');
    }

    return building;
  }

  // Delete building and its flats
  static async deleteBuilding(buildingId) {
    const session = await Building.startSession();
    session.startTransaction();

    try {
      // Delete all flats in the building
      await Flat.deleteMany({ building: buildingId }, { session });

      // Delete the building
      const building = await Building.findByIdAndDelete(buildingId, { session });

      if (!building) {
        throw new Error('Building not found');
      }

      await session.commitTransaction();
      session.endSession();

      return building;
    } catch (error) {
      await session.abortTransaction();
      session.endSession();
      throw error;
    }
  }

  // Get building by ID with populated society
  static async getBuildingById(buildingId) {
    const building = await Building.findById(buildingId)
      .populate('society', 'name address');

    if (!building) {
      throw new Error('Building not found');
    }

    return building;
  }

  // Get buildings by society
  static async getBuildingsBySociety(societyId, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;

    const [buildings, total] = await Promise.all([
      Building.find({ society: societyId })
        .populate('society', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      Building.countDocuments({ society: societyId })
    ]);

    return {
      buildings,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }
}

module.exports = BuildingService; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: buildingService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ complaintService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: complaintService.js ---
// services/complaintService.js
const Complaint = require('../models/Complaint');
const Flat = require('../models/Flat');

exports.createComplaint = async ({ raisedBy, userRole, flatId, category, subject, description }) => {
  const flat = await Flat.findById(flatId).populate('building society');
  if (!flat) throw new Error('Flat not found');

  const complaint = await Complaint.create({
    raisedBy,
    userRole,
    flat: flat._id,
    building: flat.building._id,
    society: flat.society._id,
    category,
    subject,
    description,
  });

  return complaint;
};

exports.getComplaintsByUser = async (userId, userRole) => {
  return await Complaint.find({ raisedBy: userId, userRole })
    .populate('flat')
    .populate('building')
    .populate('society');
};

// Updated getAllComplaints()
exports.getAllComplaints = async ({ page = 1, limit = 10, status, category }) => {
    const { skip } = require('../utils/pagination').paginate({ page, limit });
  
    const query = {};
    if (status) query.status = status;
    if (category) query.category = category;
  
    const complaints = await Complaint.find(query)
      .skip(skip)
      .limit(limit)
      .populate('raisedBy', 'name email role')
      .populate('flat building society');
  
    const total = await Complaint.countDocuments(query);
  
    return { complaints, total };
  };
  

// services/complaintService.js (add this)
exports.updateComplaintStatus = async ({ complaintId, status, adminNote, resolvedBy }) => {
    const complaint = await Complaint.findById(complaintId);
    if (!complaint) throw new Error('Complaint not found');
  
    complaint.status = status;
    complaint.adminNote = adminNote || '';
    complaint.resolvedBy = resolvedBy;
    complaint.resolvedOn = new Date();
  
    await complaint.save();
    return complaint;
  };
  
‚îÇ   ‚îÇ   ‚îÇ   # --- End: complaintService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ dashboardService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: dashboardService.js ---
const Flat = require('../models/Flat');
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');
const Complaint = require('../models/Complaint');
const User = require('../models/User');

class DashboardService {
  // Get admin dashboard data
  static async getAdminDashboard(adminId) {
    try {
      // Get admin's societies
      const societies = await Flat.distinct('society', { owner: adminId });
      
      // Get total flats managed by admin
      const totalFlats = await Flat.countDocuments({ owner: adminId });
      
      // Get occupied flats
      const occupiedFlats = await Flat.countDocuments({ 
        owner: adminId, 
        tenant: { $exists: true, $ne: null } 
      });

      // Get vacant flats
      const vacantFlats = totalFlats - occupiedFlats;

      // Get maintenance statistics
      const maintenanceStats = await this.getMaintenanceStats(societies);

      // Get rent statistics
      const rentStats = await this.getRentStats(societies);

      // Get complaint statistics
      const complaintStats = await this.getComplaintStats(societies);

      return {
        totalFlats,
        occupiedFlats,
        vacantFlats,
        maintenance: maintenanceStats,
        rent: rentStats,
        complaints: complaintStats
      };
    } catch (error) {
      console.error('Dashboard service error:', error);
      throw new Error('Failed to load dashboard data');
    }
  }

  // Get owner dashboard data
  static async getOwnerDashboard(ownerId) {
    try {
      // Get owner's flats
      const flats = await Flat.find({ owner: ownerId })
        .populate('tenant', 'name email')
        .populate('building', 'name')
        .populate('society', 'name');

      // Get maintenance due
      const maintenanceDue = await Maintenance.find({
        flat: { $in: flats.map(flat => flat._id) },
        status: 'unpaid'
      }).populate('flat building society');

      // Get rent due
      const rentDue = await Rent.find({
        flat: { $in: flats.map(flat => flat._id) },
        status: 'unpaid'
      }).populate('flat building society tenant');

      // Calculate total amounts with proper null checks
      const totalMaintenanceDue = maintenanceDue
        .reduce((sum, maintenance) => sum + (maintenance.amount || 0), 0);

      const totalRentDue = rentDue
        .reduce((sum, rent) => sum + (rent.amount || 0), 0);

      return {
        flats,
        maintenanceDue: {
          records: maintenanceDue,
          total: totalMaintenanceDue,
          count: maintenanceDue.length
        },
        rentDue: {
          records: rentDue,
          total: totalRentDue,
          count: rentDue.length
        }
      };
    } catch (error) {
      console.error('Owner dashboard service error:', error);
      throw new Error('Failed to load owner dashboard data');
    }
  }

  // Get tenant dashboard data
  static async getTenantDashboard(tenantId) {
    try {
      // Get tenant's flat with proper null check
      const flat = await Flat.findOne({ tenant: tenantId })
        .populate('owner', 'name email')
        .populate('building', 'name')
        .populate('society', 'name');

      // If no flat is assigned, return a default dashboard
      if (!flat) {
        return {
          flat: null,
          maintenanceDue: {
            records: [],
            total: 0,
            count: 0
          },
          rentDue: {
            records: [],
            total: 0,
            count: 0
          },
          message: 'No flat assigned to tenant'
        };
      }

      // Get maintenance due for tenant's flat
      const maintenanceDue = await Maintenance.find({
        flat: flat._id,
        status: 'unpaid'
      }).populate('flat building society');

      // Get rent due for tenant's flat
      const rentDue = await Rent.find({
        flat: flat._id,
        status: 'unpaid'
      }).populate('flat building society');

      // Calculate totals with null checks
      const totalMaintenanceDue = maintenanceDue
        .reduce((sum, maintenance) => sum + (maintenance.amount || 0), 0);

      const totalRentDue = rentDue
        .reduce((sum, rent) => sum + (rent.amount || 0), 0);

      return {
        flat,
        maintenanceDue: {
          records: maintenanceDue,
          total: totalMaintenanceDue,
          count: maintenanceDue.length
        },
        rentDue: {
          records: rentDue,
          total: totalRentDue,
          count: rentDue.length
        }
      };
    } catch (error) {
      console.error('Tenant dashboard service error:', error);
      throw new Error('Failed to load tenant dashboard data');
    }
  }

  // Get maintenance statistics
  static async getMaintenanceStats(societyIds) {
    try {
      const [totalMaintenance, paidMaintenance, unpaidMaintenance] = await Promise.all([
        Maintenance.countDocuments({ society: { $in: societyIds } }),
        Maintenance.countDocuments({ 
          society: { $in: societyIds }, 
          status: 'paid' 
        }),
        Maintenance.countDocuments({ 
          society: { $in: societyIds }, 
          status: 'unpaid' 
        })
      ]);

      const totalAmount = await Maintenance.aggregate([
        { $match: { society: { $in: societyIds } } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]);

      const paidAmount = await Maintenance.aggregate([
        { $match: { society: { $in: societyIds }, status: 'paid' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]);

      return {
        total: totalMaintenance,
        paid: paidMaintenance,
        unpaid: unpaidMaintenance,
        totalAmount: totalAmount[0]?.total || 0,
        paidAmount: paidAmount[0]?.total || 0,
        outstandingAmount: (totalAmount[0]?.total || 0) - (paidAmount[0]?.total || 0)
      };
    } catch (error) {
      console.error('Maintenance stats error:', error);
      return {
        total: 0,
        paid: 0,
        unpaid: 0,
        totalAmount: 0,
        paidAmount: 0,
        outstandingAmount: 0
      };
    }
  }

  // Get rent statistics
  static async getRentStats(societyIds) {
    try {
      const [totalRent, paidRent, unpaidRent] = await Promise.all([
        Rent.countDocuments({ society: { $in: societyIds } }),
        Rent.countDocuments({ 
          society: { $in: societyIds }, 
          status: 'paid' 
        }),
        Rent.countDocuments({ 
          society: { $in: societyIds }, 
          status: 'unpaid' 
        })
      ]);

      const totalAmount = await Rent.aggregate([
        { $match: { society: { $in: societyIds } } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]);

      const paidAmount = await Rent.aggregate([
        { $match: { society: { $in: societyIds }, status: 'paid' } },
        { $group: { _id: null, total: { $sum: '$amount' } } }
      ]);

      return {
        total: totalRent,
        paid: paidRent,
        unpaid: unpaidRent,
        totalAmount: totalAmount[0]?.total || 0,
        paidAmount: paidAmount[0]?.total || 0,
        outstandingAmount: (totalAmount[0]?.total || 0) - (paidAmount[0]?.total || 0)
      };
    } catch (error) {
      console.error('Rent stats error:', error);
      return {
        total: 0,
        paid: 0,
        unpaid: 0,
        totalAmount: 0,
        paidAmount: 0,
        outstandingAmount: 0
      };
    }
  }

  // Get complaint statistics
  static async getComplaintStats(societyIds) {
    try {
      const [totalComplaints, openComplaints, resolvedComplaints] = await Promise.all([
        Complaint.countDocuments({ society: { $in: societyIds } }),
        Complaint.countDocuments({ 
          society: { $in: societyIds }, 
          status: { $in: ['open', 'in-progress'] } 
        }),
        Complaint.countDocuments({ 
          society: { $in: societyIds }, 
          status: 'resolved' 
        })
      ]);

      return {
        total: totalComplaints,
        open: openComplaints,
        resolved: resolvedComplaints,
        pending: totalComplaints - openComplaints - resolvedComplaints
      };
    } catch (error) {
      console.error('Complaint stats error:', error);
      return {
        total: 0,
        open: 0,
        resolved: 0,
        pending: 0
      };
    }
  }
}

module.exports = DashboardService;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: dashboardService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ flatService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: flatService.js ---
// services/flatService.js
const Flat = require('../models/Flat');
const User = require('../models/User');
const Building = require('../models/Building');
const { NotFoundError, ConflictError, BadRequestError } = require('../utils/errors');

class FlatService {
  // Create flats for a building
  static async createFlatsForBuilding(buildingId, totalFlats, adminId) {
    // Validate input parameters
    if (!buildingId || !totalFlats || totalFlats <= 0) {
      throw new Error('Invalid parameters: buildingId and totalFlats (positive number) are required');
    }

    const building = await Building.findById(buildingId);
    if (!building) {
      throw new Error('Building not found');
    }

    // Check if flats already exist for this building
    const existingFlats = await Flat.countDocuments({ building: buildingId });
    if (existingFlats > 0) {
      throw new Error('Flats already exist for this building');
    }

    const flats = [];
    const flatsPerFloor = Math.ceil(totalFlats / building.totalFloors);

    for (let floor = 1; floor <= building.totalFloors; floor++) {
      const flatsOnThisFloor = Math.min(flatsPerFloor, totalFlats - flats.length);
      
      for (let flatNum = 1; flatNum <= flatsOnThisFloor; flatNum++) {
        const flatNumber = `${floor}${String(flatNum).padStart(2, '0')}`;
        
        flats.push({
          flatNumber,
          floor,
          building: buildingId,
          society: building.society,
          owner: adminId, // Default owner is the admin who created it
          occupancyStatus: 'vacant'
        });
      }
    }

    const createdFlats = await Flat.insertMany(flats);

    // ‚úÖ FIXED: Update admin's society if not set
    const admin = await User.findById(adminId);
    if (admin && !admin.society) {
      admin.society = building.society;
      await admin.save();
    }

    return createdFlats;
  }

  static async assignOwnerToFlat(flatId, ownerId) {
    if (!flatId || !ownerId) {
      throw new BadRequestError('Flat ID and Owner ID are required');
    }

    const flat = await Flat.findById(flatId);
    if (!flat) {
      throw new NotFoundError('Flat not found');
    }

    const owner = await User.findById(ownerId);
    if (!owner) {
      throw new NotFoundError('Owner not found');
    }

    // ‚úÖ FIXED: Check if owner is already assigned to another flat
    const existingOwnerFlat = await Flat.findOne({ owner: ownerId });
    if (existingOwnerFlat) {
      throw new ConflictError('User is already assigned as owner to another flat');
    }

    flat.owner = ownerId;
    await flat.save();
    return flat;
  }

  // Remove owner from flat
  static async removeOwnerFromFlat(flatId) {
    if (!flatId) {
      throw new Error('Flat ID is required');
    }

    const flat = await Flat.findById(flatId);
    if (!flat) {
      throw new Error('Flat not found');
    }

    flat.owner = null;
    await flat.save();

    return flat;
  }

  static async assignTenantToFlat(flatId, tenantId) {
    if (!flatId || !tenantId) {
      throw new BadRequestError('Flat ID and Tenant ID are required');
    }

    const flat = await Flat.findById(flatId);
    if (!flat) {
      throw new NotFoundError('Flat not found');
    }

    const tenant = await User.findById(tenantId);
    if (!tenant) {
      throw new NotFoundError('Tenant not found');
    }

    // ‚úÖ FIXED: Check if tenant is already assigned to another flat
    const existingTenantFlat = await Flat.findOne({ tenant: tenantId });
    if (existingTenantFlat) {
      throw new ConflictError('User is already assigned as tenant to another flat');
    }

    flat.tenant = tenantId;
    await flat.save();
    return flat;
  }

  // Remove tenant from flat
  static async removeTenantFromFlat(flatId, ownerId) {
    if (!flatId || !ownerId) {
      throw new Error('Flat ID and Owner ID are required');
    }

    const flat = await Flat.findOne({ _id: flatId, owner: ownerId });
    if (!flat) {
      throw new Error('Unauthorized or flat not found');
    }

    flat.tenant = null;
    flat.isRented = false;
    flat.occupancyStatus = 'vacant';
    await flat.save();

    return flat;
  }

  // Get flats by owner
  static async getFlatsByOwner(ownerId) {
    if (!ownerId) {
      throw new Error('Owner ID is required');
    }

    const flats = await Flat.find({ owner: ownerId })
      .populate('building', 'name')
      .populate('society', 'name')
      .populate('tenant', 'name email phone')
      .sort({ createdAt: -1 });

    return flats;
  }

  // Get flat by ID with full details
  static async getFlatById(flatId) {
    if (!flatId) {
      throw new Error('Flat ID is required');
    }

    const flat = await Flat.findById(flatId)
      .populate('owner', 'name email phone')
      .populate('tenant', 'name email phone')
      .populate('building', 'name')
      .populate('society', 'name');

    if (!flat) {
      throw new Error('Flat not found');
    }

    return flat;
  }

  // Get flats by building
  static async getFlatsByBuilding(buildingId, pagination = {}) {
    if (!buildingId) {
      throw new Error('Building ID is required');
    }

    const { page = 1, limit = 10, skip = 0 } = pagination;

    const [flats, total] = await Promise.all([
      Flat.find({ building: buildingId })
        .populate('owner', 'name email')
        .populate('tenant', 'name email')
        .skip(skip)
        .limit(limit)
        .sort({ flatNumber: 1 }),
      Flat.countDocuments({ building: buildingId })
    ]);

    return {
      flats,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get user's assigned flat
  static async getUserFlat(userId) {
    if (!userId) {
      throw new Error('User ID is required');
    }

    const flat = await Flat.findOne({
      $or: [
        { owner: userId },
        { tenant: userId }
      ]
    })
    .populate('building', 'name')
    .populate('society', 'name')
    .populate('owner', 'name email phone')
    .populate('tenant', 'name email phone');

    if (!flat) {
      throw new Error('No flat assigned to user');
    }

    return flat;
  }
}

module.exports = FlatService;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: flatService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ maintenanceService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: maintenanceService.js ---
const Maintenance = require('../models/Maintenance');
const Flat = require('../models/Flat');
const Society = require('../models/Society');
const { NotFoundError, ConflictError, BadRequestError } = require('../utils/errors');

class MaintenanceService {
  static async generateMaintenanceForMonth(societyId, billingMonth, adminId) {
    // Validate society exists
    const society = await Society.findById(societyId);
    if (!society) {
      throw new NotFoundError('Society not found');
    }

    // Check for existing maintenance records for this month
    const existing = await Maintenance.findOne({ 
      society: societyId, 
      billingMonth 
    });
    
    if (existing) {
      throw new ConflictError('Maintenance already generated for this month');
    }

    // Find all flats with owners in this society
    const flats = await Flat.find({ 
      society: societyId, 
      owner: { $ne: null } 
    });
    
    if (flats.length === 0) {
      throw new BadRequestError('No owned flats found in this society to generate maintenance for');
    }

    // Create maintenance records for each flat
    const records = flats.map(flat => ({
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      billingMonth,
      amount: society.maintenancePolicy.amountPerFlat,
      generatedBy: adminId,
      status: 'unpaid',
      dueDate: new Date(new Date(billingMonth).getFullYear(), new Date(billingMonth).getMonth() + 1, 0), // Last day of billing month
    }));

    return await Maintenance.insertMany(records);
  }

  static async getMaintenanceStatus(societyId, billingMonth) {
    const maintenance = await Maintenance.find({ 
      society: societyId, 
      billingMonth 
    }).populate('flat building');
    
    return maintenance;
  }
}

module.exports = MaintenanceService; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: maintenanceService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownershipService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownershipService.js ---
// services/ownershipService.js
const OwnershipRequest = require('../models/OwnershipRequest');
const Flat = require('../models/Flat');
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail'); // ‚úÖ ADDED: Import sendEmail utility
const crypto = require('crypto');

// Generate a secure random password
const generateSecurePassword = () => {
  return crypto.randomBytes(8).toString('hex'); // 16 character hex string
};

exports.reviewOwnershipRequest = async ({ requestId, status, note, reviewerId }) => {
  const request = await OwnershipRequest.findById(requestId);
  if (!request) throw new Error('Ownership request not found');

  request.status = status;
  request.adminNote = note;
  request.reviewedBy = reviewerId;
  request.reviewedOn = new Date();
  await request.save();

  if (status === 'approved') {
    // Check if a user with the new owner's email already exists
    let newOwner = await User.findOne({ email: request.newOwnerEmail });
    
    if (!newOwner) {
      // ‚úÖ FIXED: Generate secure random password instead of hardcoded one
      const securePassword = generateSecurePassword();
      
      // Create a new user with the details from the request
      newOwner = await User.create({
        name: request.newOwnerName,
        email: request.newOwnerEmail,
        phone: request.newOwnerPhone,
        role: 'owner',
        society: flat.society,
        password: securePassword, // Secure random password
        // ‚úÖ REMOVED: isActive: true - let schema handle default
      });

      // ‚úÖ FIXED: Send email notification to new owner
      const subject = 'Your New Housing Society Account';
      const message = `Welcome! Your account has been created successfully.\n\nYour temporary password is: ${securePassword}\n\nPlease log in and change your password immediately for security.\n\nBest regards,\nHousing Society Management Team`;
      
      const emailResult = await sendEmail(newOwner.email, subject, message);
      if (!emailResult.success) {
        console.warn(`‚ö†Ô∏è Failed to send email to ${newOwner.email}: ${emailResult.error}`);
      } else {
        console.log(`‚úÖ Email sent successfully to ${newOwner.email}`);
      }
    } else {
      // Update existing user's details if needed
      newOwner.name = request.newOwnerName;
      newOwner.phone = request.newOwnerPhone;
      newOwner.role = 'owner';
      await newOwner.save();
    }

    // Update the flat's owner to the new owner
    await Flat.findByIdAndUpdate(request.flat, { owner: newOwner._id });
  }

  return request;
};

‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownershipService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ paymentService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: paymentService.js ---
// services/paymentService.js
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');
const Flat = require('../models/Flat');

class PaymentService {
  // Validate payment authorization
  static async validatePaymentAuthorization(userId, userRole, flatId) {
    const flat = await Flat.findById(flatId);
    if (!flat) {
      throw new Error('Flat not found');
    }

    // ‚úÖ FIXED: Remove restrictive condition that prevented owners from paying when they have tenants
    const isValid = (userRole === 'owner' && flat.owner.toString() === userId) ||
                    (userRole === 'tenant' && flat.tenant.toString() === userId);

    if (!isValid) {
      throw new Error('You are not authorized to make payments for this flat');
    }

    return flat;
  }

  // Pay maintenance
  static async payMaintenance(maintenanceId, userId, userRole, paymentDetails) {
    const maintenance = await Maintenance.findById(maintenanceId);
    if (!maintenance) {
      throw new Error('Maintenance record not found');
    }

    // Validate authorization
    await this.validatePaymentAuthorization(userId, userRole, maintenance.flat);

    if (maintenance.status === 'paid') {
      throw new Error('Maintenance is already paid');
    }

    // Update maintenance record
    maintenance.status = 'paid';
    maintenance.paidOn = new Date();
    maintenance.paymentMethod = paymentDetails.paymentMethod;
    maintenance.transactionId = paymentDetails.transactionId;
    maintenance.paidBy = userId;

    await maintenance.save();

    return maintenance;
  }

  // Pay rent
  static async payRent(rentId, userId, userRole, paymentDetails) {
    const rent = await Rent.findById(rentId);
    if (!rent) {
      throw new Error('Rent record not found');
    }

    // Validate authorization
    await this.validatePaymentAuthorization(userId, userRole, rent.flat);

    if (rent.status === 'paid') {
      throw new Error('Rent is already paid');
    }

    // Update rent record
    rent.status = 'paid';
    rent.paidOn = new Date();
    rent.paymentMethod = paymentDetails.paymentMethod;
    rent.transactionId = paymentDetails.transactionId;
    rent.paidBy = userId;

    await rent.save();

    return rent;
  }

  // Get payment history for a user
  static async getPaymentHistory(userId, userRole, filters = {}) {
    const { page = 1, limit = 10, type } = filters;
    const skip = (page - 1) * limit;

    let query = {};
    if (type === 'maintenance') {
      query = { paidBy: userId };
    } else if (type === 'rent') {
      query = { paidBy: userId };
    } else {
      // Get both maintenance and rent payments
      const [maintenancePayments, rentPayments] = await Promise.all([
        Maintenance.find({ paidBy: userId }).populate('flat building society'),
        Rent.find({ paidBy: userId }).populate('flat building society')
      ]);

      return {
        maintenance: maintenancePayments,
        rent: rentPayments,
        total: maintenancePayments.length + rentPayments.length
      };
    }

    const payments = await Maintenance.find(query)
      .populate('flat building society')
      .skip(skip)
      .limit(limit)
      .sort({ paidOn: -1 });

    const total = await Maintenance.countDocuments(query);

    return {
      payments,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get overdue payments
  static async getOverduePayments(userId, userRole) {
    const currentDate = new Date();

    // Get user's flats
    const userFlats = await Flat.find({
      $or: [
        { owner: userId },
        { tenant: userId }
      ]
    });

    const flatIds = userFlats.map(flat => flat._id);

    // Get overdue maintenance
    const overdueMaintenance = await Maintenance.find({
      flat: { $in: flatIds },
      status: 'unpaid',
      dueDate: { $lt: currentDate }
    }).populate('flat building society');

    // Get overdue rent
    const overdueRent = await Rent.find({
      flat: { $in: flatIds },
      status: 'unpaid',
      dueDate: { $lt: currentDate }
    }).populate('flat building society');

    return {
      maintenance: overdueMaintenance,
      rent: overdueRent,
      total: overdueMaintenance.length + overdueRent.length
    };
  }

  // Validate payment details
  static validatePaymentDetails(paymentDetails) {
    const { paymentMethod, transactionId } = paymentDetails;

    if (!paymentMethod || !['cash', 'online', 'bank-transfer', 'upi'].includes(paymentMethod)) {
      throw new Error('Invalid payment method');
    }

    if (!transactionId || transactionId.trim().length === 0) {
      throw new Error('Transaction ID is required');
    }

    return true;
  }
}

module.exports = PaymentService;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: paymentService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ rentService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: rentService.js ---
const Rent = require('../models/Rent');
const Flat = require('../models/Flat');
const User = require('../models/User');

class RentService {
  // Calculate due date properly accounting for different month lengths
  static calculateDueDate(billingMonth) {
    const [year, month] = billingMonth.split('-').map(Number);
    const firstDayOfMonth = new Date(year, month - 1, 1);
    const lastDayOfMonth = new Date(year, month, 0);
    
    // Due date is the last day of the month
    return lastDayOfMonth;
  }

  // Generate rent for a specific month
  static async generateRentForMonth(billingMonth, societyId = null) {
    // Find all rented flats
    const filter = { isRented: true };
    if (societyId) filter.society = societyId;

    const rentedFlats = await Flat.find(filter)
      .populate('owner', 'name email')
      .populate('tenant', 'name email')
      .populate('society', 'name');

    if (rentedFlats.length === 0) {
      throw new Error('No rented flats found');
    }

    const rentRecords = [];
    const existingRentRecords = await Rent.find({ billingMonth });
    const existingFlatIds = existingRentRecords.map(rent => rent.flat.toString());

    for (const flat of rentedFlats) {
      // Skip if rent record already exists for this flat and month
      if (existingFlatIds.includes(flat._id.toString())) {
        continue;
      }

      // Get rent amount from flat or use default
      const rentAmount = flat.rentAmount || 0;

      if (rentAmount > 0) {
        // ‚úÖ FIXED: Use proper date calculation
        const dueDate = this.calculateDueDate(billingMonth);

        rentRecords.push({
          flat: flat._id,
          building: flat.building,
          society: flat.society,
          owner: flat.owner,
          tenant: flat.tenant,
          billingMonth,
          amount: rentAmount,
          status: 'unpaid',
          dueDate: dueDate
        });
      }
    }

    if (rentRecords.length === 0) {
      throw new Error('No valid rent records to generate');
    }

    const createdRentRecords = await Rent.insertMany(rentRecords);

    return {
      message: `${createdRentRecords.length} rent records generated for ${billingMonth}`,
      count: createdRentRecords.length,
      records: createdRentRecords
    };
  }

  // Get rent history with filtering
  static async getRentHistory(filters = {}, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;
    const { status, society, flat, tenant, owner } = filters;

    const filter = {};
    if (status) filter.status = status;
    if (society) filter.society = society;
    if (flat) filter.flat = flat;
    if (tenant) filter.tenant = tenant;
    if (owner) filter.owner = owner;

    const [rents, total] = await Promise.all([
      Rent.find(filter)
        .populate('flat', 'flatNumber')
        .populate('building', 'name')
        .populate('society', 'name')
        .populate('owner', 'name email')
        .populate('tenant', 'name email')
        .skip(skip)
        .limit(limit)
        .sort({ billingMonth: -1, dueDate: -1 }),
      Rent.countDocuments(filter)
    ]);

    return {
      rents,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get rent by ID
  static async getRentById(rentId) {
    const rent = await Rent.findById(rentId)
      .populate('flat', 'flatNumber')
      .populate('building', 'name')
      .populate('society', 'name')
      .populate('owner', 'name email')
      .populate('tenant', 'name email');

    if (!rent) {
      throw new Error('Rent record not found');
    }

    return rent;
  }

  // Update rent status
  static async updateRentStatus(rentId, status, paymentDetails = {}) {
    const rent = await Rent.findById(rentId);
    if (!rent) {
      throw new Error('Rent record not found');
    }

    rent.status = status;
    if (status === 'paid') {
      rent.paidOn = new Date();
      rent.paymentMethod = paymentDetails.paymentMethod;
      rent.transactionId = paymentDetails.transactionId;
    }

    await rent.save();

    return rent;
  }

  // Get overdue rents
  static async getOverdueRents(societyId = null) {
    const filter = {
      status: { $in: ['unpaid', 'overdue'] },
      dueDate: { $lt: new Date() }
    };

    if (societyId) filter.society = societyId;

    const overdueRents = await Rent.find(filter)
      .populate('flat', 'flatNumber')
      .populate('building', 'name')
      .populate('society', 'name')
      .populate('owner', 'name email')
      .populate('tenant', 'name email')
      .sort({ dueDate: 1 });

    return overdueRents;
  }

  // Get rent statistics
  static async getRentStatistics(societyId = null) {
    const filter = {};
    if (societyId) filter.society = societyId;

    const [totalRents, paidRents, unpaidRents, overdueRents] = await Promise.all([
      Rent.countDocuments(filter),
      Rent.countDocuments({ ...filter, status: 'paid' }),
      Rent.countDocuments({ ...filter, status: 'unpaid' }),
      Rent.countDocuments({ ...filter, status: 'overdue' })
    ]);

    const totalAmount = await Rent.aggregate([
      { $match: filter },
      { $group: { _id: null, total: { $sum: '$amount' } } }
    ]);

    const paidAmount = await Rent.aggregate([
      { $match: { ...filter, status: 'paid' } },
      { $group: { _id: null, total: { $sum: '$amount' } } }
    ]);

    return {
      total: totalRents,
      paid: paidRents,
      unpaid: unpaidRents,
      overdue: overdueRents,
      totalAmount: totalAmount[0]?.total || 0,
      paidAmount: paidAmount[0]?.total || 0,
      outstandingAmount: (totalAmount[0]?.total || 0) - (paidAmount[0]?.total || 0)
    };
  }

  // Get current month rent for a user
  static async getCurrentMonthRent(userId, userRole) {
    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM

    const filter = {
      billingMonth: currentMonth
    };

    if (userRole === 'tenant') {
      filter.tenant = userId;
    } else if (userRole === 'owner') {
      filter.owner = userId;
    }

    const rent = await Rent.findOne(filter)
      .populate('flat', 'flatNumber')
      .populate('building', 'name')
      .populate('society', 'name')
      .populate('owner', 'name email')
      .populate('tenant', 'name email');

    if (!rent) {
      throw new Error('No rent record found for this month');
    }

    return rent;
  }
}

module.exports = RentService; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: rentService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ societyService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: societyService.js ---
const Society = require('../models/Society');
const Building = require('../models/Building');
const Flat = require('../models/Flat');

class SocietyService {
  // Create a new society
  static async createSociety(societyData, adminId) {
    const { name, registrationNumber, address, maintenancePolicy } = societyData;

    // Check for existing society with same registration number
    const existing = await Society.findOne({ registrationNumber });
    if (existing) {
      throw new Error('Society with this registration number already exists');
    }
    
    // Parse address string if it's a string
    let addressObj = address;
    if (typeof address === 'string') {
      const addressParts = address.split(',').map(part => part.trim());
      addressObj = {
        street: addressParts[0] || '',
        city: addressParts[1] || '',
        state: addressParts[2] || '',
        pincode: addressParts[3] || ''
      };
    }
    
    // Parse maintenance policy if it's a string
    let maintenancePolicyObj = maintenancePolicy;
    if (typeof maintenancePolicy === 'string') {
      maintenancePolicyObj = {
        frequency: 'monthly',
        amountPerFlat: 1000
      };
    }

    const society = await Society.create({
      name,
      registrationNumber,
      address: addressObj,
      maintenancePolicy: maintenancePolicyObj,
      admin: adminId
    });
    
    return society;
  }

  // Get societies managed by an admin
  static async getSocietiesByAdmin(adminId, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;

    const [societies, total] = await Promise.all([
      Society.find({ admin: adminId })
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      Society.countDocuments({ admin: adminId })
    ]);

    console.log('DEBUG societies:', societies);
    console.log('DEBUG total:', total);

    return {
      societies,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Update a society
  static async updateSociety(societyId, updateData, adminId) {
    const society = await Society.findOneAndUpdate(
      { _id: societyId, admin: adminId },
      updateData,
      { new: true, runValidators: true }
    );

    if (!society) {
      throw new Error('Society not found or you do not have permission to update it');
    }

    return society;
  }

  // Delete a society and all associated data
  static async deleteSociety(societyId, adminId) {
    const society = await Society.findOneAndDelete({ _id: societyId, admin: adminId });
    
    if (!society) {
      throw new Error('Society not found or you do not have permission to delete it');
    }

    // Delete associated buildings and flats
    await Building.deleteMany({ society: societyId });
    await Flat.deleteMany({ society: societyId });

    return society;
  }

  // Get society by ID
  static async getSocietyById(societyId) {
    const society = await Society.findById(societyId);
    if (!society) {
      throw new Error('Society not found');
    }
    return society;
  }

  // Add note to society
  static async addSocietyNote(societyId, note, adminId) {
    const society = await Society.findOneAndUpdate(
      { _id: societyId, admin: adminId },
      { adminNote: note },
      { new: true }
    );

    if (!society) {
      throw new Error('Society not found or you do not have permission to update it');
    }

    return society;
  }
}

module.exports = SocietyService;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: societyService.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ userService.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: userService.js ---
const User = require('../models/User');

class UserService {
  // Get all users with filtering and pagination
  static async getAllUsers(filters = {}, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;
    const { role, isActive, society } = filters;

    const filter = {};
    if (role) filter.role = role;
    if (isActive !== undefined) filter.isActive = isActive;
    if (society) filter.society = society;

    const [users, total] = await Promise.all([
      User.find(filter)
        .select('-password')
        .populate('society', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      User.countDocuments(filter)
    ]);

    return {
      users,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get user by ID
  static async getUserById(userId) {
    const user = await User.findById(userId)
      .select('-password')
      .populate('society', 'name');

    if (!user) {
      throw new Error('User not found');
    }

    return user;
  }

  // Update user details
  static async updateUser(userId, updateData) {
    // Remove password from update data if present
    const { password, ...safeUpdateData } = updateData;

    const user = await User.findByIdAndUpdate(
      userId,
      safeUpdateData,
      { new: true, runValidators: true }
    ).select('-password');

    if (!user) {
      throw new Error('User not found');
    }

    return user;
  }

  // Deactivate/Activate user
  static async toggleUserStatus(userId) {
    const user = await User.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    user.isActive = !user.isActive;
    await user.save();

    return user;
  }

  // Get users by role
  static async getUsersByRole(role, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;

    const [users, total] = await Promise.all([
      User.find({ role })
        .select('-password')
        .populate('society', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      User.countDocuments({ role })
    ]);

    return {
      users,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get users by society
  static async getUsersBySociety(societyId, pagination = {}) {
    const { page = 1, limit = 10, skip = 0 } = pagination;

    const [users, total] = await Promise.all([
      User.find({ society: societyId })
        .select('-password')
        .populate('society', 'name')
        .skip(skip)
        .limit(limit)
        .sort({ createdAt: -1 }),
      User.countDocuments({ society: societyId })
    ]);

    return {
      users,
      total,
      page,
      limit,
      pages: Math.ceil(total / limit)
    };
  }

  // Get user statistics
  static async getUserStatistics() {
    const [totalUsers, usersByRole, activeUsers] = await Promise.all([
      User.countDocuments(),
      User.aggregate([
        {
          $group: {
            _id: '$role',
            count: { $sum: 1 }
          }
        }
      ]),
      User.countDocuments({ isActive: true })
    ]);

    const roleStats = usersByRole.reduce((acc, stat) => {
      acc[stat._id] = stat.count;
      return acc;
    }, {});

    return {
      total: totalUsers,
      active: activeUsers,
      inactive: totalUsers - activeUsers,
      byRole: roleStats
    };
  }
}

module.exports = UserService; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: userService.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ uploads/
‚îÇ   ‚îÇ   ‚îú‚îÄ utils/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ errors.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: errors.js ---
// Custom error classes for better error handling
class NotFoundError extends Error {
  constructor(message = 'Resource not found') {
    super(message);
    this.name = 'NotFoundError';
    this.statusCode = 404;
  }
}

class UnauthorizedError extends Error {
  constructor(message = 'Unauthorized access') {
    super(message);
    this.name = 'UnauthorizedError';
    this.statusCode = 401;
  }
}

class ForbiddenError extends Error {
  constructor(message = 'Access forbidden') {
    super(message);
    this.name = 'ForbiddenError';
    this.statusCode = 403;
  }
}

class ValidationError extends Error {
  constructor(message = 'Validation failed') {
    super(message);
    this.name = 'ValidationError';
    this.statusCode = 400;
  }
}

class ConflictError extends Error {
  constructor(message = 'Resource conflict') {
    super(message);
    this.name = 'ConflictError';
    this.statusCode = 409;
  }
}

class BadRequestError extends Error {
  constructor(message = 'Bad request') {
    super(message);
    this.name = 'BadRequestError';
    this.statusCode = 400;
  }
}

module.exports = {
  NotFoundError,
  UnauthorizedError,
  ForbiddenError,
  ValidationError,
  ConflictError,
  BadRequestError
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: errors.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ generateToken.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: generateToken.js ---
const jwt = require('jsonwebtoken');

const generateToken = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  return token;
};

module.exports = generateToken;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: generateToken.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ logger.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: logger.js ---
// utils/logger.js
const morgan = require('morgan');
const fs = require('fs');
const path = require('path');

// Create logs directory if it doesn't exist
const logsDir = path.join(__dirname, '../logs');
if (!fs.existsSync(logsDir)) {
  fs.mkdirSync(logsDir, { recursive: true });
}

// Morgan middleware for HTTP request logging
const morganLogger = morgan(':method :url :status :res[content-length] - :response-time ms');

// File-based logger for application logs
class Logger {
  constructor() {
    this.logFile = path.join(logsDir, 'app.log');
  }

  info(message, data = null) {
    const logEntry = {
      level: 'INFO',
      timestamp: new Date().toISOString(),
      message,
      data
    };
    this.writeLog(logEntry);
  }

  error(message, error = null) {
    const logEntry = {
      level: 'ERROR',
      timestamp: new Date().toISOString(),
      message,
      error: error ? error.stack : null
    };
    this.writeLog(logEntry);
  }

  warn(message, data = null) {
    const logEntry = {
      level: 'WARN',
      timestamp: new Date().toISOString(),
      message,
      data
    };
    this.writeLog(logEntry);
  }

  debug(message, data = null) {
    if (process.env.NODE_ENV === 'development') {
      const logEntry = {
        level: 'DEBUG',
        timestamp: new Date().toISOString(),
        message,
        data
      };
      this.writeLog(logEntry);
    }
  }

  writeLog(logEntry) {
    const logString = JSON.stringify(logEntry) + '\n';
    fs.appendFileSync(this.logFile, logString);
    
    // Also log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.log(`[${logEntry.level}] ${logEntry.message}`);
    }
  }
}

const logger = new Logger();

module.exports = { morganLogger, logger };

‚îÇ   ‚îÇ   ‚îÇ   # --- End: logger.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ pagination.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: pagination.js ---

exports.paginateQuery = (req) => {
    const page = Math.max(1, parseInt(req.query.page) || 1);
    const limit = Math.max(1, parseInt(req.query.limit) || 10);
    const skip = (page - 1) * limit;
    return { page, limit, skip };
  }; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: pagination.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ responseFormatter.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: responseFormatter.js ---
// utils/responseFormatter.js

const formatResponse = ({ success = true, message = '', data = null, statusCode = 200 }) => {
    return {
      success,
      message,
      data,
      statusCode
    };
  };
  
  module.exports = formatResponse;
‚îÇ   ‚îÇ   ‚îÇ   # --- End: responseFormatter.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ sendEmail.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: sendEmail.js ---
const nodemailer = require('nodemailer');

const sendEmail = async (to, subject, text) => {
  try {
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
      console.warn('‚ö†Ô∏è Missing EMAIL credentials in .env');
      return { success: false, message: 'Email service not configured' };
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    const result = await transporter.sendMail({ 
      from: process.env.EMAIL_USER, 
      to, 
      subject, 
      text 
    });

    return { success: true, messageId: result.messageId };
  } catch (error) {
    console.error('‚ùå Failed to send email:', error.message);
    return { success: false, error: error.message };
  }
};

module.exports = sendEmail;

‚îÇ   ‚îÇ   ‚îÇ   # --- End: sendEmail.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ validateEnv.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: validateEnv.js ---
// utils/validateEnv.js
const required = [
  'PORT', 'MONGO_URI', 'JWT_SECRET'
];

const productionRequired = [
  'EMAIL_USER', 'EMAIL_PASS', 'CLIENT_URL'
];

const optional = [
  'JWT_EXPIRES_IN', 'NODE_ENV'
];

module.exports = function validateEnv() {
  // Check required variables
  required.forEach(key => {
    if (!process.env[key]) {
      throw new Error(`‚ùå Missing required environment variable: ${key}`);
    }
  });

  // ‚úÖ IMPROVED: Only require email credentials in production
  if (process.env.NODE_ENV === 'production') {
    productionRequired.forEach(key => {
      if (!process.env[key]) {
        throw new Error(`‚ùå Missing required environment variable for production: ${key}`);
      }
    });
  }
  
  // Set defaults for optional variables
  if (!process.env.JWT_EXPIRES_IN) {
    process.env.JWT_EXPIRES_IN = '7d';
  }
  
  if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = 'development';
  }

  // ‚úÖ ADDED: Warn about missing optional variables in development
  if (process.env.NODE_ENV === 'development') {
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
      console.warn('‚ö†Ô∏è  EMAIL credentials not set - email functionality will be disabled');
    }
    if (!process.env.CLIENT_URL) {
      console.warn('‚ö†Ô∏è  CLIENT_URL not set - CORS might need adjustment');
    }
  }
};
  
‚îÇ   ‚îÇ   ‚îÇ   # --- End: validateEnv.js ---

‚îÇ   ‚îÇ   ‚îú‚îÄ validators/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ adminValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: adminValidator.js ---
const { body, param, query } = require('express-validator');

// Society validators
const societyCreateValidator = [
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Society name must be between 2 and 100 characters'),
  body('registrationNumber')
    .trim()
    .isLength({ min: 5, max: 50 })
    .withMessage('Registration number must be between 5 and 50 characters'),
  body('address')
    .trim()
    .isLength({ min: 10, max: 500 })
    .withMessage('Address must be between 10 and 500 characters'),
  body('maintenancePolicy')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Maintenance policy must not exceed 1000 characters')
];

const societyUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid society ID'),
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Society name must be between 2 and 100 characters'),
  body('address')
    .optional()
    .trim()
    .isLength({ min: 10, max: 500 })
    .withMessage('Address must be between 10 and 500 characters'),
  body('maintenancePolicy')
    .optional()
    .trim()
    .isLength({ max: 1000 })
    .withMessage('Maintenance policy must not exceed 1000 characters')
];

// Building validators
const buildingCreateValidator = [
  body('societyId')
    .isMongoId()
    .withMessage('Invalid society ID'),
  body('name')
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Building name must be between 2 and 100 characters'),
  body('totalFloors')
    .isInt({ min: 1, max: 100 })
    .withMessage('Total floors must be between 1 and 100'),
  body('totalFlats')
    .isInt({ min: 1, max: 1000 })
    .withMessage('Total flats must be between 1 and 1000'),
  body('addressLabel')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Address label must not exceed 200 characters')
];

const buildingUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid building ID'),
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Building name must be between 2 and 100 characters'),
  body('totalFloors')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Total floors must be between 1 and 100'),
  body('totalFlats')
    .optional()
    .isInt({ min: 1, max: 1000 })
    .withMessage('Total flats must be between 1 and 1000'),
  body('addressLabel')
    .optional()
    .trim()
    .isLength({ max: 200 })
    .withMessage('Address label must not exceed 200 characters')
];

// Flat validators
const flatCreateValidator = [
  body('buildingId')
    .isMongoId()
    .withMessage('Invalid building ID'),
  body('totalFlats')
    .isInt({ min: 1, max: 1000 })
    .withMessage('Total flats must be between 1 and 1000')
];

const flatAssignOwnerValidator = [
  param('flatId')
    .isMongoId()
    .withMessage('Invalid flat ID'),
  body('ownerId')
    .isMongoId()
    .withMessage('Invalid owner ID')
];

// Complaint validators
const complaintStatusUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid complaint ID'),
  body('status')
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid complaint status'),
  body('adminNote')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Admin note must not exceed 500 characters')
];

// Announcement validators
const announcementCreateValidator = [
  body('title')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Announcement title must be between 5 and 200 characters'),
  body('content')
    .trim()
    .isLength({ min: 10, max: 2000 })
    .withMessage('Announcement content must be between 10 and 2000 characters'),
  body('societyId')
    .isMongoId()
    .withMessage('Invalid society ID'),
  body('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Invalid priority level')
];

// Ownership request validators
const ownershipRequestReviewValidator = [
  body('requestId')
    .isMongoId()
    .withMessage('Invalid ownership request ID'),
  body('status')
    .isIn(['approved', 'rejected'])
    .withMessage('Invalid status'),
  body('note')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Admin note must not exceed 500 characters')
];

// Reminder validators
const reminderValidator = [
  param('userID')
    .isMongoId()
    .withMessage('Invalid user ID'),
  body('subject')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Subject must be between 5 and 200 characters'),
  body('message')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Message must be between 10 and 1000 characters')
];

// Society note validator
const societyNoteValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid society ID'),
  body('note')
    .trim()
    .isLength({ min: 1, max: 1000 })
    .withMessage('Note must be between 1 and 1000 characters')
];

// Query validators
const complaintsQueryValidator = [
  query('status')
    .optional()
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid status filter'),
  query('society')
    .optional()
    .isMongoId()
    .withMessage('Invalid society ID'),
  query('category')
    .optional()
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid category filter'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];

// User update validator
const userUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid user ID'),
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Name must be between 2 and 100 characters'),
  body('email')
    .optional()
    .isEmail()
    .withMessage('Invalid email format'),
  body('phone')
    .optional()
    .matches(/^\+?[\d\s\-\(\)]+$/)
    .withMessage('Invalid phone number format'),
  body('role')
    .optional()
    .isIn(['admin', 'owner', 'tenant'])
    .withMessage('Invalid role'),
  body('isActive')
    .optional()
    .isBoolean()
    .withMessage('isActive must be a boolean')
];

module.exports = {
  societyCreateValidator,
  societyUpdateValidator,
  buildingCreateValidator,
  buildingUpdateValidator,
  flatCreateValidator,
  flatAssignOwnerValidator,
  complaintStatusUpdateValidator,
  announcementCreateValidator,
  ownershipRequestReviewValidator,
  reminderValidator,
  societyNoteValidator,
  complaintsQueryValidator,
  userUpdateValidator
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: adminValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ announcementValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: announcementValidator.js ---
const { body, param } = require('express-validator');

// Announcement creation validator (Admin only)
const announcementCreateValidator = [
  body('title')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Announcement title must be between 5 and 200 characters'),
  body('content')
    .trim()
    .isLength({ min: 10, max: 2000 })
    .withMessage('Announcement content must be between 10 and 2000 characters'),
  body('societyId')
    .isMongoId()
    .withMessage('Invalid society ID'),
  body('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Invalid priority level')
];

// Announcement update validator (Admin only)
const announcementUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid announcement ID'),
  body('title')
    .optional()
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Announcement title must be between 5 and 200 characters'),
  body('content')
    .optional()
    .trim()
    .isLength({ min: 10, max: 2000 })
    .withMessage('Announcement content must be between 10 and 2000 characters'),
  body('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Invalid priority level')
];

module.exports = {
  announcementCreateValidator,
  announcementUpdateValidator
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: announcementValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ authValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: authValidator.js ---
const { body } = require('express-validator');

exports.registerValidator = [
  body('name').notEmpty().withMessage('Name is required'),
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
];

exports.loginValidator = [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
];
‚îÇ   ‚îÇ   ‚îÇ   # --- End: authValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ complaintValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: complaintValidator.js ---
const { body, param, query } = require('express-validator');

// Complaint creation validator (for owners and tenants)
const complaintCreateValidator = [
  body('category')
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid complaint category'),
  body('subject')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Subject must be between 5 and 200 characters'),
  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Description must be between 10 and 1000 characters'),
  body('flatId')
    .optional()
    .isMongoId()
    .withMessage('Invalid flat ID')
];

// Complaint status update validator (admin only)
const complaintStatusUpdateValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid complaint ID'),
  body('status')
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid complaint status'),
  body('adminNote')
    .optional()
    .trim()
    .isLength({ max: 500 })
    .withMessage('Admin note must not exceed 500 characters')
];

// Query validators for filtering complaints
const complaintsQueryValidator = [
  query('status')
    .optional()
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid status filter'),
  query('society')
    .optional()
    .isMongoId()
    .withMessage('Invalid society ID'),
  query('category')
    .optional()
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid category filter'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];

module.exports = {
  complaintCreateValidator,
  complaintStatusUpdateValidator,
  complaintsQueryValidator
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: complaintValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ flatValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: flatValidator.js ---
const { body } = require('express-validator');

exports.assignOwnerValidator = [
  body('ownerId').notEmpty().withMessage('Owner ID is required'),
];

exports.assignTenantValidator = [
  body('tenantId').notEmpty().withMessage('Tenant ID is required'),
];
‚îÇ   ‚îÇ   ‚îÇ   # --- End: flatValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ ownerValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: ownerValidator.js ---
const { body, param, query } = require('express-validator');

// Ownership request validators
const ownershipRequestValidator = [
  body('flatId')
    .isMongoId()
    .withMessage('Invalid flat ID'),
  body('reason')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Reason must be between 10 and 1000 characters'),
  body('documents')
    .optional()
    .isArray()
    .withMessage('Documents must be an array'),
  body('documents.*')
    .optional()
    .isString()
    .withMessage('Each document must be a string')
];

// Tenant assignment validators
const assignTenantValidator = [
  param('id')
    .isMongoId()
    .withMessage('Invalid flat ID'),
  body('tenantId')
    .isMongoId()
    .withMessage('Invalid tenant ID'),
  body('rentAmount')
    .isFloat({ min: 0 })
    .withMessage('Rent amount must be a positive number'),
  body('rentDueDate')
    .isInt({ min: 1, max: 31 })
    .withMessage('Rent due date must be between 1 and 31'),
  body('agreementStartDate')
    .isISO8601()
    .withMessage('Invalid agreement start date'),
  body('agreementEndDate')
    .isISO8601()
    .withMessage('Invalid agreement end date')
];

const updateTenantValidator = [
  param('flatId')
    .isMongoId()
    .withMessage('Invalid flat ID'),
  body('tenantId')
    .optional()
    .isMongoId()
    .withMessage('Invalid tenant ID'),
  body('rentAmount')
    .optional()
    .isFloat({ min: 0 })
    .withMessage('Rent amount must be a positive number'),
  body('rentDueDate')
    .optional()
    .isInt({ min: 1, max: 31 })
    .withMessage('Rent due date must be between 1 and 31'),
  body('agreementEndDate')
    .optional()
    .isISO8601()
    .withMessage('Invalid agreement end date')
];

// Complaint validators
const complaintCreateValidator = [
  body('flatId')
    .isMongoId()
    .withMessage('Invalid flat ID'),
  body('category')
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid complaint category'),
  body('subject')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Subject must be between 5 and 200 characters'),
  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Description must be between 10 and 1000 characters')
];

// Maintenance payment validator
const maintenancePaymentValidator = [
  param('maintenanceId')
    .isMongoId()
    .withMessage('Invalid maintenance ID'),
  body('amount')
    .isFloat({ min: 0 })
    .withMessage('Payment amount must be a positive number'),
  body('paymentMethod')
    .optional()
    .isIn(['cash', 'bank_transfer', 'online'])
    .withMessage('Invalid payment method')
];

// Profile update validator
const profileUpdateValidator = [
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Name must be between 2 and 100 characters'),
  body('phone')
    .optional()
    .matches(/^\+?[\d\s\-\(\)]+$/)
    .withMessage('Invalid phone number format'),
  body('address')
    .optional()
    .trim()
    .isLength({ min: 10, max: 500 })
    .withMessage('Address must be between 10 and 500 characters')
];

// Query validators
const complaintsQueryValidator = [
  query('status')
    .optional()
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid status filter'),
  query('category')
    .optional()
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid category filter'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];

module.exports = {
  ownershipRequestValidator,
  assignTenantValidator,
  updateTenantValidator,
  complaintCreateValidator,
  maintenancePaymentValidator,
  profileUpdateValidator,
  complaintsQueryValidator
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: ownerValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ societyValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: societyValidator.js ---
const { body } = require('express-validator');

exports.societyCreateValidator = [
    body('name').notEmpty().withMessage('Name is required'),
    body('registrationNumber').notEmpty().withMessage('Registration number is required'),
    body('address.street').notEmpty().withMessage('Street is required'),
    body('address.city').notEmpty().withMessage('City is required'),
    body('address.state').notEmpty().withMessage('State is required'),
    body('address.pincode').notEmpty().withMessage('Pincode is required'),
    body('maintenancePolicy.frequency').notEmpty().withMessage('Maintenance frequency is required'),
    body('maintenancePolicy.amountPerFlat').isNumeric().withMessage('Maintenance amount must be a number'),
  ];
‚îÇ   ‚îÇ   ‚îÇ   # --- End: societyValidator.js ---

‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ tenantValidator.js

‚îÇ   ‚îÇ   ‚îÇ   # --- Begin: tenantValidator.js ---
const { body, param, query } = require('express-validator');

// Complaint validators
const complaintCreateValidator = [
  body('category')
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid complaint category'),
  body('subject')
    .trim()
    .isLength({ min: 5, max: 200 })
    .withMessage('Subject must be between 5 and 200 characters'),
  body('description')
    .trim()
    .isLength({ min: 10, max: 1000 })
    .withMessage('Description must be between 10 and 1000 characters')
];

// Rent payment validator
const rentPaymentValidator = [
  param('rentId')
    .isMongoId()
    .withMessage('Invalid rent ID'),
  body('amount')
    .isFloat({ min: 0 })
    .withMessage('Payment amount must be a positive number'),
  body('paymentMethod')
    .optional()
    .isIn(['cash', 'bank_transfer', 'online'])
    .withMessage('Invalid payment method')
];

// Maintenance payment validator
const maintenancePaymentValidator = [
  param('maintenanceId')
    .isMongoId()
    .withMessage('Invalid maintenance ID'),
  body('amount')
    .isFloat({ min: 0 })
    .withMessage('Payment amount must be a positive number'),
  body('paymentMethod')
    .optional()
    .isIn(['cash', 'bank_transfer', 'online'])
    .withMessage('Invalid payment method')
];

// Profile update validator
const profileUpdateValidator = [
  body('name')
    .optional()
    .trim()
    .isLength({ min: 2, max: 100 })
    .withMessage('Name must be between 2 and 100 characters'),
  body('phone')
    .optional()
    .matches(/^\+?[\d\s\-\(\)]+$/)
    .withMessage('Invalid phone number format'),
  body('address')
    .optional()
    .trim()
    .isLength({ min: 10, max: 500 })
    .withMessage('Address must be between 10 and 500 characters')
];

// Query validators
const complaintsQueryValidator = [
  query('status')
    .optional()
    .isIn(['open', 'in-progress', 'resolved', 'rejected'])
    .withMessage('Invalid status filter'),
  query('category')
    .optional()
    .isIn(['plumbing', 'electrical', 'security', 'cleanliness', 'other'])
    .withMessage('Invalid category filter'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];

const announcementsQueryValidator = [
  query('priority')
    .optional()
    .isIn(['low', 'medium', 'high'])
    .withMessage('Invalid priority filter'),
  query('page')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Page must be a positive integer'),
  query('limit')
    .optional()
    .isInt({ min: 1, max: 100 })
    .withMessage('Limit must be between 1 and 100')
];

module.exports = {
  complaintCreateValidator,
  rentPaymentValidator,
  maintenancePaymentValidator,
  profileUpdateValidator,
  complaintsQueryValidator,
  announcementsQueryValidator
}; 
‚îÇ   ‚îÇ   ‚îÇ   # --- End: tenantValidator.js ---

