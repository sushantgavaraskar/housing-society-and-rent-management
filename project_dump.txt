Housing Society Management
├─ config
│  └─ db.js
├─ controllers
│  ├─ adminController.js
│  ├─ announcementController.js
│  ├─ authController.js
│  ├─ complaintController.js
│  ├─ ownerController.js
│  ├─ ownershipRequestController.js
│  └─ tenantController.js
├─ middleware
│  ├─ authMiddleware.js
│  ├─ errorHandler.js
│  ├─ notFound.js
│  ├─ roleAccessGuard
│  └─ roleMiddleware.js
├─ models
│  ├─ Announcement.js
│  ├─ Building.js
│  ├─ Complaint.js
│  ├─ Flat.js
│  ├─ Maintenance.js
│  ├─ OwnershipRequest.js
│  ├─ Rent.js
│  ├─ Society.js
│  └─ User.js
├─ package-lock.json
├─ package.json
├─ README.md
├─ routes
│  ├─ adminRoutes.js
│  ├─ announcementRoutes.js
│  ├─ authRoutes.js
│  ├─ complaintRoutes.js
│  ├─ ownerRoutes.js
│  ├─ ownershipRequestRoutes.js
│  └─ tenantRoutes.js
├─ server.js
├─ uploads
├─ utils
│  ├─ generateToken.js
│  ├─ invoiceGenerator.js
│  └─ sendEmail.js
└─ validations
   └─ userValidation.js

```


├─ ./
│   ├─ .env

│   # --- Begin: .env ---
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=your_access_token_secret
JWT_REFRESH_SECRET=your_refresh_token_secret

# Server config
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:3000
#In production, set CLIENT_URL in .env to your deployed frontend domain

# MongoDB
MONGO_URI=mongodb://localhost:27017/SRG

# JWT
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password

# Cookies
COOKIE_EXPIRE=7

# For production, override values as needed

│   # --- End: .env ---

│   ├─ .gitignore

│   # --- Begin: .gitignore ---
# Node.js
node_modules/
.env
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Logs
logs
*.log
pids
*.pid
*.seed
*.pid.lock

# OS
.DS_Store
Thumbs.db

# IDEs
.vscode/
.idea/

# Build output
dist/
build/

# Optional npm cache
.npm/
.cache/
test.py

│   # --- End: .gitignore ---

│   ├─ package.json

│   # --- Begin: package.json ---
{
  "name": "housing-rent-management",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.14.0",
    "morgan": "^1.10.0",
    "nodemailer": "^7.0.3",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

│   # --- End: package.json ---

│   ├─ server.js

│   # --- Begin: server.js ---
// ✅ PATCHED: server.js with all routes
const express = require('express');
const dotenv = require('dotenv');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
// const mongoSanitize = require('express-mongo-sanitize');
// const xss = require('xss-clean');
const compression = require('compression');

const connectDB = require('./config/db');
const { errorHandler } = require('./middleware/errorHandler');

// Route Imports
const authRoutes = require('./routes/authRoutes');
const adminRoutes = require('./routes/adminRoutes');
const ownerRoutes = require('./routes/ownerRoutes');
const tenantRoutes = require('./routes/tenantRoutes');
const complaintRoutes = require('./routes/complaintRoutes');
const announcementRoutes = require('./routes/announcementRoutes');
const ownershipRequestRoutes = require('./routes/ownershipRequestRoutes');

dotenv.config();
connectDB();

const app = express();

// === Global Middleware ===
app.use(helmet());
// app.use(xss());
// app.use(mongoSanitize());
app.use(compression());
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests from this IP, try again later.'
}));

app.use(express.json());
app.use(cookieParser());

// ✅ CORS for dev/prod
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true,
}));

// === Routes ===
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/owner', ownerRoutes);
app.use('/api/tenant', tenantRoutes);
app.use('/api/complaints', complaintRoutes);
app.use('/api/announcements', announcementRoutes); // ✅ Added
app.use('/api/ownership-requests', ownershipRequestRoutes); // ✅ Added

// Default Route
app.get('/', (req, res) => {
  res.send('Housing Society & Rent Management System API is running');
});

// Error Handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`🚀 Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});
│   # --- End: server.js ---

│   ├─ test.py

│   # --- Begin: test.py ---
import os

def dump_project_to_txt(root_dir, output_file):
    """
    Dumps the full file structure and content of all files in the project,
    excluding only specific heavy/unnecessary folders and specific files.
    """
    # Folders to completely ignore (e.g., large or non-code)
    skip_dirs = {
        "node_modules", ".git", "__pycache__", "venv",
        ".idea", ".vscode", "dist", "build", ".mypy_cache"
    }

    # Specific filenames to ignore (e.g., lockfiles or OS files)
    skip_files = {
        "package-lock.json", "yarn.lock", ".DS_Store"
    }

    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude unwanted directories during traversal
            dirnames[:] = [d for d in dirnames if d not in skip_dirs]

            level = dirpath.replace(root_dir, "").count(os.sep)
            indent = "│   " * level
            f.write(f"{indent}├─ {os.path.basename(dirpath)}/\n")

            sub_indent = "│   " * (level + 1)
            for filename in filenames:
                if filename in skip_files:
                    continue

                full_path = os.path.join(dirpath, filename)
                f.write(f"{sub_indent}├─ {filename}\n")

                try:
                    with open(full_path, "r", encoding="utf-8") as code_file:
                        code = code_file.read()
                        f.write(f"\n{sub_indent}# --- Begin: {filename} ---\n")
                        f.write(code + "\n")
                        f.write(f"{sub_indent}# --- End: {filename} ---\n\n")
                except Exception as e:
                    f.write(f"{sub_indent}[Could not read {filename}: {e}]\n")

# Example usage
dump_project_to_txt(".", "project_dump.txt")

│   # --- End: test.py ---

│   ├─ config/
│   │   ├─ db.js

│   │   # --- Begin: db.js ---
// config/db.js

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      // These options are for Mongoose >= 6
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`✅ MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`❌ MongoDB Connection Error: ${error.message}`);
    process.exit(1); // Stop the app if DB connection fails
  }
};

module.exports = connectDB;

│   │   # --- End: db.js ---

│   ├─ controllers/
│   │   ├─ adminController.js

│   │   # --- Begin: adminController.js ---
const Society = require('../models/Society');
const Building = require('../models/Building');
const Flat = require('../models/Flat');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const OwnershipRequest = require('../models/OwnershipRequest');
const Announcement = require('../models/Announcement');
const Complaint = require('../models/Complaint');
const Rent = require('../models/Rent');
const { sendEmail } = require('../utils/sendEmail');

// EXISTING & IMPROVED APIs ...

exports.getMySocieties = async (req, res, next) => {
  try {
    const societies = await Society.find({ admin: req.user._id });
    res.json(societies);
  } catch (err) {
    next(err);
  }
};

exports.createBuilding = async (req, res, next) => {
  try {
    const { societyId, name, totalFloors, totalFlats, addressLabel } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json({ message: 'Society not found' });

    const building = await Building.create({ name, totalFloors, totalFlats, addressLabel, society: societyId });
    society.totalBuildings += 1;
    await society.save();
    res.status(201).json(building);
  } catch (err) {
    next(err);
  }
};

exports.deleteBuilding = async (req, res, next) => {
  try {
    const building = await Building.findByIdAndDelete(req.params.id);
    if (!building) return res.status(404).json({ message: 'Building not found' });
    res.json({ message: 'Building deleted' });
  } catch (err) {
    next(err);
  }
};

// FLAT OWNERSHIP/TENANT MANAGEMENT

exports.assignFlatOwner = async (req, res, next) => {
  try {
    const { ownerId } = req.body;
    const flat = await Flat.findById(req.params.flatId).populate('society');
    const owner = await User.findById(ownerId);

    if (!flat || !owner || owner.role !== 'owner') {
      return res.status(400).json({ message: 'Invalid flat or owner' });
    }

    flat.owner = owner._id;
    await flat.save();

    // ✅ Assign society to owner if not already set
    if (!owner.society) {
      owner.society = flat.society._id;
      await owner.save();
    }

    res.json({ message: 'Owner assigned successfully', flat });
  } catch (err) {
    next(err);
  }
};


exports.removeFlatOwner = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json({ message: 'Flat not found' });

    flat.owner = null;
    await flat.save();
    res.json({ message: 'Owner removed successfully' });
  } catch (err) {
    next(err);
  }
};

// 


exports.removeFlatTenant = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json({ message: 'Flat not found' });

    flat.tenant = null;
    flat.isRented = false;
    flat.occupancyStatus = 'vacant';
    await flat.save();
    res.json({ message: 'Tenant removed' });
  } catch (err) {
    next(err);
  }
};

// MAINTENANCE

exports.generateMaintenance = async (req, res, next) => {
  try {
    const { societyId, billingMonth } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json({ message: 'Society not found' });

    const flats = await Flat.find({ society: societyId });
    const amount = society.maintenancePolicy.amountPerFlat;

    const records = await Maintenance.insertMany(flats.map(flat => ({
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      billingMonth,
      amount,
      generatedBy: req.user._id,
    })));

    res.status(201).json({ message: 'Maintenance generated', records });
  } catch (err) {
    next(err);
  }
};

exports.getMaintenanceStatus = async (req, res, next) => {
  try {
    const { filterBy, id } = req.query; // filterBy: society | flat | user
    let query = {};

    if (filterBy === 'society') query.society = id;
    else if (filterBy === 'flat') query.flat = id;
    else if (filterBy === 'user') {
      const flats = await Flat.find({ $or: [{ owner: id }, { tenant: id }] }, '_id');
      query.flat = { $in: flats.map(f => f._id) };
    }

    const records = await Maintenance.find(query)
      .populate('flat', 'flatNumber')
      .populate('building', 'name');

    res.json({ count: records.length, records });
  } catch (err) {
    next(err);
  }
};

// RENT HISTORY

exports.getRentHistory = async (req, res, next) => {
  try {
    const rentRecords = await Rent.find().populate('flat', 'flatNumber').populate('tenant', 'name email');
    res.json({ count: rentRecords.length, rentRecords });
  } catch (err) {
    next(err);
  }
};

// OWNERSHIP REQUESTS

exports.getOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ status: 'pending' }).populate('flat currentOwner');
    res.json(requests);
  } catch (err) {
    next(err);
  }
};

exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;
    const request = await OwnershipRequest.findById(requestId);
    if (!request) return res.status(404).json({ message: 'Request not found' });

    request.status = status;
    request.reviewedBy = req.user._id;
    request.reviewedOn = new Date();
    request.adminNote = note;
    await request.save();

    if (status === 'approved') {
      await Flat.findByIdAndUpdate(request.flat, { owner: request.currentOwner });
    }

    res.json({ message: 'Request reviewed', request });
  } catch (err) {
    next(err);
  }
};

// ANNOUNCEMENTS

exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, society, building, audience, validTill } = req.body;

    const announcement = await Announcement.create({
      title,
      message,
      createdBy: req.user._id,
      society,
      building: building || null,
      audience,
      validTill: validTill || null,
    });

    res.status(201).json(announcement);
  } catch (err) {
    next(err);
  }
};

// COMPLAINTS

exports.getComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({}).populate('raisedBy flat building society');
    res.json(complaints);
  } catch (err) {
    next(err);
  }
};

exports.updateComplaintStatus = async (req, res, next) => {
  try {
    const { complaintId, status, adminNote } = req.body;
    const complaint = await Complaint.findById(complaintId);
    if (!complaint) return res.status(404).json({ message: 'Complaint not found' });

    complaint.status = status;
    complaint.adminNote = adminNote || '';
    complaint.resolvedBy = req.user._id;
    complaint.resolvedOn = new Date();
    await complaint.save();

    res.json({ message: 'Complaint updated', complaint });
  } catch (err) {
    next(err);
  }
};

// DASHBOARD

exports.getAdminDashboard = async (req, res, next) => {
  try {
    const totalFlats = await Flat.countDocuments();
    const totalTenants = await User.countDocuments({ role: 'tenant' });
    const totalOwners = await User.countDocuments({ role: 'owner' });
    const totalPendingComplaints = await Complaint.countDocuments({ status: 'pending' });

    res.json({
      totalFlats,
      totalTenants,
      totalOwners,
      totalPendingComplaints,
    });
  } catch (err) {
    next(err);
  }
};

// AGREEMENTS VIEW

exports.getAllAgreements = async (req, res, next) => {
  try {
    // Future scope: rent/ownership documents if uploaded via upload system
    res.status(501).json({ message: 'Agreement system not implemented yet' });
  } catch (err) {
    next(err);
  }
};

// ADMIN NOTES

exports.addSocietyNote = async (req, res, next) => {
  try {
    const { note } = req.body;
    const society = await Society.findById(req.params.id);
    if (!society) return res.status(404).json({ message: 'Society not found' });

    society.adminNote = note;
    await society.save();
    res.json({ message: 'Note added' });
  } catch (err) {
    next(err);
  }
};

// EMAIL REMINDER

exports.sendReminderToUser = async (req, res, next) => {
  try {
    const { userId, subject, message } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: 'User not found' });

    await sendEmail(user.email, subject, message);
    res.json({ message: 'Reminder sent' });
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: adminController.js ---

│   │   ├─ announcementController.js

│   │   # --- Begin: announcementController.js ---
// controllers/announcementController.js

const Announcement = require('../models/Announcement');
const Society = require('../models/Society');

// Create a new announcement (Admin only)
exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, society, building, audience, validTill } = req.body;

    const newAnnouncement = await Announcement.create({
      title,
      message,
      society,
      building: building || null,
      audience,
      validTill: validTill || null,
      createdBy: req.user._id,
    });

    res.status(201).json({ message: 'Announcement created successfully', data: newAnnouncement });
  } catch (err) {
    next(err);
  }
};

// Get all announcements for a society or building
exports.getAnnouncements = async (req, res, next) => {
  try {
    const { societyId } = req.params;
    const { buildingId } = req.query;

    const filter = { society: societyId };
    if (buildingId) filter.building = buildingId;

    const announcements = await Announcement.find(filter).sort({ createdAt: -1 });

    res.status(200).json({ count: announcements.length, announcements });
  } catch (err) {
    next(err);
  }
};

// Delete an announcement (Admin only)
exports.deleteAnnouncement = async (req, res, next) => {
  try {
    const announcement = await Announcement.findById(req.params.id);
    if (!announcement) {
      return res.status(404).json({ message: 'Announcement not found' });
    }

    await announcement.deleteOne();
    res.status(200).json({ message: 'Announcement deleted successfully' });
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: announcementController.js ---

│   │   ├─ authController.js

│   │   # --- Begin: authController.js ---
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Flat = require('../models/Flat');
const { generateToken } = require('../utils/generateToken');
const { asyncHandler } = require('../middleware/errorHandler');

// REGISTER USER (admin, owner, tenant)
exports.registerUser = asyncHandler(async (req, res) => {
  const { name, email, password, phone, role = 'tenant' } = req.body;

  const existingUser = await User.findOne({ email });
  if (existingUser) {
    res.status(400);
    throw new Error('Email is already registered');
  }

  const user = await User.create({ name, email, password, phone, role });

  const token = generateToken(res, user._id);

  res.status(201).json({
    message: 'User registered successfully',
    user: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role,
    }
  });
});

// LOGIN
exports.loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  const user = await User.findOne({ email }).select('+password');
  if (!user || !(await user.comparePassword(password))) {
    res.status(401);
    throw new Error('Invalid email or password');
  }

  // 🔐 Enforce owner/tenant assignment before access
  if (user.role === 'owner') {
    const flat = await Flat.findOne({ owner: user._id });
    if (!flat) {
      res.status(403);
      throw new Error('Owner is not registered or assigned yet.');
    }
  }

  if (user.role === 'tenant') {
    const flat = await Flat.findOne({ tenant: user._id });
    if (!flat) {
      res.status(403);
      throw new Error('Tenant is not assigned to any flat yet.');
    }
  }

  const token = generateToken(res, user._id);

  res.status(200).json({
    message: 'Login successful',
    user: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role,
    }
  });
});

// LOGOUT
exports.logoutUser = asyncHandler(async (req, res) => {
  res
    .cookie('token', '', {
      httpOnly: true,
      expires: new Date(0),
    })
    .status(200)
    .json({ message: 'Logged out successfully' });
});

// GET CURRENT USER
exports.getMe = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user._id).select('-password');
  if (!user) {
    res.status(404);
    throw new Error('User not found');
  }

  res.status(200).json({
    _id: user._id,
    name: user.name,
    email: user.email,
    phone: user.phone,
    role: user.role,
    society: user.society || null,
  });
});

// CHANGE PASSWORD
exports.changePassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const user = await User.findById(req.user._id).select('+password');

  if (!user || !(await user.comparePassword(currentPassword))) {
    res.status(401);
    throw new Error('Current password is incorrect');
  }

  user.password = newPassword;
  await user.save();

  res.status(200).json({ message: 'Password updated successfully' });
});

// TOKEN STATUS
exports.tokenStatus = asyncHandler(async (req, res) => {
  const token = req.cookies.token || (req.headers.authorization?.startsWith('Bearer ') && req.headers.authorization.split(' ')[1]);
  if (!token) return res.status(401).json({ message: 'Token missing' });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return res.status(200).json({ valid: true, userId: decoded.id });
  } catch {
    return res.status(401).json({ valid: false });
  }
});

│   │   # --- End: authController.js ---

│   │   ├─ complaintController.js

│   │   # --- Begin: complaintController.js ---
// controllers/complaintController.js

const Complaint = require('../models/Complaint');
const Flat = require('../models/Flat');
const sendEmail = require('../utils/sendEmail');

// @desc    Get all complaints in the society (admin)
// @route   GET /api/complaints/all
exports.getAllComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({})
      .populate('raisedBy', 'name email role')
      .populate('flat', 'flatNumber')
      .populate('building', 'name')
      .populate('society', 'name')
      .sort({ createdAt: -1 });

    res.status(200).json(complaints);
  } catch (error) {
    next(error);
  }
};

// @desc    Get complaints for a specific building (admin or owner)
// @route   GET /api/complaints/building/:buildingId
exports.getComplaintsByBuilding = async (req, res, next) => {
  try {
    const { buildingId } = req.params;

    const complaints = await Complaint.find({ building: buildingId })
      .populate('raisedBy', 'name email role')
      .populate('flat', 'flatNumber')
      .populate('building', 'name')
      .populate('society', 'name')
      .sort({ createdAt: -1 });

    res.status(200).json(complaints);
  } catch (error) {
    next(error);
  }
};

// @desc    Mark complaint as resolved (admin/owner)
// @route   PUT /api/complaints/:id/resolve
exports.resolveComplaint = async (req, res, next) => {
  try {
    const { id } = req.params;

    const complaint = await Complaint.findById(id);
    if (!complaint) {
      return res.status(404).json({ message: 'Complaint not found' });
    }

    complaint.status = 'resolved';
    await complaint.save();

    // Notify the user via email
    await complaint.populate('raisedBy', 'email name');
    await sendEmail(
      complaint.raisedBy.email,
      'Your Complaint has been Resolved',
      `Hi ${complaint.raisedBy.name},\n\nYour complaint titled "${complaint.title}" has been resolved.\n\nThank you for your patience.\n\n- Housing Society Management`
    );


    res.status(200).json({ message: 'Complaint marked as resolved', complaint });
  } catch (error) {
    next(error);
  }
};

// @desc    Delete a complaint (admin only)
// @route   DELETE /api/complaints/:id
exports.deleteComplaint = async (req, res, next) => {
  try {
    const { id } = req.params;

    const complaint = await Complaint.findById(id);
    if (!complaint) {
      return res.status(404).json({ message: 'Complaint not found' });
    }

    await complaint.remove();
    res.status(200).json({ message: 'Complaint deleted successfully' });
  } catch (error) {
    next(error);
  }
};

│   │   # --- End: complaintController.js ---

│   │   ├─ ownerController.js

│   │   # --- Begin: ownerController.js ---
// controllers/ownerController.js

const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const OwnershipRequest = require('../models/OwnershipRequest');
const Rent = require('../models/Rent');
const User = require('../models/User');
const Society = require('../models/Society');

// 1. Get all flats owned by logged-in owner
exports.getMyFlats = async (req, res) => {
  try {
    const flats = await Flat.find({ owner: req.user._id })
      .populate('building')
      .populate('tenant');

    res.status(200).json({ flats });
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch flats', error: err.message });
  }
};

// 2. View society/building info of a specific flat (new)
exports.getFlatSocietyInfo = async (req, res) => {
  try {
    const flat = await Flat.findOne({ _id: req.params.id, owner: req.user._id })
      .populate('building')
      .populate('society');

    if (!flat) {
      return res.status(404).json({ message: 'Flat not found or unauthorized' });
    }

    res.status(200).json({ building: flat.building, society: flat.society });
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch info', error: err.message });
  }
};

// 3. Submit ownership transfer request
exports.submitOwnershipRequest = async (req, res) => {
  try {
    const { flatId, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flat = await Flat.findById(flatId);
    if (!flat || flat.owner.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'You are not authorized to request ownership for this flat' });
    }

    const request = await OwnershipRequest.create({
      flat: flatId,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    res.status(201).json({ message: 'Ownership request submitted', request });
  } catch (err) {
    res.status(500).json({ message: 'Failed to submit request', error: err.message });
  }
};

// 4. Rent payment history
exports.getRentHistory = async (req, res) => {
  try {
    const rents = await Rent.find({ owner: req.user._id })
      .populate('flat')
      .populate('tenant');

    res.status(200).json({ rents });
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch rent history', error: err.message });
  }
};

// 5. File complaint
exports.fileComplaint = async (req, res) => {
  try {
    const { flatId, category, subject, description } = req.body;

    const flat = await Flat.findOne({ _id: flatId, owner: req.user._id });
    if (!flat) {
      return res.status(403).json({ message: 'Unauthorized access to flat' });
    }

    const complaint = await Complaint.create({
      raisedBy: req.user._id,
      userRole: 'owner',
      flat: flatId,
      building: flat.building,
      society: flat.society,
      category,
      subject,
      description,
    });

    res.status(201).json({ message: 'Complaint submitted', complaint });
  } catch (err) {
    res.status(500).json({ message: 'Failed to submit complaint', error: err.message });
  }
};

// 6. View own complaints
exports.getMyComplaints = async (req, res) => {
  try {
    const complaints = await Complaint.find({ raisedBy: req.user._id, userRole: 'owner' })
      .populate('flat')
      .populate('building');

    res.status(200).json({ complaints });
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch complaints', error: err.message });
  }
};

// 7. Dashboard summary (new)
exports.getOwnerDashboard = async (req, res) => {
  try {
    const flats = await Flat.find({ owner: req.user._id });
    const flatIds = flats.map(f => f._id);

    const rentCount = await Rent.countDocuments({ flat: { $in: flatIds } });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'owner' });

    res.status(200).json({
      totalFlatsOwned: flats.length,
      rentPaymentsMade: rentCount,
      complaintsFiled: complaintCount,
    });
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch dashboard info', error: err.message });
  }
};
// View unpaid maintenance bills for owner-occupied or unrented flats
exports.getUnpaidMaintenance = async (req, res) => {
  try {
    const flats = await Flat.find({
      owner: req.user._id,
      $or: [{ tenant: null }, { tenant: { $exists: false } }]
    });

    const flatIds = flats.map(f => f._id);

    const maintenance = await Maintenance.find({
      flat: { $in: flatIds },
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(maintenance);
  } catch (err) {
    res.status(500).json({ message: 'Failed to fetch maintenance dues', error: err.message });
  }
};

// Pay maintenance for owner-occupied/unrented flat
exports.payMaintenance = async (req, res) => {
  try {
    const maintenance = await Maintenance.findById(req.params.maintenanceId).populate('flat');

    if (!maintenance) return res.status(404).json({ message: 'Maintenance not found' });

    const isOwnedByUser = maintenance.flat.owner.toString() === req.user._id.toString();
    const isVacantOrOwnerOccupied = !maintenance.flat.tenant;

    if (!isOwnedByUser || !isVacantOrOwnerOccupied) {
      return res.status(403).json({ message: 'Unauthorized: Flat is not owner-occupied or already rented' });
    }

    if (maintenance.isPaid) return res.status(400).json({ message: 'Maintenance already paid' });

    maintenance.isPaid = true;
    maintenance.paidAt = new Date();
    await maintenance.save();

    res.status(200).json({ message: 'Maintenance paid successfully', maintenance });
  } catch (err) {
    res.status(500).json({ message: 'Failed to process payment', error: err.message });
  }
};

// ✅ NEW: Assign tenant to a flat owned by logged-in owner
exports.assignTenantToMyFlat = async (req, res) => {
  try {
    const { flatId, tenantId } = req.body;

    const flat = await Flat.findOne({ _id: flatId, owner: req.user._id }).populate('society');
    if (!flat) {
      return res.status(403).json({ message: 'You do not own this flat or flat not found' });
    }

    const tenant = await User.findById(tenantId);
    if (!tenant || tenant.role !== 'tenant') {
      return res.status(400).json({ message: 'Invalid tenant user' });
    }

    // Assign tenant to flat
    flat.tenant = tenant._id;
    flat.isRented = true;
    flat.occupancyStatus = 'occupied';
    await flat.save();

    // Assign society to tenant if not already linked
    if (!tenant.society) {
      tenant.society = flat.society._id;
      await tenant.save();
    }

    res.status(200).json({ message: 'Tenant assigned successfully', flat });
  } catch (err) {
    res.status(500).json({ message: 'Failed to assign tenant', error: err.message });
  }
};

│   │   # --- End: ownerController.js ---

│   │   ├─ ownershipRequestController.js

│   │   # --- Begin: ownershipRequestController.js ---
// controllers/ownershipRequestController.js

const OwnershipRequest = require('../models/OwnershipRequest');
const Flat = require('../models/Flat');
const User = require('../models/User');
const sendEmail = require('../utils/sendEmail');

// Owner submits a request to transfer ownership
exports.createOwnershipRequest = async (req, res, next) => {
  try {
    const { flat, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flatExists = await Flat.findById(flat);
    if (!flatExists || !flatExists.owner.equals(req.user._id)) {
      return res.status(400).json({ message: 'Invalid flat or permission denied.' });
    }

    const request = await OwnershipRequest.create({
      flat,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    // Send confirmation email to the owner
    await sendEmail(
      req.user.email,
      'Ownership Transfer Request Submitted',
      `Hi ${req.user.name},\n\nYour ownership transfer request for Flat ${flatExists.flatNumber} has been submitted.\n\nWe will notify you once it's reviewed.\n\n- Housing Society Admin`
    );

    res.status(201).json({ message: 'Ownership transfer request submitted.', data: request });
  } catch (err) {
    next(err);
  }
};

// Admin fetches all ownership requests
exports.getAllOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find()
      .populate('flat', 'flatNumber')
      .populate('currentOwner', 'name email');

    res.status(200).json({ count: requests.length, requests });
  } catch (err) {
    next(err);
  }
};

// Admin approves or rejects ownership request
exports.updateOwnershipRequestStatus = async (req, res, next) => {
  try {
    const { id } = req.params;
    const { status, adminNote } = req.body;

    const request = await OwnershipRequest.findById(id).populate('flat');
    if (!request) {
      return res.status(404).json({ message: 'Ownership request not found' });
    }

    request.status = status;
    request.adminNote = adminNote || '';
    request.reviewedBy = req.user._id;
    request.reviewedOn = new Date();
    await request.save();

    // If approved, reset flat ownership and tenancy
    if (status === 'approved') {
      const flat = await Flat.findById(request.flat._id);
      flat.owner = null;
      flat.tenant = null;
      flat.isRented = false;
      flat.occupancyStatus = 'vacant';
      await flat.save();
    }

    // Notify the owner via email
    const owner = await User.findById(request.currentOwner);
    await sendEmail(
      owner.email,
      `Ownership Request ${status === 'approved' ? 'Approved' : 'Rejected'}`,
      `Hi ${owner.name},\n\nYour ownership request for Flat ${request.flat.flatNumber} has been ${status}.\n\nAdmin Note: ${adminNote || 'No additional notes'}\n\n- Housing Society Admin`
    );

    res.status(200).json({ message: `Request ${status} successfully.`, request });
  } catch (err) {
    next(err);
  }
};

// Owner fetches their ownership requests
exports.getMyOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ currentOwner: req.user._id })
      .populate('flat', 'flatNumber');

    res.status(200).json({ count: requests.length, requests });
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: ownershipRequestController.js ---

│   │   ├─ tenantController.js

│   │   # --- Begin: tenantController.js ---
const Flat = require('../models/Flat');
const Rent = require('../models/Rent');
const Complaint = require('../models/Complaint');
const Announcement = require('../models/Announcement');
const Maintenance = require('../models/Maintenance');
// 1. Get the flat assigned to the tenant
exports.getMyFlat = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id })
      .populate('building', 'name')
      .populate('society', 'name');
    
    if (!flat) {
      return res.status(404).json({ message: 'No flat assigned.' });
    }

    res.status(200).json(flat);
  } catch (error) {
    next(error);
  }
};

// 2. Rent history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ tenant: req.user._id })
      .sort({ billingMonth: -1 })
      .populate('flat', 'flatNumber')
      .populate('owner', 'name email');

    res.status(200).json(rents);
  } catch (error) {
    next(error);
  }
};

// 3. File a complaint
exports.fileComplaint = async (req, res, next) => {
  try {
    const { category, subject, description } = req.body;

    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(400).json({ message: 'No flat assigned.' });
    }

    const complaint = await Complaint.create({
      raisedBy: req.user._id,
      userRole: 'tenant',
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      category,
      subject,
      description
    });

    res.status(201).json(complaint);
  } catch (error) {
    next(error);
  }
};

// 4. View tenant's submitted complaints
exports.getMyComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({ raisedBy: req.user._id })
      .sort({ createdAt: -1 });

    res.status(200).json(complaints);
  } catch (error) {
    next(error);
  }
};

// 5. Get announcements (filtered by society or building)
exports.getAnnouncements = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) return res.status(400).json({ message: 'Flat not found.' });

    const announcements = await Announcement.find({
      $or: [
        { targetSociety: flat.society },
        { targetBuilding: flat.building }
      ]
    }).sort({ createdAt: -1 });

    res.status(200).json(announcements);
  } catch (error) {
    next(error);
  }
};

// 6. Dashboard summary (total rent paid, complaints filed, etc.)
exports.getTenantDashboard = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    const rentCount = await Rent.countDocuments({ tenant: req.user._id });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'tenant' });

    res.status(200).json({
      flatAssigned: !!flat,
      totalRentsPaid: rentCount,
      complaintsFiled: complaintCount,
    });
  } catch (error) {
    next(error);
  }
};
// 7. Get current unpaid rent
exports.getCurrentRent = async (req, res, next) => {
  try {
    const rent = await Rent.findOne({
      tenant: req.user._id,
      isPaid: false
    }).sort({ billingMonth: -1 }).populate('flat');

    if (!rent) {
      return res.status(200).json({ message: 'No unpaid rent found' });
    }

    res.status(200).json(rent);
  } catch (error) {
    next(error);
  }
};

// 8. Simulate rent payment
exports.payRent = async (req, res, next) => {
  try {
    const rent = await Rent.findOne({
      _id: req.params.rentId,
      tenant: req.user._id
    });

    if (!rent) return res.status(404).json({ message: 'Rent record not found' });
    if (rent.isPaid) return res.status(400).json({ message: 'Rent already paid' });

    rent.isPaid = true;
    rent.paidAt = new Date();
    await rent.save();

    res.status(200).json({ message: 'Rent marked as paid', rent });
  } catch (error) {
    next(error);
  }
};

// 9. View unpaid maintenance bills
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) return res.status(400).json({ message: 'No assigned flat' });

    const maintenance = await Maintenance.find({
      flat: flat._id,
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(maintenance);
  } catch (error) {
    next(error);
  }
};

// 10. Pay maintenance
exports.payMaintenance = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) return res.status(400).json({ message: 'No assigned flat' });

    const maintenance = await Maintenance.findOne({
      _id: req.params.maintenanceId,
      flat: flat._id
    });

    if (!maintenance) return res.status(404).json({ message: 'Maintenance record not found' });
    if (maintenance.isPaid) return res.status(400).json({ message: 'Already paid' });

    maintenance.isPaid = true;
    maintenance.paidAt = new Date();
    await maintenance.save();

    res.status(200).json({ message: 'Maintenance marked as paid', maintenance });
  } catch (error) {
    next(error);
  }
};
│   │   # --- End: tenantController.js ---

│   ├─ logs/
│   │   ├─ combined.logs

│   │   # --- Begin: combined.logs ---

│   │   # --- End: combined.logs ---

│   ├─ middleware/
│   │   ├─ authMiddleware.js

│   │   # --- Begin: authMiddleware.js ---
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  const token = req.cookies.token || (req.headers.authorization?.startsWith('Bearer ') && req.headers.authorization.split(' ')[1]);

  if (!token) {
    return res.status(401).json({ message: 'Access denied. No token provided.' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    if (!user) return res.status(401).json({ message: 'User not found.' });
    req.user = user;
    next();
  } catch (err) {
    return res.status(401).json({ message: 'Invalid or expired token.' });
  }
};

module.exports = authMiddleware;

│   │   # --- End: authMiddleware.js ---

│   │   ├─ errorHandler.js

│   │   # --- Begin: errorHandler.js ---
// middleware/errorHandler.js

const errorHandler = (err, req, res, next) => {
  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? null : err.stack,
  });
};

const asyncHandler = (fn) => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);

module.exports = { errorHandler, asyncHandler };

│   │   # --- End: errorHandler.js ---

│   │   ├─ notFound.js

│   │   # --- Begin: notFound.js ---

│   │   # --- End: notFound.js ---

│   │   ├─ roleAccessGuard

│   │   # --- Begin: roleAccessGuard ---
const Flat = require('../models/Flat');

// Check if owner is assigned to any flat
const verifyOwnerAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ owner: req.user._id });
  if (!flat) return res.status(403).json({ message: "Owner is not registered or assigned to any flat yet." });
  next();
};

// Check if tenant is assigned to any flat
const verifyTenantAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ tenant: req.user._id });
  if (!flat) return res.status(403).json({ message: "Tenant is not assigned to any flat yet." });
  next();
};

module.exports = {
  verifyOwnerAssigned,
  verifyTenantAssigned
};

│   │   # --- End: roleAccessGuard ---

│   │   ├─ roleMiddleware.js

│   │   # --- Begin: roleMiddleware.js ---
const roleMiddleware = (roles) => {
  const allowedRoles = Array.isArray(roles) ? roles : [roles];
  return (req, res, next) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Access forbidden: insufficient permissions.' });
    }
    next();
  };
};

module.exports = roleMiddleware;

│   │   # --- End: roleMiddleware.js ---

│   ├─ models/
│   │   ├─ Announcement.js

│   │   # --- Begin: Announcement.js ---
// models/Announcement.js

const mongoose = require('mongoose');

const announcementSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Announcement title is required'],
    trim: true,
  },
  message: {
    type: String,
    required: [true, 'Announcement message is required'],
    trim: true,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    required: [true, 'Admin reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Target society is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    default: null, // If null, applies to whole society
  },
  audience: {
    type: String,
    enum: ['all', 'owners', 'tenants'],
    default: 'all',
  },
  validTill: {
    type: Date,
    default: null, // Optional expiry
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Announcement', announcementSchema);

│   │   # --- End: Announcement.js ---

│   │   ├─ Building.js

│   │   # --- Begin: Building.js ---
// models/Building.js

const mongoose = require('mongoose');

const buildingSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Building name is required'],
    trim: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  totalFloors: {
    type: Number,
    required: [true, 'Total number of floors is required'],
    min: [1, 'There must be at least 1 floor'],
  },
  totalFlats: {
    type: Number,
    required: [true, 'Total number of flats is required'],
    min: [1, 'There must be at least 1 flat'],
  },
  addressLabel: {
    type: String,
    trim: true,
    default: '',
    // Optional label if address differs from society (e.g., "Wing B, Gate 2")
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Building', buildingSchema);

│   │   # --- End: Building.js ---

│   │   ├─ Complaint.js

│   │   # --- Begin: Complaint.js ---
// models/Complaint.js

const mongoose = require('mongoose');

const complaintSchema = new mongoose.Schema({
  raisedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User who raised the complaint is required'],
  },
  userRole: {
    type: String,
    enum: ['owner', 'tenant'],
    required: true,
  },
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: true,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  category: {
    type: String,
    enum: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    default: 'other',
  },
  subject: {
    type: String,
    required: [true, 'Complaint subject is required'],
    trim: true,
  },
  description: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['open', 'in-progress', 'resolved', 'rejected'],
    default: 'open',
  },
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  resolvedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});
complaintSchema.index({ raisedBy: 1 });
complaintSchema.index({ flat: 1 });
complaintSchema.index({ society: 1 });


module.exports = mongoose.model('Complaint', complaintSchema);

│   │   # --- End: Complaint.js ---

│   │   ├─ Flat.js

│   │   # --- Begin: Flat.js ---
// models/Flat.js

const mongoose = require('mongoose');

const flatSchema = new mongoose.Schema({
  flatNumber: {
    type: String,
    required: [true, 'Flat number is required'],
    trim: true,
  },
  floor: {
    type: Number,
    required: [true, 'Floor number is required'],
    min: 0,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner user reference is required'],
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  isRented: {
    type: Boolean,
    default: false,
  },
  occupancyStatus: {
    type: String,
    enum: ['vacant', 'occupied-owner', 'occupied-tenant'],
    default: 'vacant',
  },
}, {
  timestamps: true,
});
flatSchema.index({ tenant: 1 });
flatSchema.index({ society: 1 });
flatSchema.index({ building: 1 });

module.exports = mongoose.model('Flat', flatSchema);

│   │   # --- End: Flat.js ---

│   │   ├─ Maintenance.js

│   │   # --- Begin: Maintenance.js ---
// models/Maintenance.js

const mongoose = require('mongoose');

const maintenanceSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  amount: {
    type: Number,
    required: [true, 'Maintenance amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Typically an Admin
    required: true,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Maintenance', maintenanceSchema);

│   │   # --- End: Maintenance.js ---

│   │   ├─ OwnershipRequest.js

│   │   # --- Begin: OwnershipRequest.js ---
// models/OwnershipRequest.js

const mongoose = require('mongoose');

const ownershipRequestSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  currentOwner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Current owner reference is required'],
  },
  newOwnerName: {
    type: String,
    required: [true, 'New owner name is required'],
    trim: true,
  },
  newOwnerEmail: {
    type: String,
    required: [true, 'New owner email is required'],
    trim: true,
    lowercase: true,
  },
  newOwnerPhone: {
    type: String,
    required: [true, 'New owner phone number is required'],
    trim: true,
  },
  reason: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'pending',
  },
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    default: null,
  },
  reviewedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('OwnershipRequest', ownershipRequestSchema);

│   │   # --- End: OwnershipRequest.js ---

│   │   ├─ Rent.js

│   │   # --- Begin: Rent.js ---
// models/Rent.js

const mongoose = require('mongoose');

const rentSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Tenant reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner reference is required'],
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  rentAmount: {
    type: Number,
    required: [true, 'Rent amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  paymentMode: {
    type: String,
    enum: ['cash', 'online', 'bank-transfer', 'upi'],
    default: 'online',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Rent', rentSchema);

│   │   # --- End: Rent.js ---

│   │   ├─ Society.js

│   │   # --- Begin: Society.js ---
// models/Society.js

const mongoose = require('mongoose');

const societySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Society name is required'],
    trim: true,
  },
  address: {
    street: { type: String, required: true, trim: true },
    city: { type: String, required: true, trim: true },
    state: { type: String, required: true, trim: true },
    pincode: { type: String, required: true, trim: true },
  },
  registrationNumber: {
    type: String,
    required: [true, 'Registration number is required'],
    unique: true,
    trim: true,
  },
  totalBuildings: {
    type: Number,
    default: 0,
    min: 0,
  },
  maintenancePolicy: {
    frequency: {
      type: String,
      enum: ['monthly', 'quarterly'],
      default: 'monthly',
    },
    amountPerFlat: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  admin: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Admin user is required'],
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Society', societySchema);

│   │   # --- End: Society.js ---

│   │   ├─ User.js

│   │   # --- Begin: User.js ---
// models/User.js

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// Role constants
const ROLES = ['admin', 'owner', 'tenant'];

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide your name'],
    trim: true,
    maxlength: [50, 'Name cannot exceed 50 characters'],
  },
  email: {
    type: String,
    required: [true, 'Please provide your email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\S+@\S+\.\S+$/,
      'Please provide a valid email address',
    ],
  },
  password: {
    type: String,
    required: [true, 'Please set a password'],
    minlength: [6, 'Password must be at least 6 characters'],
    select: false, // Hide in queries by default
  },
  role: {
    type: String,
    enum: ROLES,
    default: 'tenant',
  },
  phone: {
    type: String,
    trim: true,
    maxlength: 15,
  },
  profilePic: {
    type: String, // URL to profile image (optional)
    default: '',
  },
  loginAttempts: {
    type: Number,
    default: 0,
  },
  lastLogin: {
    type: Date,
    default: null,
  },
  isActive: {
    type: Boolean,
    default: true,
  },
}, {
  timestamps: true,
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next(); // Only hash if changed

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Method to compare entered password with stored hash
userSchema.methods.comparePassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

│   │   # --- End: User.js ---

│   ├─ routes/
│   │   ├─ adminRoutes.js

│   │   # --- Begin: adminRoutes.js ---
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Admin-only routes
router.use(authMiddleware);
router.use(roleMiddleware('admin'));

// Core society & building management
router.get('/societies', adminController.getMySocieties);
router.post('/buildings', adminController.createBuilding);
router.delete('/buildings/:id', adminController.deleteBuilding);

// Flat management
router.patch('/flats/:flatId/assign-owner', adminController.assignFlatOwner);
router.patch('/flats/:flatId/remove-owner', adminController.removeFlatOwner);
router.patch('/flats/:flatId/assign-tenant', adminController.assignFlatTenant);
router.patch('/flats/:flatId/remove-tenant', adminController.removeFlatTenant);

// Maintenance
router.post('/maintenance', adminController.generateMaintenance);
router.get('/maintenance/status', adminController.getMaintenanceStatus);

// Rent
router.get('/rent/history', adminController.getRentHistory);

// Ownership requests
router.get('/ownership-requests', adminController.getOwnershipRequests);
router.post('/ownership-requests/review', adminController.reviewOwnershipRequest);

// Announcements
router.post('/announcements', adminController.createAnnouncement);

// Complaints
router.get('/complaints', adminController.getComplaints);
router.patch('/complaints', adminController.updateComplaintStatus);

// Dashboard & documents
router.get('/dashboard/overview', adminController.getAdminDashboard);
router.get('/documents', adminController.getAllAgreements);

// Notes & reminders
router.post('/societies/:id/note', adminController.addSocietyNote);
router.post('/reminders', adminController.sendReminderToUser);

module.exports = router;

│   │   # --- End: adminRoutes.js ---

│   │   ├─ announcementRoutes.js

│   │   # --- Begin: announcementRoutes.js ---
// routes/announcementRoutes.js

const express = require('express');
const router = express.Router();
const announcementController = require('../controllers/announcementController');

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Protected routes for admin
router.post('/', authMiddleware, roleMiddleware(['admin']), announcementController.createAnnouncement);
router.delete('/:id', authMiddleware, roleMiddleware(['admin']), announcementController.deleteAnnouncement);

// Public route to fetch announcements for a society (optionally filter by building)
router.get('/:societyId', authMiddleware, announcementController.getAnnouncements);

module.exports = router;

│   │   # --- End: announcementRoutes.js ---

│   │   ├─ authRoutes.js

│   │   # --- Begin: authRoutes.js ---
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

const authMiddleware = require('../middleware/authMiddleware');
const {registerValidation, loginValidation} = require('../validations/userValidation')


router.post('/register', registerValidation, authController.registerUser);
router.post('/login', loginValidation, authController.loginUser);

// Protected Routes
router.post('/logout', authMiddleware, authController.logoutUser);
router.get('/me', authMiddleware, authController.getMe);
router.put('/change-password', authMiddleware, authController.changePassword);
router.get('/token-status', authMiddleware, authController.tokenStatus);
module.exports = router;

│   │   # --- End: authRoutes.js ---

│   │   ├─ complaintRoutes.js

│   │   # --- Begin: complaintRoutes.js ---
// routes/complaintRoutes.js

const express = require('express');
const router = express.Router();
const complaintController = require('../controllers/complaintController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// All routes require authentication
router.use(authMiddleware);

// Admin-only routes
router.get('/all', roleMiddleware('admin'), complaintController.getAllComplaints);
router.delete('/:id', roleMiddleware('admin'), complaintController.deleteComplaint);

// Admin or Owner can fetch complaints by building and resolve
router.get('/building/:buildingId', roleMiddleware(['admin', 'owner']), complaintController.getComplaintsByBuilding);
router.put('/:id/resolve', roleMiddleware(['admin', 'owner']), complaintController.resolveComplaint);

module.exports = router;

│   │   # --- End: complaintRoutes.js ---

│   │   ├─ ownerRoutes.js

│   │   # --- Begin: ownerRoutes.js ---
const express = require('express');
const router = express.Router();

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyOwnerAssigned } = require('../middleware/roleAccessGuard');
const ownerController = require('../controllers/ownerController');

// 🔐 Authenticate → Confirm Role → Confirm Assignment
router.use(authMiddleware);
router.use(roleMiddleware('owner'));
router.use(verifyOwnerAssigned);

// 📦 Flat Management
router.get('/flats', ownerController.getMyFlats);
router.get('/flats/:id/society', ownerController.getFlatSocietyInfo);

// 📨 Ownership Requests
router.post('/ownership-request', ownerController.submitOwnershipRequest);
router.post('/assign-tenant', ownerController.assignTenantToMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', ownerController.getRentHistory);
router.get('/maintenance-due', ownerController.getUnpaidMaintenance);
router.post('/pay-maintenance/:maintenanceId', ownerController.payMaintenance);

// 🛠 Complaints
router.post('/complaints', ownerController.fileComplaint);
router.get('/complaints', ownerController.getMyComplaints);

// 📊 Dashboard
router.get('/dashboard/overview', ownerController.getOwnerDashboard);

module.exports = router;

│   │   # --- End: ownerRoutes.js ---

│   │   ├─ ownershipRequestRoutes.js

│   │   # --- Begin: ownershipRequestRoutes.js ---
// routes/ownershipRequestRoutes.js

const express = require('express');
const router = express.Router();
const ownershipRequestController = require('../controllers/ownershipRequestController');

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Owner creates and views their requests
router.post('/', authMiddleware, roleMiddleware(['owner']), ownershipRequestController.createOwnershipRequest);
router.get('/my-requests', authMiddleware, roleMiddleware(['owner']), ownershipRequestController.getMyOwnershipRequests);

// Admin views and updates requests
router.get('/admin', authMiddleware, roleMiddleware(['admin']), ownershipRequestController.getAllOwnershipRequests);
router.put('/admin/:id', authMiddleware, roleMiddleware(['admin']), ownershipRequestController.updateOwnershipRequestStatus);

module.exports = router;

│   │   # --- End: ownershipRequestRoutes.js ---

│   │   ├─ tenantRoutes.js

│   │   # --- Begin: tenantRoutes.js ---
const express = require('express');
const router = express.Router();

const tenantController = require('../controllers/tenantController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyTenantAssigned } = require('../middleware/roleAccessGuard');

// 🔐 Middleware to enforce auth + tenant role + flat assignment
router.use(authMiddleware);
router.use(roleMiddleware('tenant'));
router.use(verifyTenantAssigned);

// 🏠 Flat Info
router.get('/my-flat', tenantController.getMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', tenantController.getRentHistory);
router.get('/current-rent', tenantController.getCurrentRent);
router.post('/pay-rent/:rentId', tenantController.payRent);
router.get('/maintenance-due', tenantController.getUnpaidMaintenance);
router.post('/pay-maintenance/:maintenanceId', tenantController.payMaintenance);

// 🛠 Complaints
router.post('/complaints', tenantController.fileComplaint);
router.get('/complaints', tenantController.getMyComplaints);

// 📣 Announcements
router.get('/announcements', tenantController.getAnnouncements);

// 📊 Dashboard
router.get('/dashboard/overview', tenantController.getTenantDashboard);

module.exports = router;

│   │   # --- End: tenantRoutes.js ---

│   ├─ uploads/
│   ├─ utils/
│   │   ├─ generateToken.js

│   │   # --- Begin: generateToken.js ---
const jwt = require('jsonwebtoken');

const generateToken = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  return token;
};

module.exports = generateToken;

│   │   # --- End: generateToken.js ---

│   │   ├─ invoiceGenerator.js

│   │   # --- Begin: invoiceGenerator.js ---
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

const generateInvoice = (invoiceData, filePath) => {
  const doc = new PDFDocument();
  doc.pipe(fs.createWriteStream(filePath));

  doc.fontSize(20).text('Housing Society Invoice', { align: 'center' });

  doc.moveDown();
  doc.fontSize(12).text(`Invoice ID: ${invoiceData._id}`);
  doc.text(`Flat: ${invoiceData.flatNumber}`);
  doc.text(`Name: ${invoiceData.userName}`);
  doc.text(`Amount: ₹${invoiceData.amount}`);
  doc.text(`Due Date: ${invoiceData.dueDate}`);
  doc.text(`Generated On: ${new Date().toLocaleDateString()}`);

  doc.end();
};

module.exports = generateInvoice;

│   │   # --- End: invoiceGenerator.js ---

│   │   ├─ sendEmail.js

│   │   # --- Begin: sendEmail.js ---
const nodemailer = require('nodemailer');

const sendEmail = async (to, subject, text) => {
  try {
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
      console.warn('⚠️ Missing EMAIL credentials in .env');
      return;
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    await transporter.sendMail({ from: process.env.EMAIL_USER, to, subject, text });
  } catch (error) {
    console.error('❌ Failed to send email:', error.message);
  }
};

module.exports = sendEmail;

│   │   # --- End: sendEmail.js ---

│   ├─ validations/
│   │   ├─ userValidation.js

│   │   # --- Begin: userValidation.js ---
const { body } = require('express-validator');

const registerValidation = [
  body('name').notEmpty().withMessage('Name is required'),
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('role').isIn(['admin', 'owner', 'tenant']).withMessage('Invalid role'),
];

const loginValidation = [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
];

module.exports = {
  registerValidation,
  loginValidation,
};

│   │   # --- End: userValidation.js ---

