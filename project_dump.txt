├─ ./
│   ├─ .env

│   # --- Begin: .env ---
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=your_access_token_secret
JWT_REFRESH_SECRET=your_refresh_token_secret

# Server config
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:3000
#In production, set CLIENT_URL in .env to your deployed frontend domain

# MongoDB
MONGO_URI=mongodb://localhost:27017/SRG

# JWT
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password

# Cookies
COOKIE_EXPIRE=7

# For production, override values as needed

│   # --- End: .env ---

│   ├─ .env.example

│   # --- Begin: .env.example ---
PORT=5000
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password
CLIENT_URL=http://localhost:3000
NODE_ENV=development
COOKIE_EXPIRE=7

│   # --- End: .env.example ---

│   ├─ .gitignore

│   # --- Begin: .gitignore ---
# Node.js
node_modules/
.env
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Logs
logs
*.log
pids
*.pid
*.seed
*.pid.lock

# OS
.DS_Store
Thumbs.db

# IDEs
.vscode/
.idea/

# Build output
dist/
build/

# Optional npm cache
.npm/
.cache/
test.py

│   # --- End: .gitignore ---

│   ├─ package.json

│   # --- Begin: package.json ---
{
  "name": "housing-rent-management",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.14.0",
    "morgan": "^1.10.0",
    "nodemailer": "^7.0.3",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

│   # --- End: package.json ---

│   ├─ project_dump.txt

│   # --- Begin: project_dump.txt ---

│   # --- End: project_dump.txt ---

│   ├─ server.js

│   # --- Begin: server.js ---
// ✅ PATCHED: server.js with all routes
const express = require('express');
const dotenv = require('dotenv');
const cookieParser = require('cookie-parser');
const cors = require('cors');
const mongoose = require('mongoose');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
// const mongoSanitize = require('express-mongo-sanitize');
// const xss = require('xss-clean');
const compression = require('compression');

const connectDB = require('./config/db');
const { errorHandler } = require('./middleware/errorHandler');

// Route Imports
const authRoutes = require('./routes/authRoutes');
const adminRoutes = require('./routes/adminRoutes');
const ownerRoutes = require('./routes/ownerRoutes');
const tenantRoutes = require('./routes/tenantRoutes');
const complaintRoutes = require('./routes/complaintRoutes');
const announcementRoutes = require('./routes/announcementRoutes');
const ownershipRequestRoutes = require('./routes/ownershipRequestRoutes');

dotenv.config();
connectDB();

const app = express();

// === Global Middleware ===
app.use(helmet());
// app.use(xss());
// app.use(mongoSanitize());
app.use(compression());
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests from this IP, try again later.'
}));

app.use(express.json());
app.use(cookieParser());

// ✅ CORS for dev/prod
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true,
}));

// === Routes ===
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/owner', ownerRoutes);
app.use('/api/tenant', tenantRoutes);
app.use('/api/complaints', complaintRoutes);
app.use('/api/announcements', announcementRoutes); // ✅ Added
app.use('/api/ownership-requests', ownershipRequestRoutes); // ✅ Added

// Default Route
app.get('/', (req, res) => {
  res.send('Housing Society & Rent Management System API is running');
});

// Error Handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`🚀 Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});
│   # --- End: server.js ---

│   ├─ test.py

│   # --- Begin: test.py ---
import os

def dump_project_to_txt(root_dir, output_file):
    """
    Dumps the full file structure and content of all files in the project,
    excluding only specific heavy/unnecessary folders and specific files.
    """
    # Folders to completely ignore (e.g., large or non-code)
    skip_dirs = {
        "node_modules", ".git", "__pycache__", "venv",
        ".idea", ".vscode", "dist", "build", ".mypy_cache"
    }

    # Specific filenames to ignore (e.g., lockfiles or OS files)
    skip_files = {
        "package-lock.json", "yarn.lock", ".DS_Store", "README.md"
    }

    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude unwanted directories during traversal
            dirnames[:] = [d for d in dirnames if d not in skip_dirs]

            level = dirpath.replace(root_dir, "").count(os.sep)
            indent = "│   " * level
            f.write(f"{indent}├─ {os.path.basename(dirpath)}/\n")

            sub_indent = "│   " * (level + 1)
            for filename in filenames:
                if filename in skip_files:
                    continue

                full_path = os.path.join(dirpath, filename)
                f.write(f"{sub_indent}├─ {filename}\n")

                try:
                    with open(full_path, "r", encoding="utf-8") as code_file:
                        code = code_file.read()
                        f.write(f"\n{sub_indent}# --- Begin: {filename} ---\n")
                        f.write(code + "\n")
                        f.write(f"{sub_indent}# --- End: {filename} ---\n\n")
                except Exception as e:
                    f.write(f"{sub_indent}[Could not read {filename}: {e}]\n")

# Example usage
dump_project_to_txt(".", "project_dump.txt")

│   # --- End: test.py ---

│   ├─ config/
│   │   ├─ db.js

│   │   # --- Begin: db.js ---
// config/db.js

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      // These options are for Mongoose >= 6
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`✅ MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`❌ MongoDB Connection Error: ${error.message}`);
    process.exit(1); // Stop the app if DB connection fails
  }
};

module.exports = connectDB;

│   │   # --- End: db.js ---

│   ├─ controllers/
│   │   ├─ adminController.js

│   │   # --- Begin: adminController.js ---
const Society = require('../models/Society');
const Building = require('../models/Building');
const Flat = require('../models/Flat');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const OwnershipRequest = require('../models/OwnershipRequest');
const Announcement = require('../models/Announcement');
const Complaint = require('../models/Complaint');
const Rent = require('../models/Rent');
const sendEmail = require('../utils/sendEmail');
const formatResponse = require('../utils/responseFormatter');

// === SOCIETIES ===

exports.getMySocieties = async (req, res, next) => {
  try {
    const societies = await Society.find({ admin: req.user._id });
    res.json(formatResponse({ message: 'Societies retrieved', data: societies }));
  } catch (err) {
    next(err);
  }
};

// === BUILDINGS ===

exports.createBuilding = async (req, res, next) => {
  try {
    const { societyId, name, totalFloors, totalFlats, addressLabel } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    const building = await Building.create({ name, totalFloors, totalFlats, addressLabel, society: societyId });
    society.totalBuildings += 1;
    await society.save();

    res.status(201).json(formatResponse({ message: 'Building created', data: building }));
  } catch (err) {
    next(err);
  }
};

exports.deleteBuilding = async (req, res, next) => {
  try {
    const building = await Building.findByIdAndDelete(req.params.id);
    if (!building) return res.status(404).json(formatResponse({ success: false, message: 'Building not found', statusCode: 404 }));

    res.json(formatResponse({ message: 'Building deleted' }));
  } catch (err) {
    next(err);
  }
};

// === FLAT OWNERSHIP ===

exports.assignFlatOwner = async (req, res, next) => {
  try {
    const { ownerId } = req.body;
    const flat = await Flat.findById(req.params.flatId).populate('society');
    const owner = await User.findById(ownerId);

    if (!flat || !owner || owner.role !== 'owner') {
      return res.status(400).json(formatResponse({ success: false, message: 'Invalid flat or owner', statusCode: 400 }));
    }

    flat.owner = owner._id;
    await flat.save();

    if (!owner.society) {
      owner.society = flat.society._id;
      await owner.save();
    }

    res.json(formatResponse({ message: 'Owner assigned successfully', data: flat }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatOwner = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json(formatResponse({ success: false, message: 'Flat not found', statusCode: 404 }));

    flat.owner = null;
    await flat.save();
    res.json(formatResponse({ message: 'Owner removed successfully' }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatTenant = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json(formatResponse({ success: false, message: 'Flat not found', statusCode: 404 }));

    flat.tenant = null;
    flat.isRented = false;
    flat.occupancyStatus = 'vacant';
    await flat.save();
    res.json(formatResponse({ message: 'Tenant removed successfully' }));
  } catch (err) {
    next(err);
  }
};

// === MAINTENANCE ===

exports.generateMaintenance = async (req, res, next) => {
  try {
    const { societyId, billingMonth } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    const flats = await Flat.find({ society: societyId });
    const amount = society.maintenancePolicy.amountPerFlat;

    const records = await Maintenance.insertMany(flats.map(flat => ({
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      billingMonth,
      amount,
      generatedBy: req.user._id,
    })));

    res.status(201).json(formatResponse({ message: 'Maintenance generated', data: records }));
  } catch (err) {
    next(err);
  }
};

exports.getMaintenanceStatus = async (req, res, next) => {
  try {
    const { filterBy, id } = req.query;
    let query = {};

    if (filterBy === 'society') query.society = id;
    else if (filterBy === 'flat') query.flat = id;
    else if (filterBy === 'user') {
      const flats = await Flat.find({ $or: [{ owner: id }, { tenant: id }] }, '_id');
      query.flat = { $in: flats.map(f => f._id) };
    }

    const records = await Maintenance.find(query)
      .populate('flat', 'flatNumber')
      .populate('building', 'name');

    res.json(formatResponse({ message: 'Maintenance records retrieved', data: records }));
  } catch (err) {
    next(err);
  }
};

// === RENT ===

exports.getRentHistory = async (req, res, next) => {
  try {
    const rentRecords = await Rent.find().populate('flat', 'flatNumber').populate('tenant', 'name email');
    res.json(formatResponse({ message: 'Rent history retrieved', data: rentRecords }));
  } catch (err) {
    next(err);
  }
};

// === OWNERSHIP REQUESTS ===

exports.getOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ status: 'pending' }).populate('flat currentOwner');
    res.json(formatResponse({ message: 'Ownership requests fetched', data: requests }));
  } catch (err) {
    next(err);
  }
};

exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;
    const request = await OwnershipRequest.findById(requestId);
    if (!request) return res.status(404).json(formatResponse({ success: false, message: 'Request not found', statusCode: 404 }));

    request.status = status;
    request.reviewedBy = req.user._id;
    request.reviewedOn = new Date();
    request.adminNote = note;
    await request.save();

    if (status === 'approved') {
      await Flat.findByIdAndUpdate(request.flat, { owner: request.currentOwner });
    }

    res.json(formatResponse({ message: 'Request reviewed', data: request }));
  } catch (err) {
    next(err);
  }
};

// === ANNOUNCEMENTS ===

exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, society, building, audience, validTill } = req.body;

    const announcement = await Announcement.create({
      title,
      message,
      createdBy: req.user._id,
      society,
      building: building || null,
      audience,
      validTill: validTill || null,
    });

    res.status(201).json(formatResponse({ message: 'Announcement created', data: announcement }));
  } catch (err) {
    next(err);
  }
};

// === COMPLAINTS ===

exports.getComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({}).populate('raisedBy flat building society');
    res.json(formatResponse({ message: 'All complaints retrieved', data: complaints }));
  } catch (err) {
    next(err);
  }
};

exports.updateComplaintStatus = async (req, res, next) => {
  try {
    const { complaintId, status, adminNote } = req.body;
    const complaint = await Complaint.findById(complaintId);
    if (!complaint) return res.status(404).json(formatResponse({ success: false, message: 'Complaint not found', statusCode: 404 }));

    complaint.status = status;
    complaint.adminNote = adminNote || '';
    complaint.resolvedBy = req.user._id;
    complaint.resolvedOn = new Date();
    await complaint.save();

    res.json(formatResponse({ message: 'Complaint updated', data: complaint }));
  } catch (err) {
    next(err);
  }
};

// === DASHBOARD ===

exports.getAdminDashboard = async (req, res, next) => {
  try {
    const totalFlats = await Flat.countDocuments();
    const totalTenants = await User.countDocuments({ role: 'tenant' });
    const totalOwners = await User.countDocuments({ role: 'owner' });
    const totalPendingComplaints = await Complaint.countDocuments({ status: 'pending' });

    res.json(formatResponse({
      message: 'Admin dashboard data',
      data: { totalFlats, totalTenants, totalOwners, totalPendingComplaints }
    }));
  } catch (err) {
    next(err);
  }
};

// === AGREEMENTS ===

exports.getAllAgreements = async (req, res, next) => {
  try {
    res.status(501).json(formatResponse({ message: 'Agreement system not implemented yet' }));
  } catch (err) {
    next(err);
  }
};

// === NOTES & REMINDERS ===

exports.addSocietyNote = async (req, res, next) => {
  try {
    const { note } = req.body;
    const society = await Society.findById(req.params.id);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    society.adminNote = note;
    await society.save();
    res.json(formatResponse({ message: 'Note added to society' }));
  } catch (err) {
    next(err);
  }
};

exports.sendReminderToUser = async (req, res, next) => {
  try {
    const { userId, subject, message } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json(formatResponse({ success: false, message: 'User not found', statusCode: 404 }));

    await sendEmail(user.email, subject, message);
    res.json(formatResponse({ message: 'Reminder sent' }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: adminController.js ---

│   │   ├─ announcementController.js

│   │   # --- Begin: announcementController.js ---
const Announcement = require('../models/Announcement');
const Flat = require('../models/Flat');
const formatResponse = require('../utils/responseFormatter');

// Create a new announcement
exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, audience, society, building, validTill } = req.body;

    const announcement = await Announcement.create({
      title,
      message,
      audience,
      society,
      building: building || null,
      validTill: validTill || null,
      createdBy: req.user._id,
    });

    res.status(201).json(formatResponse({
      message: 'Announcement created',
      data: announcement
    }));
  } catch (err) {
    next(err);
  }
};

// Get announcements for logged-in user based on role and society/building
exports.getMyAnnouncements = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({
      $or: [
        { tenant: req.user._id },
        { owner: req.user._id }
      ]
    });

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const announcements = await Announcement.find({
      society: flat.society,
      $or: [
        { audience: 'all' },
        { audience: req.user.role },
        { building: null },
        { building: flat.building }
      ],
      $or: [
        { validTill: null },
        { validTill: { $gte: new Date() } }
      ]
    }).sort({ createdAt: -1 });

    res.status(200).json(formatResponse({
      message: 'Relevant announcements retrieved',
      data: announcements
    }));
  } catch (err) {
    next(err);
  }
};

// Get all announcements (admin use)
exports.getAllAnnouncements = async (req, res, next) => {
  try {
    const announcements = await Announcement.find()
      .populate('createdBy', 'name email role')
      .populate('society', 'name')
      .populate('building', 'name');

    res.status(200).json(formatResponse({
      message: 'All announcements retrieved',
      data: announcements
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: announcementController.js ---

│   │   ├─ authController.js

│   │   # --- Begin: authController.js ---
// controllers/authController.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Flat = require('../models/Flat');
const generateToken = require('../utils/generateToken');
const { asyncHandler } = require('../middleware/errorHandler');
const formatResponse = require('../utils/responseFormatter');

// REGISTER USER
exports.registerUser = asyncHandler(async (req, res) => {
  const { name, email, password, phone, role = 'tenant' } = req.body;

  const existingUser = await User.findOne({ email });
  if (existingUser) {
    return res.status(400).json(formatResponse({
      success: false,
      message: 'Email is already registered',
      statusCode: 400
    }));
  }

  const user = await User.create({ name, email, password, phone, role });

  generateToken(res, user._id);

  res.status(201).json(formatResponse({
    message: 'User registered successfully',
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role
    }
  }));
});

// LOGIN
exports.loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  const user = await User.findOne({ email }).select('+password');
  if (!user || !(await user.comparePassword(password))) {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Invalid email or password',
      statusCode: 401
    }));
  }

  if (user.role === 'owner') {
    const flat = await Flat.findOne({ owner: user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Owner is not assigned to any flat yet',
        statusCode: 403
      }));
    }
  }

  if (user.role === 'tenant') {
    const flat = await Flat.findOne({ tenant: user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Tenant is not assigned to any flat yet',
        statusCode: 403
      }));
    }
  }

  generateToken(res, user._id);

  res.status(200).json(formatResponse({
    message: 'Login successful',
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role
    }
  }));
});

// LOGOUT
exports.logoutUser = asyncHandler(async (req, res) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0),
  });

  res.status(200).json(formatResponse({
    message: 'Logged out successfully'
  }));
});

// GET CURRENT USER
exports.getMe = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user._id).select('-password');
  if (!user) {
    return res.status(404).json(formatResponse({
      success: false,
      message: 'User not found',
      statusCode: 404
    }));
  }

  res.status(200).json(formatResponse({
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role,
      society: user.society || null
    }
  }));
});

// CHANGE PASSWORD
exports.changePassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  const user = await User.findById(req.user._id).select('+password');

  if (!user || !(await user.comparePassword(currentPassword))) {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Current password is incorrect',
      statusCode: 401
    }));
  }

  user.password = newPassword;
  await user.save();

  res.status(200).json(formatResponse({
    message: 'Password updated successfully'
  }));
});

// TOKEN STATUS
exports.tokenStatus = asyncHandler(async (req, res) => {
  const token = req.cookies.token || (
    req.headers.authorization?.startsWith('Bearer') &&
    req.headers.authorization.split(' ')[1]
  );

  if (!token) {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Token missing',
      statusCode: 401
    }));
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    return res.status(200).json(formatResponse({
      message: 'Token is valid',
      data: { userId: decoded.id }
    }));
  } catch {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Invalid token',
      statusCode: 401
    }));
  }
});

│   │   # --- End: authController.js ---

│   │   ├─ complaintController.js

│   │   # --- Begin: complaintController.js ---
const Complaint = require('../models/Complaint');
const Flat = require('../models/Flat');
const formatResponse = require('../utils/responseFormatter');

// Get all complaints (for admin)
exports.getAllComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find()
      .populate('raisedBy', 'name email role')
      .populate('flat')
      .populate('building')
      .populate('society');

    res.status(200).json(formatResponse({
      message: 'All complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};

// Get single complaint by ID
exports.getComplaintById = async (req, res, next) => {
  try {
    const complaint = await Complaint.findById(req.params.id)
      .populate('raisedBy', 'name email role')
      .populate('flat')
      .populate('building')
      .populate('society');

    if (!complaint) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Complaint not found',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Complaint retrieved',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// Update complaint status (Admin)
exports.updateComplaint = async (req, res, next) => {
  try {
    const { status, adminNote } = req.body;

    const complaint = await Complaint.findById(req.params.id);
    if (!complaint) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Complaint not found',
        statusCode: 404
      }));
    }

    complaint.status = status || complaint.status;
    complaint.adminNote = adminNote || complaint.adminNote;
    complaint.resolvedBy = req.user._id;
    complaint.resolvedOn = new Date();

    await complaint.save();

    res.status(200).json(formatResponse({
      message: 'Complaint updated successfully',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// Get complaints by current user (if needed here too)
exports.getMyComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({ raisedBy: req.user._id })
      .populate('flat')
      .populate('building')
      .populate('society');

    res.status(200).json(formatResponse({
      message: 'My complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};

// File a new complaint
exports.createComplaint = async (req, res, next) => {
  try {
    const { flatId, category, subject, description } = req.body;

    const flat = await Flat.findById(flatId).populate('building').populate('society');
    if (!flat) {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Flat not found',
        statusCode: 400
      }));
    }

    const complaint = await Complaint.create({
      raisedBy: req.user._id,
      userRole: req.user.role,
      flat: flat._id,
      building: flat.building._id,
      society: flat.society._id,
      category,
      subject,
      description
    });

    res.status(201).json(formatResponse({
      message: 'Complaint created',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: complaintController.js ---

│   │   ├─ ownerController.js

│   │   # --- Begin: ownerController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const OwnershipRequest = require('../models/OwnershipRequest');
const Rent = require('../models/Rent');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const formatResponse = require('../utils/responseFormatter');

// 1. Get all flats owned by logged-in owner
exports.getMyFlats = async (req, res, next) => {
  try {
    const flats = await Flat.find({ owner: req.user._id })
      .populate('building')
      .populate('tenant');

    res.status(200).json(formatResponse({
      message: 'Flats retrieved',
      data: flats
    }));
  } catch (err) {
    next(err);
  }
};

// 2. View society/building info of a specific flat
exports.getFlatSocietyInfo = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ _id: req.params.id, owner: req.user._id })
      .populate('building')
      .populate('society');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found or unauthorized',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Flat info retrieved',
      data: {
        building: flat.building,
        society: flat.society
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Submit ownership transfer request
exports.submitOwnershipRequest = async (req, res, next) => {
  try {
    const { flatId, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flat = await Flat.findById(flatId);
    if (!flat || flat.owner.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized for this flat',
        statusCode: 403
      }));
    }

    const request = await OwnershipRequest.create({
      flat: flatId,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    res.status(201).json(formatResponse({
      message: 'Ownership request submitted',
      data: request
    }));
  } catch (err) {
    next(err);
  }
};

// 4. Rent payment history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ owner: req.user._id })
      .populate('flat')
      .populate('tenant');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 5. File complaint
exports.fileComplaint = async (req, res, next) => {
  try {
    const { flatId, category, subject, description } = req.body;

    const flat = await Flat.findOne({ _id: flatId, owner: req.user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized access to flat',
        statusCode: 403
      }));
    }

    const complaint = await Complaint.create({
      raisedBy: req.user._id,
      userRole: 'owner',
      flat: flatId,
      building: flat.building,
      society: flat.society,
      category,
      subject,
      description,
    });

    res.status(201).json(formatResponse({
      message: 'Complaint submitted',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// 6. View own complaints
exports.getMyComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({ raisedBy: req.user._id, userRole: 'owner' })
      .populate('flat')
      .populate('building');

    res.status(200).json(formatResponse({
      message: 'Complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};

// 7. Dashboard summary
exports.getOwnerDashboard = async (req, res, next) => {
  try {
    const flats = await Flat.find({ owner: req.user._id });
    const flatIds = flats.map(f => f._id);

    const rentCount = await Rent.countDocuments({ flat: { $in: flatIds } });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'owner' });

    res.status(200).json(formatResponse({
      message: 'Dashboard data retrieved',
      data: {
        totalFlatsOwned: flats.length,
        rentPaymentsMade: rentCount,
        complaintsFiled: complaintCount
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 8. View unpaid maintenance bills for owner flats
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flats = await Flat.find({
      owner: req.user._id,
      $or: [{ tenant: null }, { tenant: { $exists: false } }]
    });

    const flatIds = flats.map(f => f._id);

    const maintenance = await Maintenance.find({
      flat: { $in: flatIds },
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 9. Pay maintenance for owner flats
exports.payMaintenance = async (req, res, next) => {
  try {
    const maintenance = await Maintenance.findById(req.params.maintenanceId).populate('flat');

    if (!maintenance) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Maintenance not found',
        statusCode: 404
      }));
    }

    const isOwnedByUser = maintenance.flat.owner.toString() === req.user._id.toString();
    const isVacantOrOwnerOccupied = !maintenance.flat.tenant;

    if (!isOwnedByUser || !isVacantOrOwnerOccupied) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized: not owner-occupied or already rented',
        statusCode: 403
      }));
    }

    if (maintenance.isPaid) {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Already paid',
        statusCode: 400
      }));
    }

    maintenance.isPaid = true;
    maintenance.paidAt = new Date();
    await maintenance.save();

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 10. Assign tenant to flat
exports.assignTenantToMyFlat = async (req, res, next) => {
  try {
    const { flatId, tenantId } = req.body;

    const flat = await Flat.findOne({ _id: flatId, owner: req.user._id }).populate('society');
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized or flat not found',
        statusCode: 403
      }));
    }

    const tenant = await User.findById(tenantId);
    if (!tenant || tenant.role !== 'tenant') {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Invalid tenant user',
        statusCode: 400
      }));
    }

    flat.tenant = tenant._id;
    flat.isRented = true;
    flat.occupancyStatus = 'occupied';
    await flat.save();

    if (!tenant.society) {
      tenant.society = flat.society._id;
      await tenant.save();
    }

    res.status(200).json(formatResponse({
      message: 'Tenant assigned successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: ownerController.js ---

│   │   ├─ ownershipRequestController.js

│   │   # --- Begin: ownershipRequestController.js ---
const OwnershipRequest = require('../models/OwnershipRequest');
const Flat = require('../models/Flat');
const formatResponse = require('../utils/responseFormatter');

// Submit ownership request
exports.submitOwnershipRequest = async (req, res, next) => {
  try {
    const { flatId, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flat = await Flat.findById(flatId);
    if (!flat || flat.owner.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized request',
        statusCode: 403
      }));
    }

    const request = await OwnershipRequest.create({
      flat: flatId,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    res.status(201).json(formatResponse({
      message: 'Ownership request submitted',
      data: request
    }));
  } catch (err) {
    next(err);
  }
};

// Get ownership requests submitted by owner
exports.getMyOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ currentOwner: req.user._id })
      .populate('flat');

    res.status(200).json(formatResponse({
      message: 'Your ownership requests retrieved',
      data: requests
    }));
  } catch (err) {
    next(err);
  }
};

// Get all ownership requests (admin use)
exports.getAllOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find()
      .populate('flat')
      .populate('currentOwner', 'name email');

    res.status(200).json(formatResponse({
      message: 'All ownership requests retrieved',
      data: requests
    }));
  } catch (err) {
    next(err);
  }
};

// Review ownership request (admin)
exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;

    const request = await OwnershipRequest.findById(requestId);
    if (!request) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Request not found',
        statusCode: 404
      }));
    }

    request.status = status;
    request.adminNote = note;
    request.reviewedBy = req.user._id;
    request.reviewedOn = new Date();
    await request.save();

    if (status === 'approved') {
      await Flat.findByIdAndUpdate(request.flat, {
        owner: request.currentOwner
      });
    }

    res.status(200).json(formatResponse({
      message: `Ownership request ${status}`,
      data: request
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: ownershipRequestController.js ---

│   │   ├─ tenantController.js

│   │   # --- Begin: tenantController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');
const Announcement = require('../models/Announcement');
const formatResponse = require('../utils/responseFormatter');

// 1. Get assigned flat
exports.getMyFlat = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id })
      .populate('building')
      .populate('owner');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not assigned',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Assigned flat retrieved',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

// 2. Rent history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ tenant: req.user._id })
      .populate('flat');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Pay rent
exports.payRent = async (req, res, next) => {
  try {
    const rent = await Rent.findById(req.params.rentId).populate('tenant');
    if (!rent || rent.tenant._id.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized rent payment attempt',
        statusCode: 403
      }));
    }

    if (rent.isPaid) {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Rent already paid',
        statusCode: 400
      }));
    }

    rent.isPaid = true;
    rent.paidAt = new Date();
    await rent.save();

    res.status(200).json(formatResponse({
      message: 'Rent paid successfully',
      data: rent
    }));
  } catch (err) {
    next(err);
  }
};

// 4. File complaint
exports.fileComplaint = async (req, res, next) => {
  try {
    const { flatId, category, subject, description } = req.body;

    const flat = await Flat.findOne({ _id: flatId, tenant: req.user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized access to flat',
        statusCode: 403
      }));
    }

    const complaint = await Complaint.create({
      raisedBy: req.user._id,
      userRole: 'tenant',
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      category,
      subject,
      description,
    });

    res.status(201).json(formatResponse({
      message: 'Complaint filed',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// 5. View own complaints
exports.getMyComplaints = async (req, res, next) => {
  try {
    const complaints = await Complaint.find({
      raisedBy: req.user._id,
      userRole: 'tenant'
    }).populate('flat').populate('building');

    res.status(200).json(formatResponse({
      message: 'Complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};

// 6. View announcements
exports.getRelevantAnnouncements = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const announcements = await Announcement.find({
      society: flat.society,
      $or: [
        { audience: 'all' },
        { audience: 'tenants' },
        { building: null },
        { building: flat.building }
      ],
      $or: [
        { validTill: null },
        { validTill: { $gte: new Date() } }
      ]
    }).sort({ createdAt: -1 });

    res.status(200).json(formatResponse({
      message: 'Announcements retrieved',
      data: announcements
    }));
  } catch (err) {
    next(err);
  }
};

// 7. View unpaid maintenance
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized',
        statusCode: 403
      }));
    }

    const maintenance = await Maintenance.find({
      flat: flat._id,
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 8. Pay maintenance
exports.payMaintenance = async (req, res, next) => {
  try {
    const maintenance = await Maintenance.findById(req.params.maintenanceId).populate('flat');
    if (!maintenance || maintenance.flat.tenant.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized or not found',
        statusCode: 403
      }));
    }

    if (maintenance.isPaid) {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Already paid',
        statusCode: 400
      }));
    }

    maintenance.isPaid = true;
    maintenance.paidAt = new Date();
    await maintenance.save();

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 9. Dashboard overview
exports.getTenantDashboard = async (req, res, next) => {
  try {
    const rentCount = await Rent.countDocuments({ tenant: req.user._id });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'tenant' });
    const unpaidMaintenance = await Maintenance.countDocuments({ isPaid: false, flat: (await Flat.findOne({ tenant: req.user._id }))._id });

    res.status(200).json(formatResponse({
      message: 'Dashboard retrieved',
      data: {
        rentPayments: rentCount,
        complaintsFiled: complaintCount,
        unpaidMaintenanceCount: unpaidMaintenance
      }
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: tenantController.js ---

│   ├─ logs/
│   │   ├─ combined.log

│   │   # --- Begin: combined.log ---

│   │   # --- End: combined.log ---

│   ├─ middleware/
│   │   ├─ authMiddleware.js

│   │   # --- Begin: authMiddleware.js ---
// middleware/authMiddleware.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  let token = req.cookies.token;

  if (!token && req.headers.authorization?.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ success: false, message: 'Unauthorized: Token missing' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    if (!user) return res.status(401).json({ success: false, message: 'User not found' });

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ success: false, message: 'Invalid or expired token' });
  }
};

module.exports = authMiddleware;

│   │   # --- End: authMiddleware.js ---

│   │   ├─ errorHandler.js

│   │   # --- Begin: errorHandler.js ---
// middleware/errorHandler.js

const errorHandler = (err, req, res, next) => {
  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? null : err.stack,
  });
};

const asyncHandler = (fn) => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);

module.exports = { errorHandler, asyncHandler };

│   │   # --- End: errorHandler.js ---

│   │   ├─ roleAccessGuard.js

│   │   # --- Begin: roleAccessGuard.js ---
const Flat = require('../models/Flat');

// Check if owner is assigned to any flat
const verifyOwnerAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ owner: req.user._id });
  if (!flat) return res.status(403).json({ message: "Owner is not registered or assigned to any flat yet." });
  next();
};

// Check if tenant is assigned to any flat
const verifyTenantAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ tenant: req.user._id });
  if (!flat) return res.status(403).json({ message: "Tenant is not assigned to any flat yet." });
  next();
};

module.exports = {
  verifyOwnerAssigned,
  verifyTenantAssigned
};

│   │   # --- End: roleAccessGuard.js ---

│   │   ├─ roleMiddleware.js

│   │   # --- Begin: roleMiddleware.js ---
// middleware/roleMiddleware.js

const roleMiddleware = (roles) => {
  const allowedRoles = Array.isArray(roles) ? roles : [roles];
  return (req, res, next) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'Access denied: Insufficient permissions' });
    }
    next();
  };
};

module.exports = roleMiddleware;

│   │   # --- End: roleMiddleware.js ---

│   ├─ models/
│   │   ├─ Announcement.js

│   │   # --- Begin: Announcement.js ---
// models/Announcement.js

const mongoose = require('mongoose');

const announcementSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Announcement title is required'],
    trim: true,
  },
  message: {
    type: String,
    required: [true, 'Announcement message is required'],
    trim: true,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    required: [true, 'Admin reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Target society is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    default: null, // If null, applies to whole society
  },
  audience: {
    type: String,
    enum: ['all', 'owners', 'tenants'],
    default: 'all',
  },
  validTill: {
    type: Date,
    default: null, // Optional expiry
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Announcement', announcementSchema);

│   │   # --- End: Announcement.js ---

│   │   ├─ Building.js

│   │   # --- Begin: Building.js ---
// models/Building.js

const mongoose = require('mongoose');

const buildingSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Building name is required'],
    trim: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  totalFloors: {
    type: Number,
    required: [true, 'Total number of floors is required'],
    min: [1, 'There must be at least 1 floor'],
  },
  totalFlats: {
    type: Number,
    required: [true, 'Total number of flats is required'],
    min: [1, 'There must be at least 1 flat'],
  },
  addressLabel: {
    type: String,
    trim: true,
    default: '',
    // Optional label if address differs from society (e.g., "Wing B, Gate 2")
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Building', buildingSchema);

│   │   # --- End: Building.js ---

│   │   ├─ Complaint.js

│   │   # --- Begin: Complaint.js ---
// models/Complaint.js

const mongoose = require('mongoose');

const complaintSchema = new mongoose.Schema({
  raisedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User who raised the complaint is required'],
  },
  userRole: {
    type: String,
    enum: ['owner', 'tenant'],
    required: true,
  },
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: true,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  category: {
    type: String,
    enum: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    default: 'other',
  },
  subject: {
    type: String,
    required: [true, 'Complaint subject is required'],
    trim: true,
  },
  description: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['open', 'in-progress', 'resolved', 'rejected'],
    default: 'open',
  },
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  resolvedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});
complaintSchema.index({ raisedBy: 1 });
complaintSchema.index({ flat: 1 });
complaintSchema.index({ society: 1 });


module.exports = mongoose.model('Complaint', complaintSchema);

│   │   # --- End: Complaint.js ---

│   │   ├─ Flat.js

│   │   # --- Begin: Flat.js ---
// models/Flat.js

const mongoose = require('mongoose');

const flatSchema = new mongoose.Schema({
  flatNumber: {
    type: String,
    required: [true, 'Flat number is required'],
    trim: true,
  },
  floor: {
    type: Number,
    required: [true, 'Floor number is required'],
    min: 0,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner user reference is required'],
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  isRented: {
    type: Boolean,
    default: false,
  },
  occupancyStatus: {
    type: String,
    enum: ['vacant', 'occupied-owner', 'occupied-tenant'],
    default: 'vacant',
  },
}, {
  timestamps: true,
});
flatSchema.index({ tenant: 1 });
flatSchema.index({ society: 1 });
flatSchema.index({ building: 1 });

module.exports = mongoose.model('Flat', flatSchema);

│   │   # --- End: Flat.js ---

│   │   ├─ Maintenance.js

│   │   # --- Begin: Maintenance.js ---
// models/Maintenance.js

const mongoose = require('mongoose');

const maintenanceSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  amount: {
    type: Number,
    required: [true, 'Maintenance amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Typically an Admin
    required: true,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Maintenance', maintenanceSchema);

│   │   # --- End: Maintenance.js ---

│   │   ├─ OwnershipRequest.js

│   │   # --- Begin: OwnershipRequest.js ---
// models/OwnershipRequest.js

const mongoose = require('mongoose');

const ownershipRequestSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  currentOwner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Current owner reference is required'],
  },
  newOwnerName: {
    type: String,
    required: [true, 'New owner name is required'],
    trim: true,
  },
  newOwnerEmail: {
    type: String,
    required: [true, 'New owner email is required'],
    trim: true,
    lowercase: true,
  },
  newOwnerPhone: {
    type: String,
    required: [true, 'New owner phone number is required'],
    trim: true,
  },
  reason: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'pending',
  },
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    default: null,
  },
  reviewedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('OwnershipRequest', ownershipRequestSchema);

│   │   # --- End: OwnershipRequest.js ---

│   │   ├─ Rent.js

│   │   # --- Begin: Rent.js ---
// models/Rent.js

const mongoose = require('mongoose');

const rentSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Tenant reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner reference is required'],
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  rentAmount: {
    type: Number,
    required: [true, 'Rent amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  paymentMode: {
    type: String,
    enum: ['cash', 'online', 'bank-transfer', 'upi'],
    default: 'online',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Rent', rentSchema);

│   │   # --- End: Rent.js ---

│   │   ├─ Society.js

│   │   # --- Begin: Society.js ---
// models/Society.js

const mongoose = require('mongoose');

const societySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Society name is required'],
    trim: true,
  },
  address: {
    street: { type: String, required: true, trim: true },
    city: { type: String, required: true, trim: true },
    state: { type: String, required: true, trim: true },
    pincode: { type: String, required: true, trim: true },
  },
  registrationNumber: {
    type: String,
    required: [true, 'Registration number is required'],
    unique: true,
    trim: true,
  },
  totalBuildings: {
    type: Number,
    default: 0,
    min: 0,
  },
  maintenancePolicy: {
    frequency: {
      type: String,
      enum: ['monthly', 'quarterly'],
      default: 'monthly',
    },
    amountPerFlat: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  admin: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Admin user is required'],
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Society', societySchema);

│   │   # --- End: Society.js ---

│   │   ├─ User.js

│   │   # --- Begin: User.js ---
// models/User.js

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// Role constants
const ROLES = ['admin', 'owner', 'tenant'];

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide your name'],
    trim: true,
    maxlength: [50, 'Name cannot exceed 50 characters'],
  },
  email: {
    type: String,
    required: [true, 'Please provide your email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\S+@\S+\.\S+$/,
      'Please provide a valid email address',
    ],
  },
  password: {
    type: String,
    required: [true, 'Please set a password'],
    minlength: [6, 'Password must be at least 6 characters'],
    select: false, // Hide in queries by default
  },
  role: {
    type: String,
    enum: ROLES,
    default: 'tenant',
  },
  phone: {
    type: String,
    trim: true,
    maxlength: 15,
  },
  profilePic: {
    type: String, // URL to profile image (optional)
    default: '',
  },
  loginAttempts: {
    type: Number,
    default: 0,
  },
  lastLogin: {
    type: Date,
    default: null,
  },
  isActive: {
    type: Boolean,
    default: true,
  },
}, {
  timestamps: true,
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next(); // Only hash if changed

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Method to compare entered password with stored hash
userSchema.methods.comparePassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

│   │   # --- End: User.js ---

│   ├─ routes/
│   │   ├─ adminRoutes.js

│   │   # --- Begin: adminRoutes.js ---
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Admin-only routes
router.use(authMiddleware);
router.use(roleMiddleware('admin'));

// Core society & building management
router.get('/societies', adminController.getMySocieties);
router.post('/buildings', adminController.createBuilding);
router.delete('/buildings/:id', adminController.deleteBuilding);

// Flat management
router.patch('/flats/:flatId/assign-owner', adminController.assignFlatOwner);
router.patch('/flats/:flatId/remove-owner', adminController.removeFlatOwner);
// router.patch('/flats/:flatId/assign-tenant', adminController.assignFlatTenant);
router.patch('/flats/:flatId/remove-tenant', adminController.removeFlatTenant);

// Maintenance
router.post('/maintenance', adminController.generateMaintenance);
router.get('/maintenance/status', adminController.getMaintenanceStatus);

// Rent
router.get('/rent/history', adminController.getRentHistory);

// Ownership requests
router.get('/ownership-requests', adminController.getOwnershipRequests);
router.post('/ownership-requests/review', adminController.reviewOwnershipRequest);

// Announcements
router.post('/announcements', adminController.createAnnouncement);

// Complaints
router.get('/complaints', adminController.getComplaints);
router.patch('/complaints', adminController.updateComplaintStatus);

// Dashboard & documents
router.get('/dashboard/overview', adminController.getAdminDashboard);
router.get('/documents', adminController.getAllAgreements);

// Notes & reminders
router.post('/societies/:id/note', adminController.addSocietyNote);
router.post('/reminders', adminController.sendReminderToUser);

module.exports = router;

│   │   # --- End: adminRoutes.js ---

│   │   ├─ announcementRoutes.js

│   │   # --- Begin: announcementRoutes.js ---
// routes/announcementRoutes.js

const express = require('express');
const router = express.Router();
const announcementController = require('../controllers/announcementController');

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Protected routes for admin
router.post('/', authMiddleware, roleMiddleware(['admin']), announcementController.createAnnouncement);
router.delete('/:id', authMiddleware, roleMiddleware(['admin']), announcementController.deleteAnnouncement);

// Public route to fetch announcements for a society (optionally filter by building)
router.get('/:societyId', authMiddleware, announcementController.getAnnouncements);

module.exports = router;

│   │   # --- End: announcementRoutes.js ---

│   │   ├─ authRoutes.js

│   │   # --- Begin: authRoutes.js ---
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');

const authMiddleware = require('../middleware/authMiddleware');
const {registerValidation, loginValidation} = require('../validations/userValidation')


router.post('/register', registerValidation, authController.registerUser);
router.post('/login', loginValidation, authController.loginUser);

// Protected Routes
router.post('/logout', authMiddleware, authController.logoutUser);
router.get('/me', authMiddleware, authController.getMe);
router.put('/change-password', authMiddleware, authController.changePassword);
router.get('/token-status', authMiddleware, authController.tokenStatus);
module.exports = router;

│   │   # --- End: authRoutes.js ---

│   │   ├─ complaintRoutes.js

│   │   # --- Begin: complaintRoutes.js ---
// routes/complaintRoutes.js

const express = require('express');
const router = express.Router();
const complaintController = require('../controllers/complaintController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// All routes require authentication
router.use(authMiddleware);

// Admin-only routes
router.get('/all', roleMiddleware('admin'), complaintController.getAllComplaints);
router.delete('/:id', roleMiddleware('admin'), complaintController.deleteComplaint);

// Admin or Owner can fetch complaints by building and resolve
router.get('/building/:buildingId', roleMiddleware(['admin', 'owner']), complaintController.getComplaintsByBuilding);
router.put('/:id/resolve', roleMiddleware(['admin', 'owner']), complaintController.resolveComplaint);

module.exports = router;

│   │   # --- End: complaintRoutes.js ---

│   │   ├─ ownerRoutes.js

│   │   # --- Begin: ownerRoutes.js ---
const express = require('express');
const router = express.Router();

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyOwnerAssigned } = require('../middleware/roleAccessGuard');
const ownerController = require('../controllers/ownerController');

// 🔐 Authenticate → Confirm Role → Confirm Assignment
router.use(authMiddleware);
router.use(roleMiddleware('owner'));
router.use(verifyOwnerAssigned);

// 📦 Flat Management
router.get('/flats', ownerController.getMyFlats);
router.get('/flats/:id/society', ownerController.getFlatSocietyInfo);

// 📨 Ownership Requests
router.post('/ownership-request', ownerController.submitOwnershipRequest);
router.post('/assign-tenant', ownerController.assignTenantToMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', ownerController.getRentHistory);
router.get('/maintenance-due', ownerController.getUnpaidMaintenance);
router.post('/pay-maintenance/:maintenanceId', ownerController.payMaintenance);

// 🛠 Complaints
router.post('/complaints', ownerController.fileComplaint);
router.get('/complaints', ownerController.getMyComplaints);

// 📊 Dashboard
router.get('/dashboard/overview', ownerController.getOwnerDashboard);

module.exports = router;

│   │   # --- End: ownerRoutes.js ---

│   │   ├─ ownershipRequestRoutes.js

│   │   # --- Begin: ownershipRequestRoutes.js ---
// routes/ownershipRequestRoutes.js

const express = require('express');
const router = express.Router();
const ownershipRequestController = require('../controllers/ownershipRequestController');

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Owner creates and views their requests
router.post('/', authMiddleware, roleMiddleware(['owner']), ownershipRequestController.createOwnershipRequest);
router.get('/my-requests', authMiddleware, roleMiddleware(['owner']), ownershipRequestController.getMyOwnershipRequests);

// Admin views and updates requests
router.get('/admin', authMiddleware, roleMiddleware(['admin']), ownershipRequestController.getAllOwnershipRequests);
router.put('/admin/:id', authMiddleware, roleMiddleware(['admin']), ownershipRequestController.updateOwnershipRequestStatus);

module.exports = router;

│   │   # --- End: ownershipRequestRoutes.js ---

│   │   ├─ tenantRoutes.js

│   │   # --- Begin: tenantRoutes.js ---
const express = require('express');
const router = express.Router();

const tenantController = require('../controllers/tenantController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyTenantAssigned } = require('../middleware/roleAccessGuard');

// 🔐 Middleware to enforce auth + tenant role + flat assignment
router.use(authMiddleware);
router.use(roleMiddleware('tenant'));
router.use(verifyTenantAssigned);

// 🏠 Flat Info
router.get('/my-flat', tenantController.getMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', tenantController.getRentHistory);
router.get('/current-rent', tenantController.getCurrentRent);
router.post('/pay-rent/:rentId', tenantController.payRent);
router.get('/maintenance-due', tenantController.getUnpaidMaintenance);
router.post('/pay-maintenance/:maintenanceId', tenantController.payMaintenance);

// 🛠 Complaints
router.post('/complaints', tenantController.fileComplaint);
router.get('/complaints', tenantController.getMyComplaints);

// 📣 Announcements
router.get('/announcements', tenantController.getAnnouncements);

// 📊 Dashboard
router.get('/dashboard/overview', tenantController.getTenantDashboard);

module.exports = router;

│   │   # --- End: tenantRoutes.js ---

│   ├─ uploads/
│   ├─ utils/
│   │   ├─ generateToken.js

│   │   # --- Begin: generateToken.js ---
const jwt = require('jsonwebtoken');

const generateToken = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  return token;
};

module.exports = generateToken;

│   │   # --- End: generateToken.js ---

│   │   ├─ invoiceGenerator.js

│   │   # --- Begin: invoiceGenerator.js ---
const PDFDocument = require('pdfkit');
const fs = require('fs');
const path = require('path');

const generateInvoice = (invoiceData, filePath) => {
  const doc = new PDFDocument();
  doc.pipe(fs.createWriteStream(filePath));

  doc.fontSize(20).text('Housing Society Invoice', { align: 'center' });

  doc.moveDown();
  doc.fontSize(12).text(`Invoice ID: ${invoiceData._id}`);
  doc.text(`Flat: ${invoiceData.flatNumber}`);
  doc.text(`Name: ${invoiceData.userName}`);
  doc.text(`Amount: ₹${invoiceData.amount}`);
  doc.text(`Due Date: ${invoiceData.dueDate}`);
  doc.text(`Generated On: ${new Date().toLocaleDateString()}`);

  doc.end();
};

module.exports = generateInvoice;

│   │   # --- End: invoiceGenerator.js ---

│   │   ├─ responseFormatter.js

│   │   # --- Begin: responseFormatter.js ---
// utils/responseFormatter.js

const formatResponse = ({ success = true, message = '', data = null, statusCode = 200 }) => {
    return {
      success,
      message,
      data,
      statusCode
    };
  };
  
  module.exports = formatResponse;
│   │   # --- End: responseFormatter.js ---

│   │   ├─ sendEmail.js

│   │   # --- Begin: sendEmail.js ---
const nodemailer = require('nodemailer');

const sendEmail = async (to, subject, text) => {
  try {
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
      console.warn('⚠️ Missing EMAIL credentials in .env');
      return;
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    await transporter.sendMail({ from: process.env.EMAIL_USER, to, subject, text });
  } catch (error) {
    console.error('❌ Failed to send email:', error.message);
  }
};

module.exports = sendEmail;

│   │   # --- End: sendEmail.js ---

