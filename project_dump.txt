├─ ./
│   ├─ .env

│   # --- Begin: .env ---
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=your_access_token_secret
JWT_REFRESH_SECRET=your_refresh_token_secret

# Server config
PORT=5000
NODE_ENV=development
CLIENT_URL=http://localhost:3000
#In production, set CLIENT_URL in .env to your deployed frontend domain

# MongoDB
MONGO_URI=mongodb://localhost:27017/SRG

# JWT
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password

# Cookies
COOKIE_EXPIRE=7

# For production, override values as needed

│   # --- End: .env ---

│   ├─ .env.example

│   # --- Begin: .env.example ---
PORT=5000
MONGO_URI=mongodb://localhost:27017/SRG
JWT_SECRET=supersecurejwtkey
JWT_EXPIRES_IN=7d
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password
CLIENT_URL=http://localhost:3000
NODE_ENV=development
COOKIE_EXPIRE=7

│   # --- End: .env.example ---

│   ├─ .gitignore

│   # --- Begin: .gitignore ---
# Node.js
node_modules/
.env
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Logs
logs
*.log
pids
*.pid
*.seed
*.pid.lock

# OS
.DS_Store
Thumbs.db

# IDEs
.vscode/
.idea/

# Build output
dist/
build/

# Optional npm cache
.npm/
.cache/

tesh.py
project_dump.txt
│   # --- End: .gitignore ---

│   ├─ package.json

│   # --- Begin: package.json ---
{
  "name": "housing-rent-management",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "bcryptjs": "^3.0.2",
    "compression": "^1.8.0",
    "cookie-parser": "^1.4.7",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^5.1.0",
    "express-mongo-sanitize": "^2.2.0",
    "express-rate-limit": "^7.5.0",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.14.0",
    "morgan": "^1.10.0",
    "nodemailer": "^7.0.3",
    "xss-clean": "^0.1.4"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}

│   # --- End: package.json ---

│   ├─ project_dump.txt

│   # --- Begin: project_dump.txt ---

│   # --- End: project_dump.txt ---

│   ├─ README.md

│   # --- Begin: README.md ---

```
Housing Society Management
├─ config
│  ├─ constant.js
│  ├─ db.js
│  └─ mailer.js
├─ controllers
│  ├─ adminController.js
│  ├─ announcementController.js
│  ├─ authController.js
│  ├─ complaintController.js
│  ├─ ownerController.js
│  ├─ ownershipRequestController.js
│  └─ tenantController.js
├─ middleware
│  ├─ authMiddleware.js
│  ├─ errorHandler.js
│  ├─ roleAccessGuard.js
│  ├─ roleMiddleware.js
│  └─ validate.js
├─ models
│  ├─ Announcement.js
│  ├─ Building.js
│  ├─ Complaint.js
│  ├─ Flat.js
│  ├─ Maintenance.js
│  ├─ OwnershipRequest.js
│  ├─ Rent.js
│  ├─ Society.js
│  └─ User.js
├─ package-lock.json
├─ package.json
├─ README.md
├─ routes
│  ├─ adminRoutes.js
│  ├─ announcementRoutes.js
│  ├─ authRoutes.js
│  ├─ complaintRoutes.js
│  ├─ ownerRoutes.js
│  ├─ ownershipRequestRoutes.js
│  └─ tenantRoutes.js
├─ server.js
├─ services
│  ├─ authService.js
│  ├─ complaintServices
│  ├─ flatService.js
│  ├─ ownershipService.js
│  └─ paymentService.js
├─ uploads
├─ utils
│  ├─ formatResponse.js
│  ├─ generateToken.js
│  ├─ logger.js
│  ├─ pagination.js
│  ├─ sendEmail.js
│  └─ validateEnv.js
└─ validators
   ├─ authValidator.js
   ├─ flatValidator.js
   └─ societyValidator.js

```
│   # --- End: README.md ---

│   ├─ server.js

│   # --- Begin: server.js ---
// ✅ PATCHED: server.js with all routes
const express = require('express');
const dotenv = require('dotenv');
const cookieParser = require('cookie-parser');
const cors = require('cors');

const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
// const mongoSanitize = require('express-mongo-sanitize');
// const xss = require('xss-clean');
const compression = require('compression');
const validateEnv = require('./utils/validateEnv');
const logger = require('./utils/logger');
const connectDB = require('./config/db');
const { errorHandler } = require('./middleware/errorHandler');

// Route Imports
const authRoutes = require('./routes/authRoutes');
const adminRoutes = require('./routes/adminRoutes');
const ownerRoutes = require('./routes/ownerRoutes');
const tenantRoutes = require('./routes/tenantRoutes');
const complaintRoutes = require('./routes/complaintRoutes');
const announcementRoutes = require('./routes/announcementRoutes');
const ownershipRequestRoutes = require('./routes/ownershipRequestRoutes');

dotenv.config();
validateEnv(); // Validate environment variables
connectDB();

const app = express();

// === Global Middleware ===
app.use(helmet());
// app.use(xss());
// app.use(mongoSanitize());
app.use(compression());
app.use(logger); // ✅ Added logger middleware
app.use(rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: 'Too many requests from this IP, try again later.'
}));

app.use(express.json());
app.use(cookieParser());

// ✅ CORS for dev/prod
app.use(cors({
  origin: process.env.CLIENT_URL || 'http://localhost:3000',
  credentials: true,
}));

// === Routes ===
app.use('/api/auth', authRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api/owner', ownerRoutes);
app.use('/api/tenant', tenantRoutes);
app.use('/api/complaints', complaintRoutes);
app.use('/api/announcements', announcementRoutes); // ✅ Added
app.use('/api/ownership-requests', ownershipRequestRoutes); // ✅ Added

// Default Route
app.get('/', (req, res) => {
  res.send('Housing Society & Rent Management System API is running');
});

// Error Handler
app.use(errorHandler);

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(`Server running in ${process.env.NODE_ENV} mode on port ${PORT}`);
});
│   # --- End: server.js ---

│   ├─ tesh.py

│   # --- Begin: tesh.py ---
import os

def dump_project_to_txt(root_dir, output_file):
    """
    Dumps the full file structure and content of all files in the project,
    excluding only specific heavy/unnecessary folders and specific files.
    """
    # Folders to completely ignore (e.g., large or non-code)
    skip_dirs = {
        "node_modules", ".git", "__pycache__", "venv",
        ".idea", ".vscode", "dist", "build", ".mypy_cache"
    }

    # Specific filenames to ignore (e.g., lockfiles or OS files)
    skip_files = {
        "package-lock.json", "yarn.lock", ".DS_Store"
    }

    with open(output_file, "w", encoding="utf-8") as f:
        for dirpath, dirnames, filenames in os.walk(root_dir):
            # Exclude unwanted directories during traversal
            dirnames[:] = [d for d in dirnames if d not in skip_dirs]

            level = dirpath.replace(root_dir, "").count(os.sep)
            indent = "│   " * level
            f.write(f"{indent}├─ {os.path.basename(dirpath)}/\n")

            sub_indent = "│   " * (level + 1)
            for filename in filenames:
                if filename in skip_files:
                    continue

                full_path = os.path.join(dirpath, filename)
                f.write(f"{sub_indent}├─ {filename}\n")

                try:
                    with open(full_path, "r", encoding="utf-8") as code_file:
                        code = code_file.read()
                        f.write(f"\n{sub_indent}# --- Begin: {filename} ---\n")
                        f.write(code + "\n")
                        f.write(f"{sub_indent}# --- End: {filename} ---\n\n")
                except Exception as e:
                    f.write(f"{sub_indent}[Could not read {filename}: {e}]\n")

# Example usage
dump_project_to_txt(".", "project_dump.txt")

│   # --- End: tesh.py ---

│   ├─ config/
│   │   ├─ constant.js

│   │   # --- Begin: constant.js ---
// config/constants.js
module.exports = {
    ROLES: ['admin', 'owner', 'tenant'],
    COMPLAINT_CATEGORIES: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    MAINTENANCE_FREQUENCIES: ['monthly', 'quarterly'],
    PAYMENT_MODES: ['cash', 'online', 'bank-transfer', 'upi'],
  };
  
│   │   # --- End: constant.js ---

│   │   ├─ db.js

│   │   # --- Begin: db.js ---
// config/db.js

const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    const conn = await mongoose.connect(process.env.MONGO_URI, {
      // These options are for Mongoose >= 6
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });

    console.log(`✅ MongoDB Connected: ${conn.connection.host}`);
  } catch (error) {
    console.error(`❌ MongoDB Connection Error: ${error.message}`);
    process.exit(1); // Stop the app if DB connection fails
  }
};

module.exports = connectDB;

│   │   # --- End: db.js ---

│   │   ├─ mailer.js

│   │   # --- Begin: mailer.js ---
// config/mailer.js
const nodemailer = require('nodemailer');

const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS,
  },
});

module.exports = transporter;

│   │   # --- End: mailer.js ---

│   ├─ controllers/
│   │   ├─ adminController.js

│   │   # --- Begin: adminController.js ---
const Society = require('../models/Society');
const Building = require('../models/Building');
const Flat = require('../models/Flat');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const OwnershipRequest = require('../models/OwnershipRequest');
const Announcement = require('../models/Announcement');
const Complaint = require('../models/Complaint');
const Rent = require('../models/Rent');
const sendEmail = require('../utils/sendEmail');
const formatResponse = require('../utils/formatResponse');
const Society = require('../models/Society');
// === SOCIETIES ===
const Society = require('../models/Society');

exports.createSociety = async (req, res, next) => {
  try {
    const { name, registrationNumber, address, maintenancePolicy } = req.body;

    const existing = await Society.findOne({ registrationNumber });
    if (existing) {
      return res.status(400).json(formatResponse({
        success: false,
        message: 'Society with this registration number already exists',
        statusCode: 400
      }));
    }

    const society = await Society.create({
      name,
      registrationNumber,
      address,
      maintenancePolicy,
      admin: req.user._id
    });

    res.status(201).json(formatResponse({
      message: 'Society created successfully',
      data: society
    }));
  } catch (err) {
    next(err);
  }
};

exports.getMySocieties = async (req, res, next) => {
  try {
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    const [societies, total] = await Promise.all([
      Society.find({ admin: req.user._id }).skip(skip).limit(limit),
      Society.countDocuments({ admin: req.user._id })
    ]);

    res.json(formatResponse({
      message: 'Societies retrieved',
      data: societies,
      pagination: {
        total,
        page,
        limit,
        pages: Math.ceil(total / limit)
      }
    }));
  } catch (err) {
    next(err);
  }
};

// === BUILDINGS ===

exports.createBuilding = async (req, res, next) => {
  try {
    const { societyId, name, totalFloors, totalFlats, addressLabel } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    const building = await Building.create({ name, totalFloors, totalFlats, addressLabel, society: societyId });
    society.totalBuildings += 1;
    await society.save();

    res.status(201).json(formatResponse({ message: 'Building created', data: building }));
  } catch (err) {
    next(err);
  }
};

exports.deleteBuilding = async (req, res, next) => {
  try {
    const building = await Building.findByIdAndDelete(req.params.id);
    if (!building) return res.status(404).json(formatResponse({ success: false, message: 'Building not found', statusCode: 404 }));

    res.json(formatResponse({ message: 'Building deleted' }));
  } catch (err) {
    next(err);
  }
};

// === FLAT OWNERSHIP ===

exports.assignFlatOwner = async (req, res, next) => {
  try {
    const { ownerId } = req.body;
    const flat = await Flat.findById(req.params.flatId).populate('society');
    const owner = await User.findById(ownerId);

    if (!flat || !owner || owner.role !== 'owner') {
      return res.status(400).json(formatResponse({ success: false, message: 'Invalid flat or owner', statusCode: 400 }));
    }

    flat.owner = owner._id;
    await flat.save();

    if (!owner.society) {
      owner.society = flat.society._id;
      await owner.save();
    }

    res.json(formatResponse({ message: 'Owner assigned successfully', data: flat }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatOwner = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json(formatResponse({ success: false, message: 'Flat not found', statusCode: 404 }));

    flat.owner = null;
    await flat.save();
    res.json(formatResponse({ message: 'Owner removed successfully' }));
  } catch (err) {
    next(err);
  }
};

exports.removeFlatTenant = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId);
    if (!flat) return res.status(404).json(formatResponse({ success: false, message: 'Flat not found', statusCode: 404 }));

    flat.tenant = null;
    flat.isRented = false;
    flat.occupancyStatus = 'vacant';
    await flat.save();
    res.json(formatResponse({ message: 'Tenant removed successfully' }));
  } catch (err) {
    next(err);
  }
};

// === MAINTENANCE ===

exports.generateMaintenance = async (req, res, next) => {
  try {
    const { societyId, billingMonth } = req.body;
    const society = await Society.findById(societyId);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    const flats = await Flat.find({ society: societyId });
    const amount = society.maintenancePolicy.amountPerFlat;

    const records = await Maintenance.insertMany(flats.map(flat => ({
      flat: flat._id,
      building: flat.building,
      society: flat.society,
      billingMonth,
      amount,
      generatedBy: req.user._id,
    })));

    res.status(201).json(formatResponse({ message: 'Maintenance generated', data: records }));
  } catch (err) {
    next(err);
  }
};

exports.getMaintenanceStatus = async (req, res, next) => {
  try {
    const { filterBy, id } = req.query;
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    let query = {};

    if (filterBy === 'society') query.society = id;
    else if (filterBy === 'flat') query.flat = id;
    else if (filterBy === 'user') {
      const flats = await Flat.find({ $or: [{ owner: id }, { tenant: id }] }, '_id');
      query.flat = { $in: flats.map(f => f._id) };
    }

    const [records, total] = await Promise.all([
      Maintenance.find(query).populate('flat building').skip(skip).limit(limit),
      Maintenance.countDocuments(query)
    ]);

    res.json(formatResponse({
      message: 'Maintenance records retrieved',
      data: records,
      pagination: { total, page, limit, pages: Math.ceil(total / limit) }
    }));
  } catch (err) {
    next(err);
  }
};


// === RENT ===

exports.getRentHistory = async (req, res, next) => {
  try {
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    const [rents, total] = await Promise.all([
      Rent.find().populate('flat tenant').skip(skip).limit(limit),
      Rent.countDocuments()
    ]);

    res.json(formatResponse({
      message: 'Rent history retrieved',
      data: rents,
      pagination: { total, page, limit, pages: Math.ceil(total / limit) }
    }));
  } catch (err) {
    next(err);
  }
};

// === OWNERSHIP REQUESTS ===

exports.getOwnershipRequests = async (req, res, next) => {
  try {
    const requests = await OwnershipRequest.find({ status: 'pending' }).populate('flat currentOwner');
    res.json(formatResponse({ message: 'Ownership requests fetched', data: requests }));
  } catch (err) {
    next(err);
  }
};

const { reviewOwnershipRequest } = require('../services/ownershipService');

exports.reviewOwnershipRequest = async (req, res, next) => {
  try {
    const { requestId, status, note } = req.body;
    const result = await reviewOwnershipRequest({
      requestId,
      status,
      note,
      reviewerId: req.user._id
    });

    res.json(formatResponse({
      message: 'Request reviewed',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};


// === ANNOUNCEMENTS ===

exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, society, building, audience, validTill } = req.body;

    const announcement = await Announcement.create({
      title,
      message,
      createdBy: req.user._id,
      society,
      building: building || null,
      audience,
      validTill: validTill || null,
    });

    res.status(201).json(formatResponse({ message: 'Announcement created', data: announcement }));
  } catch (err) {
    next(err);
  }
};

// === COMPLAINTS ===

const { getAllComplaints } = require('../services/complaintService');

exports.getComplaints = async (req, res, next) => {
  try {
    const complaints = await getAllComplaints();
    res.json(formatResponse({
      message: 'All complaints retrieved',
      data: complaints
    }));
  } catch (err) {
    next(err);
  }
};


const { updateComplaintStatus } = require('../services/complaintService');

exports.updateComplaintStatus = async (req, res, next) => {
  try {
    const { complaintId, status, adminNote } = req.body;
    const complaint = await updateComplaintStatus({
      complaintId,
      status,
      adminNote,
      resolvedBy: req.user._id
    });

    res.json(formatResponse({
      message: 'Complaint updated',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};


// === DASHBOARD ===

exports.getAdminDashboard = async (req, res, next) => {
  try {
    const totalFlats = await Flat.countDocuments();
    const totalTenants = await User.countDocuments({ role: 'tenant' });
    const totalOwners = await User.countDocuments({ role: 'owner' });
    const totalPendingComplaints = await Complaint.countDocuments({ status: 'pending' });

    res.json(formatResponse({
      message: 'Admin dashboard data',
      data: { totalFlats, totalTenants, totalOwners, totalPendingComplaints }
    }));
  } catch (err) {
    next(err);
  }
};



// === NOTES & REMINDERS ===

exports.addSocietyNote = async (req, res, next) => {
  try {
    const { note } = req.body;
    const society = await Society.findById(req.params.id);
    if (!society) return res.status(404).json(formatResponse({ success: false, message: 'Society not found', statusCode: 404 }));

    society.adminNote = note;
    await society.save();
    res.json(formatResponse({ message: 'Note added to society' }));
  } catch (err) {
    next(err);
  }
};

exports.sendReminderToUser = async (req, res, next) => {
  try {
    const { userId, subject, message } = req.body;
    const user = await User.findById(userId);
    if (!user) return res.status(404).json(formatResponse({ success: false, message: 'User not found', statusCode: 404 }));

    await sendEmail(user.email, subject, message);
    res.json(formatResponse({ message: 'Reminder sent' }));
  } catch (err) {
    next(err);
  }
};
// Get full flat info (owner, tenant, society, building)
exports.getFlatInfo = async (req, res, next) => {
  try {
    const flat = await Flat.findById(req.params.flatId)
      .populate('owner', 'name email phone')
      .populate('tenant', 'name email phone')
      .populate('building')
      .populate('society');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found',
        statusCode: 404
      }));
    }

    res.json(formatResponse({
      message: 'Flat details retrieved',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};


│   │   # --- End: adminController.js ---

│   │   ├─ announcementController.js

│   │   # --- Begin: announcementController.js ---
const Announcement = require('../models/Announcement');
const Flat = require('../models/Flat');
const formatResponse = require('../utils/formatResponse');

// Create a new announcement
exports.createAnnouncement = async (req, res, next) => {
  try {
    const { title, message, audience, society, building, validTill } = req.body;

    const announcement = await Announcement.create({
      title,
      message,
      audience,
      society,
      building: building || null,
      validTill: validTill || null,
      createdBy: req.user._id,
    });

    res.status(201).json(formatResponse({
      message: 'Announcement created',
      data: announcement
    }));
  } catch (err) {
    next(err);
  }
};

// Get announcements for logged-in user based on role and society/building
exports.getMyAnnouncements = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({
      $or: [
        { tenant: req.user._id },
        { owner: req.user._id }
      ]
    });

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const announcements = await Announcement.find({
      society: flat.society,
      $or: [
        { audience: 'all' },
        { audience: req.user.role },
        { building: null },
        { building: flat.building }
      ],
      $or: [
        { validTill: null },
        { validTill: { $gte: new Date() } }
      ]
    }).sort({ createdAt: -1 });

    res.status(200).json(formatResponse({
      message: 'Relevant announcements retrieved',
      data: announcements
    }));
  } catch (err) {
    next(err);
  }
};

// Get all announcements (admin use)
exports.getAllAnnouncements = async (req, res, next) => {
  try {
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    const [announcements, total] = await Promise.all([
      Announcement.find().populate('createdBy society building').skip(skip).limit(limit),
      Announcement.countDocuments()
    ]);

    res.status(200).json(formatResponse({
      message: 'All announcements retrieved',
      data: announcements,
      pagination: { total, page, limit, pages: Math.ceil(total / limit) }
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: announcementController.js ---

│   │   ├─ authController.js

│   │   # --- Begin: authController.js ---
// controllers/authController.js
const {
  loginUser,
  registerUser,
  generateTokenCookie,
  changePassword,
  validateToken
} = require('../services/authService');
const formatResponse = require('../utils/responseFormatter');
const { asyncHandler } = require('../middleware/errorHandler');
const User = require('../models/User');

// REGISTER
exports.registerUser = asyncHandler(async (req, res) => {
  const { name, email, password, phone, role } = req.body;
  const user = await registerUser({ name, email, password, phone, role });

  generateTokenCookie(res, user._id);

  res.status(201).json(formatResponse({
    message: 'User registered successfully',
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role
    }
  }));
});

// LOGIN
exports.loginUser = asyncHandler(async (req, res) => {
  const { email, password } = req.body;
  const user = await loginUser({ email, password });

  generateTokenCookie(res, user._id);

  res.status(200).json(formatResponse({
    message: 'Login successful',
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role
    }
  }));
});

// LOGOUT
exports.logoutUser = asyncHandler(async (req, res) => {
  res.cookie('token', '', {
    httpOnly: true,
    expires: new Date(0)
  });

  res.status(200).json(formatResponse({
    message: 'Logged out successfully'
  }));
});

// GET CURRENT USER
exports.getMe = asyncHandler(async (req, res) => {
  const user = await User.findById(req.user._id).select('-password');
  if (!user) {
    return res.status(404).json(formatResponse({
      success: false,
      message: 'User not found',
      statusCode: 404
    }));
  }

  res.status(200).json(formatResponse({
    data: {
      _id: user._id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      role: user.role,
      society: user.society || null
    }
  }));
});

// CHANGE PASSWORD
exports.changePassword = asyncHandler(async (req, res) => {
  const { currentPassword, newPassword } = req.body;
  await changePassword({
    userId: req.user._id,
    currentPassword,
    newPassword
  });

  res.status(200).json(formatResponse({
    message: 'Password updated successfully'
  }));
});

// TOKEN STATUS
exports.tokenStatus = asyncHandler(async (req, res) => {
  const token = req.cookies.token || (
    req.headers.authorization?.startsWith('Bearer') &&
    req.headers.authorization.split(' ')[1]
  );

  if (!token) {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Token missing',
      statusCode: 401
    }));
  }

  try {
    const decoded = validateToken(token);
    return res.status(200).json(formatResponse({
      message: 'Token is valid',
      data: { userId: decoded.id }
    }));
  } catch {
    return res.status(401).json(formatResponse({
      success: false,
      message: 'Invalid token',
      statusCode: 401
    }));
  }
});

│   │   # --- End: authController.js ---

│   │   ├─ complaintController.js

│   │   # --- Begin: complaintController.js ---
// controllers/complaintController.js

const {
  createComplaint,
  getComplaintsByUser,
  getAllComplaints,
  updateComplaintStatus
} = require('../services/complaintService');
const formatResponse = require('../utils/responseFormatter');
const { asyncHandler } = require('../middleware/errorHandler');

// For tenant or owner complaint creation
exports.createComplaint = asyncHandler(async (req, res) => {
  const { flatId, category, subject, description } = req.body;
  const complaint = await createComplaint({
    raisedBy: req.user._id,
    userRole: req.user.role,
    flatId,
    category,
    subject,
    description
  });

  res.status(201).json(formatResponse({
    message: 'Complaint created successfully',
    data: complaint
  }));
});

// For fetching user’s own complaints
exports.getMyComplaints = asyncHandler(async (req, res) => {
  const complaints = await getComplaintsByUser(req.user._id, req.user.role);
  res.json(formatResponse({
    message: 'Your complaints',
    data: complaints
  }));
});

// controllers/complaintController.js
const { getAllComplaints } = require('../services/complaintService');
const formatResponse = require('../utils/responseFormatter');

exports.getAllComplaints = async (req, res, next) => {
  try {
    const { page, limit, status, category } = req.query;

    const { complaints, total } = await getAllComplaints({ page, limit, status, category });

    res.json(formatResponse({
      message: 'Complaints retrieved',
      data: complaints,
      pagination: {
        total,
        page: parseInt(page) || 1,
        limit: parseInt(limit) || 10,
        pages: Math.ceil(total / (limit || 10))
      }
    }));
  } catch (err) {
    next(err);
  }
};



// Admin: update complaint status
exports.updateComplaintStatus = asyncHandler(async (req, res) => {
  const { complaintId, status, adminNote } = req.body;

  const complaint = await updateComplaintStatus({
    complaintId,
    status,
    adminNote,
    resolvedBy: req.user._id
  });

  res.json(formatResponse({
    message: 'Complaint updated',
    data: complaint
  }));
});

│   │   # --- End: complaintController.js ---

│   │   ├─ ownerController.js

│   │   # --- Begin: ownerController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const OwnershipRequest = require('../models/OwnershipRequest');
const Rent = require('../models/Rent');
const User = require('../models/User');
const Maintenance = require('../models/Maintenance');
const formatResponse = require('../utils/formatResponse');

// 1. Get all flats owned by logged-in owner
exports.getMyFlats = async (req, res, next) => {
  try {
    const flats = await Flat.find({ owner: req.user._id })
      .populate('building')
      .populate('tenant');

    res.status(200).json(formatResponse({
      message: 'Flats retrieved',
      data: flats
    }));
  } catch (err) {
    next(err);
  }
};

// 2. View society/building info of a specific flat
exports.getFlatSocietyInfo = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ _id: req.params.id, owner: req.user._id })
      .populate('building')
      .populate('society');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found or unauthorized',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Flat info retrieved',
      data: {
        building: flat.building,
        society: flat.society
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Submit ownership transfer request
exports.submitOwnershipRequest = async (req, res, next) => {
  try {
    const { flatId, newOwnerName, newOwnerEmail, newOwnerPhone, reason } = req.body;

    const flat = await Flat.findById(flatId);
    if (!flat || flat.owner.toString() !== req.user._id.toString()) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized for this flat',
        statusCode: 403
      }));
    }

    const request = await OwnershipRequest.create({
      flat: flatId,
      currentOwner: req.user._id,
      newOwnerName,
      newOwnerEmail,
      newOwnerPhone,
      reason,
    });

    res.status(201).json(formatResponse({
      message: 'Ownership request submitted',
      data: request
    }));
  } catch (err) {
    next(err);
  }
};

// 4. Rent payment history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ owner: req.user._id })
      .populate('flat')
      .populate('tenant');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 5. File complaint
const { createComplaint } = require('../services/complaintService');

exports.fileComplaint = async (req, res, next) => {
  try {
    const { flatId, category, subject, description } = req.body;
    const complaint = await createComplaint({
      raisedBy: req.user._id,
      userRole: 'owner',
      flatId,
      category,
      subject,
      description
    });

    res.status(201).json(formatResponse({
      message: 'Complaint submitted',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};


// 6. View own complaints
exports.getMyComplaints = async (req, res, next) => {
  try {
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    const [complaints, total] = await Promise.all([
      Complaint.find({ raisedBy: req.user._id, userRole: 'owner' })
        .populate('flat building').skip(skip).limit(limit),
      Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'owner' })
    ]);

    res.status(200).json(formatResponse({
      message: 'Complaints retrieved',
      data: complaints,
      pagination: { total, page, limit, pages: Math.ceil(total / limit) }
    }));
  } catch (err) {
    next(err);
  }
};

// 7. Dashboard summary
exports.getOwnerDashboard = async (req, res, next) => {
  try {
    const flats = await Flat.find({ owner: req.user._id });
    const flatIds = flats.map(f => f._id);

    const rentCount = await Rent.countDocuments({ flat: { $in: flatIds } });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'owner' });

    res.status(200).json(formatResponse({
      message: 'Dashboard data retrieved',
      data: {
        totalFlatsOwned: flats.length,
        rentPaymentsMade: rentCount,
        complaintsFiled: complaintCount
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 8. View unpaid maintenance bills for owner flats
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flats = await Flat.find({
      owner: req.user._id,
      $or: [{ tenant: null }, { tenant: { $exists: false } }]
    });

    const flatIds = flats.map(f => f._id);

    const maintenance = await Maintenance.find({
      flat: { $in: flatIds },
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 9. Pay maintenance for owner flats
const { payMaintenance } = require('../services/paymentService');

exports.payMaintenance = async (req, res, next) => {
  try {
    const result = await payMaintenance({
      maintenanceId: req.params.maintenanceId,
      userId: req.user._id,
      role: 'owner'
    });

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// 10. Assign tenant to flat
const { assignTenant } = require('../services/flatService');

exports.assignTenantToMyFlat = async (req, res, next) => {
  try {
    const { flatId, tenantId } = req.body;
    const flat = await assignTenant({ flatId, tenantId, ownerId: req.user._id });

    res.status(200).json(formatResponse({
      message: 'Tenant assigned successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

exports.removeTenantFromMyFlat = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({
      _id: req.params.flatId,
      owner: req.user._id
    });

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found or unauthorized',
        statusCode: 404
      }));
    }

    flat.tenant = null;
    flat.isRented = false;
    flat.occupancyStatus = 'vacant';
    await flat.save();

    res.json(formatResponse({ message: 'Tenant removed successfully', data: flat }));
  } catch (err) {
    next(err);
  }
};
exports.updateTenantForMyFlat = async (req, res, next) => {
  try {
    const { newTenantId } = req.body;
    const flat = await Flat.findOne({
      _id: req.params.flatId,
      owner: req.user._id
    });

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not found or unauthorized',
        statusCode: 404
      }));
    }

    flat.tenant = newTenantId;
    flat.isRented = true;
    flat.occupancyStatus = 'occupied-tenant';
    await flat.save();

    res.status(200).json(formatResponse({
      message: 'Tenant updated successfully',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

│   │   # --- End: ownerController.js ---

│   │   ├─ ownershipRequestController.js

│   │   # --- Begin: ownershipRequestController.js ---
// controllers/ownershipRequestController.js

const { reviewOwnershipRequest } = require('../services/ownershipService');
const OwnershipRequest = require('../models/OwnershipRequest');
const formatResponse = require('../utils/responseFormatter');
const { asyncHandler } = require('../middleware/errorHandler');

// Admin: list all ownership requests
exports.getOwnershipRequests = async (req, res, next) => {
  const { page = 1, limit = 10, status } = req.query;

  const query = {};
  if (status) query.status = status;

  const skip = (page - 1) * limit;

  const requests = await OwnershipRequest.find(query)
    .populate('currentOwner flat')
    .skip(skip)
    .limit(parseInt(limit));

  const total = await OwnershipRequest.countDocuments(query);

  res.json(formatResponse({
    message: 'Ownership requests retrieved',
    data: requests,
    pagination: {
      total,
      page: parseInt(page),
      limit: parseInt(limit),
      pages: Math.ceil(total / limit)
    }
  }));
};


// Admin: review/approve/reject ownership request
exports.reviewOwnershipRequest = asyncHandler(async (req, res) => {
  const { requestId, status, note } = req.body;

  const updatedRequest = await reviewOwnershipRequest({
    requestId,
    status,
    note,
    reviewerId: req.user._id
  });

  res.json(formatResponse({
    message: `Ownership request ${status}`,
    data: updatedRequest
  }));
});

│   │   # --- End: ownershipRequestController.js ---

│   │   ├─ tenantController.js

│   │   # --- Begin: tenantController.js ---
const Flat = require('../models/Flat');
const Complaint = require('../models/Complaint');
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');
const Announcement = require('../models/Announcement');
const formatResponse = require('../utils/formatResponse');

// 1. Get assigned flat
exports.getMyFlat = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id })
      .populate('building')
      .populate('owner');

    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not assigned',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Assigned flat retrieved',
      data: flat
    }));
  } catch (err) {
    next(err);
  }
};

// 2. Rent history
exports.getRentHistory = async (req, res, next) => {
  try {
    const rents = await Rent.find({ tenant: req.user._id })
      .populate('flat');

    res.status(200).json(formatResponse({
      message: 'Rent history retrieved',
      data: rents
    }));
  } catch (err) {
    next(err);
  }
};

// 3. Pay rent
const { payRent } = require('../services/paymentService');

exports.payRent = async (req, res, next) => {
  try {
    const result = await payRent({
      rentId: req.params.rentId,
      userId: req.user._id
    });

    res.status(200).json(formatResponse({
      message: 'Rent paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};


// 4. File complaint
const { createComplaint } = require('../services/complaintService');

exports.fileComplaint = async (req, res, next) => {
  try {
    const { flatId, category, subject, description } = req.body;
    const complaint = await createComplaint({
      raisedBy: req.user._id,
      userRole: 'tenant',
      flatId,
      category,
      subject,
      description
    });

    res.status(201).json(formatResponse({
      message: 'Complaint filed',
      data: complaint
    }));
  } catch (err) {
    next(err);
  }
};

// 5. View own complaints
exports.getMyComplaints = async (req, res, next) => {
  try {
    const { page, limit, skip } = require('../utils/pagination').paginateQuery(req);
    const [complaints, total] = await Promise.all([
      Complaint.find({ raisedBy: req.user._id, userRole: 'tenant' })
        .populate('flat building').skip(skip).limit(limit),
      Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'tenant' })
    ]);

    res.status(200).json(formatResponse({
      message: 'Complaints retrieved',
      data: complaints,
      pagination: { total, page, limit, pages: Math.ceil(total / limit) }
    }));
  } catch (err) {
    next(err);
  }
};


// 6. View announcements
exports.getRelevantAnnouncements = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No assigned flat found',
        statusCode: 404
      }));
    }

    const announcements = await Announcement.find({
      society: flat.society,
      $or: [
        { audience: 'all' },
        { audience: 'tenants' },
        { building: null },
        { building: flat.building }
      ],
      $or: [
        { validTill: null },
        { validTill: { $gte: new Date() } }
      ]
    }).sort({ createdAt: -1 });

    res.status(200).json(formatResponse({
      message: 'Announcements retrieved',
      data: announcements
    }));
  } catch (err) {
    next(err);
  }
};

// 7. View unpaid maintenance
exports.getUnpaidMaintenance = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(403).json(formatResponse({
        success: false,
        message: 'Unauthorized',
        statusCode: 403
      }));
    }

    const maintenance = await Maintenance.find({
      flat: flat._id,
      isPaid: false
    }).sort({ billingMonth: -1 });

    res.status(200).json(formatResponse({
      message: 'Unpaid maintenance retrieved',
      data: maintenance
    }));
  } catch (err) {
    next(err);
  }
};

// 8. Pay maintenance
const { payMaintenance } = require('../services/paymentService');

exports.payMaintenance = async (req, res, next) => {
  try {
    const result = await payMaintenance({
      maintenanceId: req.params.maintenanceId,
      userId: req.user._id,
      role: 'tenant'
    });

    res.status(200).json(formatResponse({
      message: 'Maintenance paid successfully',
      data: result
    }));
  } catch (err) {
    next(err);
  }
};

// 9. Dashboard overview
exports.getTenantDashboard = async (req, res, next) => {
  try {
    const rentCount = await Rent.countDocuments({ tenant: req.user._id });
    const complaintCount = await Complaint.countDocuments({ raisedBy: req.user._id, userRole: 'tenant' });
    const unpaidMaintenance = await Maintenance.countDocuments({ isPaid: false, flat: (await Flat.findOne({ tenant: req.user._id }))._id });

    res.status(200).json(formatResponse({
      message: 'Dashboard retrieved',
      data: {
        rentPayments: rentCount,
        complaintsFiled: complaintCount,
        unpaidMaintenanceCount: unpaidMaintenance
      }
    }));
  } catch (err) {
    next(err);
  }
};

// 2.5. Get current month's rent (if exists)
exports.getCurrentRent = async (req, res, next) => {
  try {
    const flat = await Flat.findOne({ tenant: req.user._id });
    if (!flat) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'Flat not assigned',
        statusCode: 404
      }));
    }

    const currentMonth = new Date().toISOString().slice(0, 7); // YYYY-MM

    const rent = await Rent.findOne({
      flat: flat._id,
      tenant: req.user._id,
      billingMonth: currentMonth,
    });

    if (!rent) {
      return res.status(404).json(formatResponse({
        success: false,
        message: 'No rent record found for this month',
        statusCode: 404
      }));
    }

    res.status(200).json(formatResponse({
      message: 'Current month rent retrieved',
      data: rent
    }));
  } catch (err) {
    next(err);
  }
};
exports.updateMyProfile = async (req, res, next) => {
  try {
    const { name, phone, profilePic } = req.body;

    const user = await User.findById(req.user._id);
    if (!user) return res.status(404).json(formatResponse({ success: false, message: 'User not found' }));

    if (name) user.name = name;
    if (phone) user.phone = phone;
    if (profilePic) user.profilePic = profilePic;

    await user.save();

    res.status(200).json(formatResponse({
      message: 'Profile updated successfully',
      data: {
        _id: user._id,
        name: user.name,
        email: user.email,
        phone: user.phone,
        profilePic: user.profilePic
      }
    }));
  } catch (err) {
    next(err);
  }
};


│   │   # --- End: tenantController.js ---

│   ├─ logs/
│   │   ├─ combined.log

│   │   # --- Begin: combined.log ---

│   │   # --- End: combined.log ---

│   ├─ middleware/
│   │   ├─ authMiddleware.js

│   │   # --- Begin: authMiddleware.js ---
// middleware/authMiddleware.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');

const authMiddleware = async (req, res, next) => {
  let token = req.cookies.token;

  if (!token && req.headers.authorization?.startsWith('Bearer')) {
    token = req.headers.authorization.split(' ')[1];
  }

  if (!token) {
    return res.status(401).json({ success: false, message: 'Unauthorized: Token missing' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.id).select('-password');
    if (!user) return res.status(401).json({ success: false, message: 'User not found' });

    req.user = user;
    next();
  } catch (error) {
    return res.status(401).json({ success: false, message: 'Invalid or expired token' });
  }
};

module.exports = authMiddleware;

│   │   # --- End: authMiddleware.js ---

│   │   ├─ errorHandler.js

│   │   # --- Begin: errorHandler.js ---
// middleware/errorHandler.js

const errorHandler = (err, req, res, next) => {
  const statusCode = res.statusCode === 200 ? 500 : res.statusCode;
  res.status(statusCode);
  res.json({
    message: err.message,
    stack: process.env.NODE_ENV === 'production' ? null : err.stack,
  });
};

const asyncHandler = (fn) => (req, res, next) =>
  Promise.resolve(fn(req, res, next)).catch(next);

module.exports = { errorHandler, asyncHandler };

│   │   # --- End: errorHandler.js ---

│   │   ├─ roleAccessGuard.js

│   │   # --- Begin: roleAccessGuard.js ---
const formatResponse = require('../utils/responseFormatter');
const Flat = require('../models/Flat');

const verifyOwnerAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ owner: req.user._id });
  if (!flat) {
    return res.status(403).json(formatResponse({
      success: false,
      message: 'Owner not assigned to any flat',
      statusCode: 403
    }));
  }
  next();
};

const verifyTenantAssigned = async (req, res, next) => {
  const flat = await Flat.findOne({ tenant: req.user._id });
  if (!flat) {
    return res.status(403).json(formatResponse({
      success: false,
      message: 'Tenant not assigned to any flat',
      statusCode: 403
    }));
  }
  next();
};

module.exports = { verifyOwnerAssigned, verifyTenantAssigned };

│   │   # --- End: roleAccessGuard.js ---

│   │   ├─ roleMiddleware.js

│   │   # --- Begin: roleMiddleware.js ---
// middleware/roleMiddleware.js

const roleMiddleware = (roles) => {
  const allowedRoles = Array.isArray(roles) ? roles : [roles];
  return (req, res, next) => {
    if (!req.user || !allowedRoles.includes(req.user.role)) {
      return res.status(403).json({ success: false, message: 'Access denied: Insufficient permissions' });
    }
    next();
  };
};

module.exports = roleMiddleware;

│   │   # --- End: roleMiddleware.js ---

│   │   ├─ validate.js

│   │   # --- Begin: validate.js ---
const { validationResult } = require('express-validator');

module.exports = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      message: 'Validation failed',
      errors: errors.array()
    });
  }
  next();
};
│   │   # --- End: validate.js ---

│   ├─ models/
│   │   ├─ Announcement.js

│   │   # --- Begin: Announcement.js ---
// models/Announcement.js

const mongoose = require('mongoose');

const announcementSchema = new mongoose.Schema({
  title: {
    type: String,
    required: [true, 'Announcement title is required'],
    trim: true,
  },
  message: {
    type: String,
    required: [true, 'Announcement message is required'],
    trim: true,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    required: [true, 'Admin reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Target society is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    default: null, // If null, applies to whole society
  },
  audience: {
    type: String,
    enum: ['all', 'owners', 'tenants'],
    default: 'all',
  },
  validTill: {
    type: Date,
    default: null, // Optional expiry
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Announcement', announcementSchema);

│   │   # --- End: Announcement.js ---

│   │   ├─ Building.js

│   │   # --- Begin: Building.js ---
// models/Building.js

const mongoose = require('mongoose');

const buildingSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Building name is required'],
    trim: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  totalFloors: {
    type: Number,
    required: [true, 'Total number of floors is required'],
    min: [1, 'There must be at least 1 floor'],
  },
  totalFlats: {
    type: Number,
    required: [true, 'Total number of flats is required'],
    min: [1, 'There must be at least 1 flat'],
  },
  addressLabel: {
    type: String,
    trim: true,
    default: '',
    // Optional label if address differs from society (e.g., "Wing B, Gate 2")
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Building', buildingSchema);

│   │   # --- End: Building.js ---

│   │   ├─ Complaint.js

│   │   # --- Begin: Complaint.js ---
// models/Complaint.js

const mongoose = require('mongoose');

const complaintSchema = new mongoose.Schema({
  raisedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'User who raised the complaint is required'],
  },
  userRole: {
    type: String,
    enum: ['owner', 'tenant'],
    required: true,
  },
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: true,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  category: {
    type: String,
    enum: ['plumbing', 'electrical', 'security', 'cleanliness', 'other'],
    default: 'other',
  },
  subject: {
    type: String,
    required: [true, 'Complaint subject is required'],
    trim: true,
  },
  description: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['open', 'in-progress', 'resolved', 'rejected'],
    default: 'open',
  },
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  resolvedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});
complaintSchema.index({ raisedBy: 1 });
complaintSchema.index({ flat: 1 });
complaintSchema.index({ society: 1 });


module.exports = mongoose.model('Complaint', complaintSchema);

│   │   # --- End: Complaint.js ---

│   │   ├─ Flat.js

│   │   # --- Begin: Flat.js ---
// models/Flat.js

const mongoose = require('mongoose');

const flatSchema = new mongoose.Schema({
  flatNumber: {
    type: String,
    required: [true, 'Flat number is required'],
    trim: true,
  },
  floor: {
    type: Number,
    required: [true, 'Floor number is required'],
    min: 0,
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: [true, 'Building reference is required'],
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: [true, 'Society reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner user reference is required'],
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    default: null,
  },
  isRented: {
    type: Boolean,
    default: false,
  },
  occupancyStatus: {
    type: String,
    enum: ['vacant', 'occupied-owner', 'occupied-tenant'],
    default: 'vacant',
  },
}, {
  timestamps: true,
});
flatSchema.index({ tenant: 1 });
flatSchema.index({ society: 1 });
flatSchema.index({ building: 1 });

module.exports = mongoose.model('Flat', flatSchema);

│   │   # --- End: Flat.js ---

│   │   ├─ Maintenance.js

│   │   # --- Begin: Maintenance.js ---
// models/Maintenance.js

const mongoose = require('mongoose');

const maintenanceSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  amount: {
    type: Number,
    required: [true, 'Maintenance amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  generatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Typically an Admin
    required: true,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Maintenance', maintenanceSchema);

│   │   # --- End: Maintenance.js ---

│   │   ├─ OwnershipRequest.js

│   │   # --- Begin: OwnershipRequest.js ---
// models/OwnershipRequest.js

const mongoose = require('mongoose');

const ownershipRequestSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  currentOwner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Current owner reference is required'],
  },
  newOwnerName: {
    type: String,
    required: [true, 'New owner name is required'],
    trim: true,
  },
  newOwnerEmail: {
    type: String,
    required: [true, 'New owner email is required'],
    trim: true,
    lowercase: true,
  },
  newOwnerPhone: {
    type: String,
    required: [true, 'New owner phone number is required'],
    trim: true,
  },
  reason: {
    type: String,
    trim: true,
    default: '',
  },
  status: {
    type: String,
    enum: ['pending', 'approved', 'rejected'],
    default: 'pending',
  },
  reviewedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User', // Admin
    default: null,
  },
  reviewedOn: {
    type: Date,
    default: null,
  },
  adminNote: {
    type: String,
    trim: true,
    default: '',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('OwnershipRequest', ownershipRequestSchema);

│   │   # --- End: OwnershipRequest.js ---

│   │   ├─ Rent.js

│   │   # --- Begin: Rent.js ---
// models/Rent.js

const mongoose = require('mongoose');

const rentSchema = new mongoose.Schema({
  flat: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Flat',
    required: [true, 'Flat reference is required'],
  },
  building: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Building',
    required: true,
  },
  society: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Society',
    required: true,
  },
  tenant: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Tenant reference is required'],
  },
  owner: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Owner reference is required'],
  },
  billingMonth: {
    type: String,
    required: [true, 'Billing month is required'],
    match: [/^\d{4}-(0[1-9]|1[0-2])$/, 'Format must be YYYY-MM'],
    // Example: "2025-06"
  },
  rentAmount: {
    type: Number,
    required: [true, 'Rent amount is required'],
    min: 0,
  },
  isPaid: {
    type: Boolean,
    default: false,
  },
  paidOn: {
    type: Date,
    default: null,
  },
  paymentMode: {
    type: String,
    enum: ['cash', 'online', 'bank-transfer', 'upi'],
    default: 'online',
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Rent', rentSchema);

│   │   # --- End: Rent.js ---

│   │   ├─ Society.js

│   │   # --- Begin: Society.js ---
// models/Society.js

const mongoose = require('mongoose');

const societySchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Society name is required'],
    trim: true,
  },
  address: {
    street: { type: String, required: true, trim: true },
    city: { type: String, required: true, trim: true },
    state: { type: String, required: true, trim: true },
    pincode: { type: String, required: true, trim: true },
  },
  registrationNumber: {
    type: String,
    required: [true, 'Registration number is required'],
    unique: true,
    trim: true,
  },
  totalBuildings: {
    type: Number,
    default: 0,
    min: 0,
  },
  maintenancePolicy: {
    frequency: {
      type: String,
      enum: ['monthly', 'quarterly'],
      default: 'monthly',
    },
    amountPerFlat: {
      type: Number,
      required: true,
      min: 0,
    },
  },
  admin: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: [true, 'Admin user is required'],
  },
  createdAt: {
    type: Date,
    default: Date.now,
  },
}, {
  timestamps: true,
});

module.exports = mongoose.model('Society', societySchema);

│   │   # --- End: Society.js ---

│   │   ├─ User.js

│   │   # --- Begin: User.js ---
// models/User.js

const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

// Role constants
const ROLES = ['admin', 'owner', 'tenant'];

const userSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'Please provide your name'],
    trim: true,
    maxlength: [50, 'Name cannot exceed 50 characters'],
  },
  email: {
    type: String,
    required: [true, 'Please provide your email'],
    unique: true,
    lowercase: true,
    trim: true,
    match: [
      /^\S+@\S+\.\S+$/,
      'Please provide a valid email address',
    ],
  },
  password: {
    type: String,
    required: [true, 'Please set a password'],
    minlength: [6, 'Password must be at least 6 characters'],
    select: false, // Hide in queries by default
  },
  role: {
    type: String,
    enum: ROLES,
    default: 'tenant',
  },
  phone: {
    type: String,
    trim: true,
    maxlength: 15,
  },
  profilePic: {
    type: String, // URL to profile image (optional)
    default: '',
  },
  loginAttempts: {
    type: Number,
    default: 0,
  },
  lastLogin: {
    type: Date,
    default: null,
  },
  isActive: {
    type: Boolean,
    default: true,
  },
}, {
  timestamps: true,
});

// Hash password before saving
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next(); // Only hash if changed

  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

// Method to compare entered password with stored hash
userSchema.methods.comparePassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

│   │   # --- End: User.js ---

│   ├─ routes/
│   │   ├─ adminRoutes.js

│   │   # --- Begin: adminRoutes.js ---
const express = require('express');
const router = express.Router();
const adminController = require('../controllers/adminController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Admin-only routes
router.use(authMiddleware);
router.use(roleMiddleware('admin'));
const validate = require('../middleware/validate');
const {
  societyCreateValidator,
} = require('../validators/societyValidator');
const {
  
  assignOwnerValidator,
} = require('../validators/flatValidator');

// Core society & building management
router.post('/societies', societyCreateValidator, validate, adminController.createSociety);

router.get('/societies/my', adminController.getMySocieties);
router.post('/buildings', adminController.createBuilding);
router.delete('/buildings/:id', adminController.deleteBuilding);

// Flat management
router.patch('/flats/:flatId/assign-owner', assignOwnerValidator, validate, adminController.assignOwnerToFlat);
router.patch('/flats/:flatId/remove-owner', adminController.removeFlatOwner);

router.patch('/flats/:flatId/remove-tenant', adminController.removeFlatTenant);

// Maintenance
router.post('/maintenance', adminController.generateMaintenance);
router.get('/maintenance/status', adminController.getMaintenanceStatus);

// Rent
router.get('/rent/history', adminController.getRentHistory);

// Ownership requests
router.get('/ownership-requests', adminController.getOwnershipRequests);
router.patch('/ownership-requests/:id', adminController.reviewOwnershipRequest);

// Announcements
router.post('/announcements', adminController.createAnnouncement);

// Complaints
router.get('/complaints', adminController.getComplaints);
router.patch('/complaints/:id', adminController.updateComplaintStatus);

// Dashboard & documents
router.get('/dashboard/overview', adminController.getAdminDashboard);
// router.get('/documents', adminController.getAllAgreements);
router.get('/flats/:flatId/info', adminController.getFlatInfo);

// Notes & reminders
router.patch('/societies/:id/note', adminController.addSocietyNote);
router.post('/users/:userID/reminder', adminController.sendReminderToUser);

module.exports = router;

│   │   # --- End: adminRoutes.js ---

│   │   ├─ announcementRoutes.js

│   │   # --- Begin: announcementRoutes.js ---
// routes/announcementRoutes.js

const express = require('express');
const router = express.Router();
const announcementController = require('../controllers/announcementController');

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');

// Protected routes for admin
router.post('/', authMiddleware, roleMiddleware(['admin']), announcementController.createAnnouncement);
router.delete('/:id', authMiddleware, roleMiddleware(['admin']), announcementController.deleteAnnouncement);

// Public route to fetch announcements for a society (optionally filter by building)
router.get('/:societyId', authMiddleware, announcementController.getAnnouncements);

module.exports = router;

│   │   # --- End: announcementRoutes.js ---

│   │   ├─ authRoutes.js

│   │   # --- Begin: authRoutes.js ---
// routes/authRoutes.js

const express = require('express');
const router = express.Router();

const authController = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

const validate = require('../middleware/validate');
const { registerValidator, loginValidator } = require('../validators/authValidator');
// Public Routes
router.post('/register', registerValidator, validate, authController.registerUser);
router.post('/login', loginValidator,validate, authController.loginUser);
router.get('/token-status', authController.tokenStatus);

// Protected Routes
router.post('/logout', protect, authController.logoutUser);
router.get('/me', protect, authController.getMe);
router.patch('/change-password', protect, authController.changePassword);

module.exports = router;

│   │   # --- End: authRoutes.js ---

│   │   ├─ complaintRoutes.js

│   │   # --- Begin: complaintRoutes.js ---
// controllers/complaintController.js

const {
    createComplaint,
    getComplaintsByUser,
    getAllComplaints,
    updateComplaintStatus
  } = require('../services/complaintService');
  const formatResponse = require('../utils/responseFormatter');
  const { asyncHandler } = require('../middleware/errorHandler');
  
  // For tenant or owner complaint creation
  exports.createComplaint = asyncHandler(async (req, res) => {
    const { flatId, category, subject, description } = req.body;
    const complaint = await createComplaint({
      raisedBy: req.user._id,
      userRole: req.user.role,
      flatId,
      category,
      subject,
      description
    });
  
    res.status(201).json(formatResponse({
      message: 'Complaint created successfully',
      data: complaint
    }));
  });
  
  // For fetching user’s own complaints
  exports.getMyComplaints = asyncHandler(async (req, res) => {
    const complaints = await getComplaintsByUser(req.user._id, req.user.role);
    res.json(formatResponse({
      message: 'Your complaints',
      data: complaints
    }));
  });
  
  // Admin: fetch all complaints
  exports.getAllComplaints = asyncHandler(async (req, res) => {
    const complaints = await getAllComplaints();
    res.json(formatResponse({
      message: 'All complaints retrieved',
      data: complaints
    }));
  });
  
  // Admin: update complaint status
  exports.updateComplaintStatus = asyncHandler(async (req, res) => {
    const { complaintId, status, adminNote } = req.body;
  
    const complaint = await updateComplaintStatus({
      complaintId,
      status,
      adminNote,
      resolvedBy: req.user._id
    });
  
    res.json(formatResponse({
      message: 'Complaint updated',
      data: complaint
    }));
  });
  
│   │   # --- End: complaintRoutes.js ---

│   │   ├─ ownerRoutes.js

│   │   # --- Begin: ownerRoutes.js ---
const express = require('express');
const router = express.Router();

const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyOwnerAssigned } = require('../middleware/roleAccessGuard');
const ownerController = require('../controllers/ownerController');

// 🔐 Authenticate → Confirm Role → Confirm Assignment
router.use(authMiddleware);
router.use(roleMiddleware('owner'));
router.use(verifyOwnerAssigned);

// 📦 Flat Management
router.get('/flats', ownerController.getMyFlats);
router.get('/flats/:id/society', ownerController.getFlatSocietyInfo);

// 📨 Ownership Requests
router.post('/ownership-request', ownerController.submitOwnershipRequest);
router.patch('/flats/:id/assign-tenant', ownerController.assignTenantToMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', ownerController.getRentHistory);
router.get('/maintenance-due', ownerController.getUnpaidMaintenance);
router.patch('/maintenance/:maintenanceId/pay', ownerController.payMaintenance);
router.patch('/flats/:flatId/remove-tenant', ownerController.removeTenantFromMyFlat);
router.patch('/flats/:flatId/update-tenant', ownerController.updateTenantForMyFlat);

// 🛠 Complaints
router.post('/complaints', ownerController.fileComplaint);
router.get('/complaints', ownerController.getMyComplaints);

// 📊 Dashboard
router.get('/dashboard/overview', ownerController.getOwnerDashboard);

module.exports = router;

│   │   # --- End: ownerRoutes.js ---

│   │   ├─ ownershipRequestRoutes.js

│   │   # --- Begin: ownershipRequestRoutes.js ---
// routes/ownershipRequestRoutes.js
const express = require('express');
const router = express.Router();
const controller = require('../controllers/ownershipRequestController');
const { protect } = require('../middleware/authMiddleware');
const { roleMiddleware } = require('../middleware/roleMiddleware');

// Admin routes
router.get('/', protect, roleMiddleware(['admin']), controller.getOwnershipRequests);
router.patch('/:requestId', protect, roleMiddleware(['admin']), controller.reviewOwnershipRequest);

module.exports = router;

│   │   # --- End: ownershipRequestRoutes.js ---

│   │   ├─ tenantRoutes.js

│   │   # --- Begin: tenantRoutes.js ---
const express = require('express');
const router = express.Router();

const tenantController = require('../controllers/tenantController');
const authMiddleware = require('../middleware/authMiddleware');
const roleMiddleware = require('../middleware/roleMiddleware');
const { verifyTenantAssigned } = require('../middleware/roleAccessGuard');

// 🔐 Middleware to enforce auth + tenant role + flat assignment
router.use(authMiddleware);
router.use(roleMiddleware('tenant'));
router.use(verifyTenantAssigned);

// 🏠 Flat Info
router.get('/my-flat', tenantController.getMyFlat);

// 💰 Rent & Maintenance
router.get('/rent-history', tenantController.getRentHistory);
router.get('/current-rent', tenantController.getCurrentRent);
router.patch('/rent/:rentId/pay', tenantController.payRent);
router.get('/maintenance-due', tenantController.getUnpaidMaintenance);
router.patch('/maintenance/:maintenanceId/pay', tenantController.payMaintenance);
router.patch('/profile', tenantController.updateMyProfile);

// 🛠 Complaints
router.post('/complaints', tenantController.fileComplaint);
router.get('/complaints', tenantController.getMyComplaints);

// 📣 Announcements
router.get('/announcements', tenantController.getAnnouncements);

// 📊 Dashboard
router.get('/dashboard/overview', tenantController.getTenantDashboard);

module.exports = router;

│   │   # --- End: tenantRoutes.js ---

│   ├─ services/
│   │   ├─ authService.js

│   │   # --- Begin: authService.js ---
// services/authService.js

const jwt = require('jsonwebtoken');
const User = require('../models/User');
const Flat = require('../models/Flat');

// Generate a signed JWT and return cookie options
exports.generateTokenCookie = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days
  });

  return token;
};

// Validate user login
exports.loginUser = async ({ email, password }) => {
  const user = await User.findOne({ email }).select('+password');
  if (!user || !(await user.comparePassword(password))) {
    throw new Error('Invalid email or password');
  }

  // If owner, must be assigned
  if (user.role === 'owner') {
    const flat = await Flat.findOne({ owner: user._id });
    if (!flat) throw new Error('Owner is not assigned to any flat');
  }

  // If tenant, must be assigned
  if (user.role === 'tenant') {
    const flat = await Flat.findOne({ tenant: user._id });
    if (!flat) throw new Error('Tenant is not assigned to any flat');
  }

  return user;
};

// Register new user
exports.registerUser = async ({ name, email, password, phone, role = 'tenant' }) => {
  const existing = await User.findOne({ email });
  if (existing) throw new Error('Email is already registered');

  const user = await User.create({ name, email, password, phone, role });
  return user;
};

// Change password
exports.changePassword = async ({ userId, currentPassword, newPassword }) => {
  const user = await User.findById(userId).select('+password');
  if (!user || !(await user.comparePassword(currentPassword))) {
    throw new Error('Current password is incorrect');
  }

  user.password = newPassword;
  await user.save();
};

// Token check
exports.validateToken = (token) => {
  return jwt.verify(token, process.env.JWT_SECRET);
};

│   │   # --- End: authService.js ---

│   │   ├─ complaintServices

│   │   # --- Begin: complaintServices ---
// services/complaintService.js
const Complaint = require('../models/Complaint');
const Flat = require('../models/Flat');

exports.createComplaint = async ({ raisedBy, userRole, flatId, category, subject, description }) => {
  const flat = await Flat.findById(flatId).populate('building society');
  if (!flat) throw new Error('Flat not found');

  const complaint = await Complaint.create({
    raisedBy,
    userRole,
    flat: flat._id,
    building: flat.building._id,
    society: flat.society._id,
    category,
    subject,
    description,
  });

  return complaint;
};

exports.getComplaintsByUser = async (userId, userRole) => {
  return await Complaint.find({ raisedBy: userId, userRole })
    .populate('flat')
    .populate('building')
    .populate('society');
};

// Updated getAllComplaints()
exports.getAllComplaints = async ({ page = 1, limit = 10, status, category }) => {
    const { skip } = require('../utils/pagination').paginate({ page, limit });
  
    const query = {};
    if (status) query.status = status;
    if (category) query.category = category;
  
    const complaints = await Complaint.find(query)
      .skip(skip)
      .limit(limit)
      .populate('raisedBy', 'name email role')
      .populate('flat building society');
  
    const total = await Complaint.countDocuments(query);
  
    return { complaints, total };
  };
  

// services/complaintService.js (add this)
exports.updateComplaintStatus = async ({ complaintId, status, adminNote, resolvedBy }) => {
    const complaint = await Complaint.findById(complaintId);
    if (!complaint) throw new Error('Complaint not found');
  
    complaint.status = status;
    complaint.adminNote = adminNote || '';
    complaint.resolvedBy = resolvedBy;
    complaint.resolvedOn = new Date();
  
    await complaint.save();
    return complaint;
  };
  
│   │   # --- End: complaintServices ---

│   │   ├─ flatService.js

│   │   # --- Begin: flatService.js ---
// services/flatService.js
const Flat = require('../models/Flat');
const User = require('../models/User');

exports.assignTenant = async ({ flatId, tenantId, ownerId }) => {
  const flat = await Flat.findOne({ _id: flatId, owner: ownerId }).populate('society');
  if (!flat) throw new Error('Unauthorized or flat not found');

  const tenant = await User.findById(tenantId);
  if (!tenant || tenant.role !== 'tenant') throw new Error('Invalid tenant');

  flat.tenant = tenant._id;
  flat.isRented = true;
  flat.occupancyStatus = 'occupied-tenant';
  await flat.save();

  if (!tenant.society) {
    tenant.society = flat.society._id;
    await tenant.save();
  }

  return flat;
};

│   │   # --- End: flatService.js ---

│   │   ├─ ownershipService.js

│   │   # --- Begin: ownershipService.js ---
// services/ownershipService.js
const OwnershipRequest = require('../models/OwnershipRequest');
const Flat = require('../models/Flat');

exports.reviewOwnershipRequest = async ({ requestId, status, note, reviewerId }) => {
  const request = await OwnershipRequest.findById(requestId);
  if (!request) throw new Error('Ownership request not found');

  request.status = status;
  request.adminNote = note;
  request.reviewedBy = reviewerId;
  request.reviewedOn = new Date();
  await request.save();

  if (status === 'approved') {
    await Flat.findByIdAndUpdate(request.flat, { owner: request.currentOwner });
  }

  return request;
};

│   │   # --- End: ownershipService.js ---

│   │   ├─ paymentService.js

│   │   # --- Begin: paymentService.js ---
// services/paymentService.js
const Maintenance = require('../models/Maintenance');
const Rent = require('../models/Rent');

exports.payMaintenance = async ({ maintenanceId, userId, role }) => {
  const maintenance = await Maintenance.findById(maintenanceId).populate('flat');
  if (!maintenance) throw new Error('Maintenance record not found');
  if (maintenance.isPaid) throw new Error('Already paid');

  const { flat } = maintenance;

  const isValid = (role === 'owner' && flat.owner.toString() === userId && !flat.tenant) ||
                  (role === 'tenant' && flat.tenant.toString() === userId);
  if (!isValid) throw new Error('Unauthorized payment');

  maintenance.isPaid = true;
  maintenance.paidOn = new Date();
  await maintenance.save();

  return maintenance;
};

exports.payRent = async ({ rentId, userId }) => {
  const rent = await Rent.findById(rentId).populate('tenant');
  if (!rent) throw new Error('Rent record not found');
  if (rent.isPaid) throw new Error('Rent already paid');

  if (rent.tenant._id.toString() !== userId) throw new Error('Unauthorized rent payment');

  rent.isPaid = true;
  rent.paidOn = new Date();
  await rent.save();

  return rent;
};

│   │   # --- End: paymentService.js ---

│   ├─ uploads/
│   ├─ utils/
│   │   ├─ formatResponse.js

│   │   # --- Begin: formatResponse.js ---
// utils/responseFormatter.js

const formatResponse = ({ success = true, message = '', data = null, statusCode = 200 }) => {
    return {
      success,
      message,
      data,
      statusCode
    };
  };
  
  module.exports = formatResponse;
│   │   # --- End: formatResponse.js ---

│   │   ├─ generateToken.js

│   │   # --- Begin: generateToken.js ---
const jwt = require('jsonwebtoken');

const generateToken = (res, userId) => {
  const token = jwt.sign({ id: userId }, process.env.JWT_SECRET, {
    expiresIn: process.env.JWT_EXPIRES_IN || '7d',
  });

  res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000,
  });

  return token;
};

module.exports = generateToken;

│   │   # --- End: generateToken.js ---

│   │   ├─ logger.js

│   │   # --- Begin: logger.js ---
// utils/logger.js
const morgan = require('morgan');

const logger = morgan(':method :url :status :res[content-length] - :response-time ms');

module.exports = logger;

│   │   # --- End: logger.js ---

│   │   ├─ pagination.js

│   │   # --- Begin: pagination.js ---

exports.paginateQuery = (req) => {
    const page = Math.max(1, parseInt(req.query.page) || 1);
    const limit = Math.max(1, parseInt(req.query.limit) || 10);
    const skip = (page - 1) * limit;
    return { page, limit, skip };
  }; 
│   │   # --- End: pagination.js ---

│   │   ├─ sendEmail.js

│   │   # --- Begin: sendEmail.js ---
const nodemailer = require('nodemailer');

const sendEmail = async (to, subject, text) => {
  try {
    if (!process.env.EMAIL_USER || !process.env.EMAIL_PASS) {
      console.warn('⚠️ Missing EMAIL credentials in .env');
      return;
    }

    const transporter = nodemailer.createTransport({
      service: 'gmail',
      auth: {
        user: process.env.EMAIL_USER,
        pass: process.env.EMAIL_PASS,
      },
    });

    await transporter.sendMail({ from: process.env.EMAIL_USER, to, subject, text });
  } catch (error) {
    console.error('❌ Failed to send email:', error.message);
  }
};

module.exports = sendEmail;

│   │   # --- End: sendEmail.js ---

│   │   ├─ validateEnv.js

│   │   # --- Begin: validateEnv.js ---
// utils/validateEnv.js
const required = [
    'PORT', 'MONGO_URI', 'JWT_SECRET', 'EMAIL_USER', 'EMAIL_PASS', 'CLIENT_URL'
  ];
  
  module.exports = function validateEnv() {
    required.forEach(key => {
      if (!process.env[key]) {
        throw new Error(`❌ Missing required environment variable: ${key}`);
      }
    });
  };
  
│   │   # --- End: validateEnv.js ---

│   ├─ validators/
│   │   ├─ authValidator.js

│   │   # --- Begin: authValidator.js ---
const { body } = require('express-validator');

exports.registerValidator = [
  body('name').notEmpty().withMessage('Name is required'),
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
];

exports.loginValidator = [
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').notEmpty().withMessage('Password is required'),
];
│   │   # --- End: authValidator.js ---

│   │   ├─ flatValidator.js

│   │   # --- Begin: flatValidator.js ---
const { body } = require('express-validator');

exports.assignOwnerValidator = [
  body('ownerId').notEmpty().withMessage('Owner ID is required'),
];

exports.assignTenantValidator = [
  body('tenantId').notEmpty().withMessage('Tenant ID is required'),
];
│   │   # --- End: flatValidator.js ---

│   │   ├─ societyValidator.js

│   │   # --- Begin: societyValidator.js ---
exports.societyCreateValidator = [
    body('name').notEmpty().withMessage('Name is required'),
    body('registrationNumber').notEmpty().withMessage('Registration number is required'),
    body('address.street').notEmpty().withMessage('Street is required'),
    body('address.city').notEmpty().withMessage('City is required'),
    body('address.state').notEmpty().withMessage('State is required'),
    body('address.pincode').notEmpty().withMessage('Pincode is required'),
    body('maintenancePolicy.frequency').notEmpty().withMessage('Maintenance frequency is required'),
    body('maintenancePolicy.amountPerFlat').isNumeric().withMessage('Maintenance amount must be a number'),
  ];
│   │   # --- End: societyValidator.js ---

